diff --git a/geometry2/package.xml b/geometry2/package.xml
index 5d32c060..94c37f8b 100644
--- a/geometry2/package.xml
+++ b/geometry2/package.xml
@@ -18,7 +18,7 @@
   <buildtool_depend>ament_cmake</buildtool_depend>
 
   <exec_depend>tf2</exec_depend>
-  <exec_depend>tf2_bullet</exec_depend>
+  <!--exec_depend>tf2_bullet</exec_depend-->
   <exec_depend>tf2_eigen</exec_depend>
   <exec_depend>tf2_eigen_kdl</exec_depend>
   <exec_depend>tf2_geometry_msgs</exec_depend>
diff --git a/test_tf2/CHANGELOG.rst b/test_tf2/CHANGELOG.rst
deleted file mode 100644
index 221d2821..00000000
--- a/test_tf2/CHANGELOG.rst
+++ /dev/null
@@ -1,335 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package test_tf2
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-0.25.7 (2024-05-29)
--------------------
-
-0.25.6 (2024-02-16)
--------------------
-
-0.25.5 (2023-11-13)
--------------------
-
-0.25.4 (2023-09-19)
--------------------
-
-0.25.3 (2023-07-17)
--------------------
-
-0.25.2 (2023-01-10)
--------------------
-
-0.25.1 (2022-08-05)
--------------------
-
-0.25.0 (2022-04-05)
--------------------
-* Fix more instances of Eigen problems on RHEL. (`#515 <https://github.com/ros2/geometry2/issues/515>`_)
-* Install includes to include/${PROJECT_NAME} and use modern CMake (`#493 <https://github.com/ros2/geometry2/issues/493>`_)
-* Contributors: Chris Lalancette, Shane Loretz
-
-0.24.0 (2022-03-31)
--------------------
-
-0.23.0 (2022-03-28)
--------------------
-* Fix precision loss from using rclcpp::Time::seconds() (`#511 <https://github.com/ros2/geometry2/issues/511>`_)
-* Contributors: Kenji Brameld
-
-0.22.0 (2022-03-01)
--------------------
-
-0.21.0 (2022-01-14)
--------------------
-
-0.20.0 (2021-12-17)
--------------------
-
-0.19.0 (2021-10-15)
--------------------
-* More Intuitive CLI for Static Transform Publisher (`#392 <https://github.com/ros2/geometry2/issues/392>`_)
-* Contributors: Hunter L. Allen
-
-0.18.0 (2021-06-01)
--------------------
-* Conversion tests for toMsg() (`#423 <https://github.com/ros2/geometry2/issues/423>`_)
-* Deprecate tf2_geometry_msgs.h (`#418 <https://github.com/ros2/geometry2/issues/418>`_)
-* Deprecate tf2_kdl.h (`#414 <https://github.com/ros2/geometry2/issues/414>`_)
-* Deprecate tf2_bullet.h (`#412 <https://github.com/ros2/geometry2/issues/412>`_)
-* Contributors: Bjar Ne, Chris Lalancette
-
-0.17.1 (2021-04-06)
--------------------
-
-0.17.0 (2021-03-19)
--------------------
-
-0.16.0 (2021-01-25)
--------------------
-
-0.15.1 (2020-12-08)
--------------------
-
-0.15.0 (2020-11-02)
--------------------
-* Update maintainers of the ros2/geometry2 fork. (`#328 <https://github.com/ros2/geometry2/issues/328>`_)
-* Contributors: Chris Lalancette
-
-0.14.1 (2020-09-21)
--------------------
-* Activate usual compiler warnings and fix errors (`#270 <https://github.com/ros2/geometry2/issues/270>`_)
-* Contributors: Ivan Santiago Paunovic
-
-0.14.0 (2020-08-14)
--------------------
-* Fix a TOCTTOU race in tf2. (`#307 <https://github.com/ros2/geometry2/issues/307>`_)
-* Fixed memory leak in Buffer::waitForTransform (`#281 <https://github.com/ros2/geometry2/issues/281>`_)
-* relax test timings to pass with Connext (`#304 <https://github.com/ros2/geometry2/issues/304>`_)
-* Explicitly initialize instances of tf2::Duration (`#291 <https://github.com/ros2/geometry2/issues/291>`_)
-* Generate callbacks after updating message\_ (`#274 <https://github.com/ros2/geometry2/issues/274>`_)
-* fix test_static_publisher in macos (`#284 <https://github.com/ros2/geometry2/issues/284>`_)
-* Fix up the dependencies in test_tf2. (`#277 <https://github.com/ros2/geometry2/issues/277>`_)
-* Split tf2_ros in tf2_ros and tf2_ros_py (`#210 <https://github.com/ros2/geometry2/issues/210>`_)
-* Contributors: Alejandro Hernández Cordero, Chris Lalancette, Dirk Thomas, Martin Ganeff, Michael Carroll, ymd-stella
-
-0.13.4 (2020-06-03)
--------------------
-
-0.13.3 (2020-05-26)
--------------------
-
-0.13.2 (2020-05-18)
--------------------
-* Fix deprecation warnings from launch (`#264 <https://github.com/ros2/geometry2/issues/264>`_)
-* Contributors: Chris Lalancette
-
-0.13.1 (2020-05-08)
--------------------
-
-0.13.0 (2020-04-30)
--------------------
-* Replace deprecated launch_ros usage (`#250 <https://github.com/ros2/geometry2/issues/250>`_)
-* Remote ready_fn from launch_testing tests (`#243 <https://github.com/ros2/geometry2/issues/243>`_)
-* [test_tf2] Call project() and ament_package() if not building tests (`#233 <https://github.com/ros2/geometry2/issues/233>`_)
-* Porting test_tf2  (`#203 <https://github.com/ros2/geometry2/issues/203>`_)
-* Contributors: Alejandro Hernández Cordero, Jacob Perron, Peter Baughman
-
-0.5.15 (2017-01-24)
--------------------
-
-0.5.14 (2017-01-16)
--------------------
-* Typos.
-* Adds unit tests for TF loaded from parameter server.
-  This tests both success (loading a valid TF into the param server) and
-  failures (parameter does not exist, parameter contents are invalid).
-* Code linting & reorganization
-  - whitespace
-  - indentation
-  - re-organized code to remove duplications.
-  whitespace & indentation changes only.
-  simplified (de-duplicated) duplicate code.
-  missing a duplicate variable.
-  whitespace changes only.
-* Contributors: Felix Duvallet
-
-0.5.13 (2016-03-04)
--------------------
-* Remove LGPL from license tags
-  LGPL was erroneously included in 2a38724. As there are no files with it
-  in the package.
-* Contributors: Jochen Sprickerhof
-
-0.5.12 (2015-08-05)
--------------------
-* add utilities to get yaw, pitch, roll and identity transform
-* provide more conversions between types
-  The previous conversion always assumed that it was converting a
-  non-message type to a non-message type. Now, one, both or none
-  can be a message or a non-message.
-* Contributors: Vincent Rabaud
-
-0.5.11 (2015-04-22)
--------------------
-
-0.5.10 (2015-04-21)
--------------------
-
-0.5.9 (2015-03-25)
-------------------
-
-0.5.8 (2015-03-17)
-------------------
-* remove useless Makefile files
-* Contributors: Vincent Rabaud
-
-0.5.7 (2014-12-23)
-------------------
-
-0.5.6 (2014-09-18)
-------------------
-
-0.5.5 (2014-06-23)
-------------------
-* Removed AsyncSpinner workaround
-* Contributors: Esteve Fernandez
-
-0.5.4 (2014-05-07)
-------------------
-* Clean up warnings about autostart and add some assertions for coverage
-* Contributors: Tully Foote
-
-0.5.3 (2014-02-21)
-------------------
-
-0.5.2 (2014-02-20)
-------------------
-
-0.5.1 (2014-02-14)
-------------------
-
-0.5.0 (2014-02-14)
-------------------
-
-0.4.10 (2013-12-26)
--------------------
-* fixing kdl linking for tests
-* Contributors: Tully Foote
-
-0.4.9 (2013-11-06)
-------------------
-
-0.4.8 (2013-11-06)
-------------------
-* Fixed static_transform_publisher duplicate check, added rostest.
-
-0.4.7 (2013-08-28)
-------------------
-
-0.4.6 (2013-08-28)
-------------------
-
-0.4.5 (2013-07-11)
-------------------
-* fixing quaternion in unit test and adding a timeout on the waitForServer
-* fixing usage string to show quaternions and using quaternions in the test app
-* removing redundant declaration
-* disabling whole cmake invocation in test_tf2 when not CATKIN_ENABLE_TESTING
-
-0.4.4 (2013-07-09)
-------------------
-
-0.4.3 (2013-07-05)
-------------------
-
-0.4.2 (2013-07-05)
-------------------
-
-0.4.1 (2013-07-05)
-------------------
-* fixing test target dependencies
-* fixing colliding target names between geometry and geometry_experimental
-* stripping tf2_ros dependency from tf2_bullet.  Test was moved to test_tf2
-
-0.4.0 (2013-06-27)
-------------------
-* splitting rospy dependency into tf2_py so tf2 is pure c++ library.
-* switching to console_bridge from rosconsole
-* moving convert methods back into tf2 because it does not have any ros dependencies beyond ros::Time which is already a dependency of tf2
-* Cleaning up unnecessary dependency on roscpp
-* converting contents of tf2_ros to be properly namespaced in the tf2_ros namespace
-* Cleaning up packaging of tf2 including:
-  removing unused nodehandle
-  fixing overmatch on search and replace
-  cleaning up a few dependencies and linking
-  removing old backup of package.xml
-  making diff minimally different from tf version of library
-* Restoring test packages and bullet packages.
-  reverting 3570e8c42f9b394ecbfd9db076b920b41300ad55 to get back more of the packages previously implemented
-  reverting 04cf29d1b58c660fdc999ab83563a5d4b76ab331 to fix `#7 <https://github.com/ros/geometry_experimental/issues/7>`_
-
-0.3.6 (2013-03-03)
-------------------
-
-0.3.5 (2013-02-15 14:46)
-------------------------
-
-0.3.4 (2013-02-15 13:14)
-------------------------
-
-0.3.3 (2013-02-15 11:30)
-------------------------
-
-0.3.2 (2013-02-15 00:42)
-------------------------
-
-0.3.1 (2013-02-14)
-------------------
-
-0.3.0 (2013-02-13)
-------------------
-* removing packages with missing deps
-* catkinizing geometry-experimental
-* add boost linkage
-* fixing test for header cleanup
-* fixing usage of bullet for migration to native bullet
-* Cleanup on test code, all tests pass
-* cleanup on optimized tests, still failing
-* Cleanup in compound transform test
-* Adding more frames to compound transform case
-* Compound transform test fails on optimized case after more frames added
-* Compound transform test has more frames in it
-* Cleanup of compount transform test
-* Compound transform at root node test fails for optimized branch
-* compount transform test, non-optimized
-* time-varying tests with different time-steps for optimized case
-* Time-varying test inserts data at different time-steps for non-optimized case
-* Helix (time-varying) test works on optimized branch
-* Adding more complicated case to helix test
-* Adding helix test for time-varying transforms in non-optimized case
-* Corrected ring45 values in buffer core test
-* Corrected values of ring45 test for non-optimized case
-* Ring 45 test running on non-optimized tf2 branch, from Tully's commit r880
-* filling out ring test case which finds errors in the optimization
-* Add option to use a callback queue in the message filter
-* another out-the-back test
-* move the message filter to tf2_ros
-* fix warnings
-* merge from tf_rework
-* tf2::MessageFilter + tests.  Still need to change it around to pass in a callback queue, since we're being triggered directly from the tf2 buffer
-* adding in y configuration test
-* a little more realistic
-* Don't add the request if the transform is already available.  Add some new tests
-* working transformable callbacks with a simple (incomplete) test case
-* cleaning up test setup
-* check_v implemented and passing v test and multi tree test
-* working toward multi configuration tests
-* removing restructuring for it won't nest like I thought
-* continuing restructuring and filling in test case setup
-* restructuring before scaling
-* Completely remove lookupLists().  canTransform() now uses the same walking code as lookupTransform().  Also fixed a bug in the static transform publisher test
-* testing chaining in a ring
-* test dataset generator
-* more complicated test with interleaving static and dynamic frames passing
-* static transform tested and working
-* test in progress, need to unshelve changes.
-* tests passing and all throw catches removed too\!
-* move to tf2_ros completed. tests pass again
-* merge tf2_cpp and tf2_py into tf2_ros
-* merging and fixing broken unittest
-* Got transform with types working in python
-* A working first version of transforming and converting between different types
-* removing unused datatypes
-* removing include of old tf from tf2
-* testing new argument validation and catching bug
-* unit test of single link one to try to debug eitan's client bug
-* working towards interpolation too
-* A working version of a test case for the python buffer client
-* merging
-* adding else to catch uncovered cases, and changing time for easier use
-* Adding a test for the python buffer client
-* using permuter now and doing a,b,c to a,b,c, at three different times including 0
-* Moving tf2_tests to test_tf2
-* moving test to new package
-* initial package created for testing tf2
diff --git a/test_tf2/CMakeLists.txt b/test_tf2/CMakeLists.txt
deleted file mode 100644
index a05818f3..00000000
--- a/test_tf2/CMakeLists.txt
+++ /dev/null
@@ -1,141 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-
-project(test_tf2)
-
-find_package(ament_cmake REQUIRED)
-
-if(NOT BUILD_TESTING)
-  ament_package()
-  return()
-endif()
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)
-endif()
-
-find_package(ament_cmake_gtest REQUIRED)
-find_package(builtin_interfaces REQUIRED)
-# Work around broken find module in AlmaLinux/RHEL eigen3-devel from PowerTools repo
-find_package(Eigen3 QUIET NO_MODULE)
-if(NOT Eigen3_FOUND)
-  find_package(Eigen3 REQUIRED)
-endif()
-find_package(geometry_msgs REQUIRED)
-find_package(launch_testing_ament_cmake REQUIRED)
-find_package(rclcpp REQUIRED)
-find_package(tf2 REQUIRED)
-find_package(tf2_bullet REQUIRED)
-find_package(tf2_eigen REQUIRED)
-find_package(tf2_geometry_msgs REQUIRED)
-find_package(tf2_kdl REQUIRED)
-find_package(tf2_ros REQUIRED)
-
-ament_find_gtest()
-
-ament_add_gtest(buffer_core_test test/buffer_core_test.cpp)
-if(TARGET buffer_core_test)
-  target_link_libraries(buffer_core_test
-    ${builtin_interfaces_TARGETS}
-    ${geometry_msgs_TARGETS}
-    rclcpp::rclcpp
-    tf2::tf2
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_ros::tf2_ros)
-endif()
-
-ament_add_gtest(test_message_filter test/test_message_filter.cpp)
-if(TARGET test_message_filter)
-  target_link_libraries(test_message_filter
-    ${builtin_interfaces_TARGETS}
-    ${geometry_msgs_TARGETS}
-    rclcpp::rclcpp
-    tf2::tf2
-    tf2_ros::tf2_ros)
-endif()
-
-ament_add_gtest(test_convert test/test_convert.cpp)
-if(TARGET test_convert)
-  target_link_libraries(test_convert
-    ${geometry_msgs_TARGETS}
-    tf2::tf2
-    tf2_bullet::tf2_bullet
-    tf2_eigen::tf2_eigen
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_kdl::tf2_kdl)
-  if(TARGET Eigen3::Eigen)
-    # TODO(sloretz) require target to exist when https://github.com/ros2/choco-packages/issues/19 is addressed
-    target_link_libraries(test_convert Eigen3::Eigen)
-  else()
-    target_include_directories(test_convert PRIVATE ${Eigen3_INCLUDE_DIRS})
-  endif()
-endif()
-
-ament_add_gtest(test_utils test/test_utils.cpp)
-if(TARGET test_utils)
-  target_link_libraries(test_utils
-    ${geometry_msgs_TARGETS}
-    tf2::tf2
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_kdl::tf2_kdl)
-endif()
-
-add_executable(test_buffer_server test/test_buffer_server.cpp)
-if(TARGET test_buffer_server)
-  target_link_libraries(test_buffer_server
-    rclcpp::rclcpp
-    tf2_ros::tf2_ros)
-endif()
-
-add_executable(test_buffer_client test/test_buffer_client.cpp)
-if(TARGET test_buffer_client)
-  target_link_libraries(test_buffer_client
-    ${GTEST_LIBRARIES}
-    rclcpp::rclcpp
-    tf2_bullet::tf2_bullet
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_kdl::tf2_kdl
-    tf2_ros::tf2_ros)
-  add_launch_test(test/buffer_client_tester.launch.py)
-endif()
-
-add_executable(test_static_publisher test/test_static_publisher.cpp)
-if(TARGET test_static_publisher)
-  target_link_libraries(test_static_publisher
-    ${GTEST_LIBRARIES}
-    ${geometry_msgs_TARGETS}
-    rclcpp::rclcpp
-    tf2::tf2
-    tf2_ros::tf2_ros)
-  add_launch_test(test/static_publisher.launch.py)
-endif()
-
-ament_add_gtest(test_tf2_bullet test/test_tf2_bullet.cpp)
-if(TARGET test_tf2_bullet)
-  target_link_libraries(test_tf2_bullet
-    rclcpp::rclcpp
-    tf2_bullet::tf2_bullet
-    tf2_ros::tf2_ros
-    tf2::tf2)
-endif()
-
-# TODO(ahcorde): enable once python part of tf2_geometry_msgs is working
-# add_launch_test(test/test_buffer_client.launch.py)
-
-# install executables
-install(TARGETS
-  test_buffer_client
-  test_buffer_server
-  test_static_publisher
-  DESTINATION lib/${PROJECT_NAME}
-)
-install(PROGRAMS
-  test/test_buffer_client.py
-  DESTINATION lib/${PROJECT_NAME}
-)
-
-ament_package()
diff --git a/test_tf2/mainpage.dox b/test_tf2/mainpage.dox
deleted file mode 100644
index a01bfa21..00000000
--- a/test_tf2/mainpage.dox
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
-\mainpage
-\htmlinclude manifest.html
-
-\b test_tf2 is ... 
-
-<!-- 
-Provide an overview of your package.
--->
-
-
-\section codeapi Code API
-
-<!--
-Provide links to specific auto-generated API documentation within your
-package that is of particular interest to a reader. Doxygen will
-document pretty much every part of your code, so do your best here to
-point the reader to the actual API.
-
-If your codebase is fairly large or has different sets of APIs, you
-should use the doxygen 'group' tag to keep these APIs together. For
-example, the roscpp documentation has 'libros' group.
--->
-
-
-*/
diff --git a/test_tf2/package.xml b/test_tf2/package.xml
deleted file mode 100644
index b0cdbe42..00000000
--- a/test_tf2/package.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<package format="2">
-  <name>test_tf2</name>
-  <version>0.25.7</version>
-  <description>
-    tf2 unit tests
-  </description>
-  <maintainer email="clalancette@openrobotics.org">Chris Lalancette</maintainer>
-  <maintainer email="alejandro@openrobotics.org">Alejandro Hernandez Cordero</maintainer>
-  <license>BSD</license>
-  <url type="website">http://www.ros.org/wiki/geometry_experimental</url>
-  <author email="tfoote@osrfoundation.org">Tully Foote</author>
-  <author>Eitan Marder-Eppstein</author>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <build_depend>eigen</build_depend>
-
-  <depend>builtin_interfaces</depend>
-  <depend>geometry_msgs</depend>
-  <depend>rclcpp</depend>
-  <depend>tf2</depend>
-  <depend>tf2_bullet</depend>
-  <depend>tf2_eigen</depend>
-  <depend>tf2_geometry_msgs</depend>
-  <depend>tf2_kdl</depend>
-  <depend>tf2_ros</depend>
-
-  <test_depend>ament_cmake_gtest</test_depend>
-  <test_depend>launch_ros</test_depend>
-  <test_depend>launch_testing_ament_cmake</test_depend>
-  <test_depend>tf2_ros_py</test_depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
diff --git a/test_tf2/test/buffer_client_tester.launch.py b/test_tf2/test/buffer_client_tester.launch.py
deleted file mode 100644
index 5cd426c5..00000000
--- a/test_tf2/test/buffer_client_tester.launch.py
+++ /dev/null
@@ -1,56 +0,0 @@
-# generated from buildfarm_perf_tests/test/test_performance.py.in
-# generated code does not contain a copyright notice
-
-import unittest
-
-from launch import LaunchDescription
-import launch
-from launch_ros.actions import Node
-from launch.substitutions import LaunchConfiguration
-import launch_testing
-import launch_testing.actions
-
-
-def generate_test_description():
-    node_under_test = Node(
-        package='test_tf2',
-        executable='test_buffer_client',
-        output='screen',
-        arguments=[],
-    )
-    node_static_transform_publisher = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "5", "--y", "6", "--z", "7", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "a", "--child-frame-id", "b"]
-    )
-
-    node_buffer_server = Node(
-        package='test_tf2',
-        executable='test_buffer_server',
-        output='screen',
-        arguments=[],
-        sigterm_timeout=LaunchConfiguration('sigterm_timeout', default=2)
-    )
-    return LaunchDescription([
-        node_static_transform_publisher,
-        node_buffer_server,
-        node_under_test,
-        launch_testing.util.KeepAliveProc(),
-        launch_testing.actions.ReadyToTest(),
-        ]), locals()
-
-
-class TestBufferClient(unittest.TestCase):
-
-    def test_termination(self, node_under_test, proc_info):
-        proc_info.assertWaitForShutdown(process=node_under_test, timeout=(10))
-
-
-@launch_testing.post_shutdown_test()
-class BufferClientTestAfterShutdown(unittest.TestCase):
-
-    def test_exit_code(self, proc_info):
-        # Check that all processes in the launch (in this case, there's just one) exit
-        # with code 0
-        launch_testing.asserts.assertExitCodes(proc_info)
diff --git a/test_tf2/test/buffer_core_test.cpp b/test_tf2/test/buffer_core_test.cpp
deleted file mode 100644
index 8c50112f..00000000
--- a/test_tf2/test/buffer_core_test.cpp
+++ /dev/null
@@ -1,2875 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if _WIN32
-#define _USE_MATH_DEFINES
-#endif
-#include <chrono>
-#include <cmath>
-#include <functional>
-#include <limits>
-#include <string>
-#include <vector>
-
-#include <gtest/gtest.h>
-
-#include <builtin_interfaces/msg/time.hpp>
-#include <geometry_msgs/msg/quaternion.hpp>
-#include <geometry_msgs/msg/transform.hpp>
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rclcpp/rclcpp.hpp>
-#include <tf2/buffer_core.h>
-#include <tf2/exceptions.h>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2/time.h>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-#include <tf2_ros/buffer_interface.h>
-
-#include "permuter.hpp"
-
-void seed_rand()
-{
-  //Seed random number generator with current time.
-  srand((unsigned) time(0));
-}
-
-void generate_rand_vectors(double scale, uint64_t runs, std::vector<double>& xvalues, std::vector<double>& yvalues, std::vector<double>&zvalues)
-{
-  (void)scale;
-  seed_rand();
-  for ( uint64_t i = 0; i < runs ; i++ )
-  {
-    xvalues[i] = 1.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-    yvalues[i] = 1.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-    zvalues[i] = 1.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-  }
-}
-
-
-void setIdentity(geometry_msgs::msg::Transform& trans)
-{
-  trans.translation.x = 0;
-  trans.translation.y = 0;
-  trans.translation.z = 0;
-  trans.rotation.x = 0;
-  trans.rotation.y = 0;
-  trans.rotation.z = 0;
-  trans.rotation.w = 1;
-}
-
-
-void push_back_i(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-  /*
-     "a"
-     v   (1,0)
-     "b"
-     v   (1,0)
-     "c"
-  */
-
-  children.push_back("b");
-  parents.push_back("a");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-  children.push_back("c");
-  parents.push_back("b");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-}
-
-
-void push_back_y(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-    /*
-      "a"
-      v  (1,0)
-      "b" ------(0,1)-----> "d"
-      v  (1,0)              v  (0,1)
-      "c"                   "e"
-    */
-    // a>b
-    children.push_back("b");
-    parents.push_back("a");
-    dx.push_back(1.0);
-    dy.push_back(0.0);
-     // b>c
-    children.push_back("c");
-    parents.push_back("b");
-    dx.push_back(1.0);
-    dy.push_back(0.0);
-     // b>d
-    children.push_back("d");
-    parents.push_back("b");
-    dx.push_back(0.0);
-    dy.push_back(1.0);
-     // d>e
-    children.push_back("e");
-    parents.push_back("d");
-    dx.push_back(0.0);
-    dy.push_back(1.0);
-}
-
-void push_back_v(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-  /*
-    "a" ------(0,1)-----> "f"
-    v  (1,0)              v  (0,1)
-    "b"                   "g"
-    v  (1,0)
-    "c"
-  */
-  // a>b
-  children.push_back("b");
-  parents.push_back("a");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-  // b>c
-  children.push_back("c");
-  parents.push_back("b");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-  // a>f
-  children.push_back("f");
-  parents.push_back("a");
-  dx.push_back(0.0);
-  dy.push_back(1.0);
-  // f>g
-  children.push_back("g");
-  parents.push_back("f");
-  dx.push_back(0.0);
-  dy.push_back(1.0);
-
-}
-
-void push_back_1(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-  children.push_back("2");
-  parents.push_back("1");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-}
-
-void setupTree(tf2::BufferCore& mBC, const std::string& mode, const builtin_interfaces::msg::Time & time, const tf2::Duration& interpolation_space = tf2::durationFromSec(0.0))
-{
-
-  mBC.clear();
-
-  std::vector<std::string> children;
-  std::vector<std::string> parents;
-  std::vector<double> dx, dy;
-
-  if (mode == "i")
-  {
-    push_back_i(children, parents, dx, dy);
-  }
-  else if (mode == "y")
-  {
-    push_back_y(children, parents, dx, dy);
-  }
-
-  else if (mode == "v")
-  {
-    push_back_v(children, parents, dx, dy);
-  }
-
-  else if (mode == "ring_45")
-  {
-    /* Form a ring of transforms at every 45 degrees on the unit circle.  */
-
-    std::vector<std::string> frames;
-
-    frames.push_back("a");
-    frames.push_back("b");
-    frames.push_back("c");
-    frames.push_back("d");
-    frames.push_back("e");
-    frames.push_back("f");
-    frames.push_back("g");
-    frames.push_back("h");
-    frames.push_back("i");
-
-    for (uint8_t iteration = 0; iteration < 2; ++iteration)
-    {
-      double direction = 1;
-      std::string frame_prefix;
-      if (iteration == 0)
-      {
-        frame_prefix = "inverse_";
-        direction = -1;
-      }
-      else
-      {
-        frame_prefix ="";
-      }
-      for (uint64_t i = 1; i <  frames.size(); i++)
-      {
-        geometry_msgs::msg::TransformStamped ts;
-        setIdentity(ts.transform);
-        ts.transform.translation.x = direction * ( sqrt(2)/2 - 1);
-        ts.transform.translation.y = direction * sqrt(2)/2;
-        ts.transform.rotation.x = 0;
-        ts.transform.rotation.y = 0;
-        ts.transform.rotation.z = sin(direction * M_PI/8);
-        ts.transform.rotation.w = cos(direction * M_PI/8);
-
-        double time_seconds = time.sec + time.nanosec / 1e9;
-        double time_interpolation_space = tf2::durationToSec(interpolation_space) * .5;
-
-        if (time_seconds > time_interpolation_space )
-        {
-          double time_stamp = time_seconds - time_interpolation_space;
-          ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-        }
-        else
-        {
-          ts.header.stamp = builtin_interfaces::msg::Time();
-        }
-
-        ts.header.frame_id = frame_prefix + frames[i-1];
-        if (i > 1)
-          ts.child_frame_id = frame_prefix + frames[i];
-        else
-          ts.child_frame_id = frames[i]; // connect first frame
-        EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-        if (interpolation_space > tf2::Duration(0))
-        {
-          // TODO (ahcorde): review this
-          double time_stamp = time_seconds;// + time_interpolation_space;
-          ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-          EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-        }
-      }
-    }
-    return; // nonstandard setup return before standard executinog
-  }
-  else if (mode == "1")
-  {
-    push_back_1(children, parents, dx, dy);
-  }
-  else if (mode =="1_v")
-  {
-    push_back_1(children, parents, dx, dy);
-    push_back_v(children, parents, dx, dy);
-  }
-  else
-    EXPECT_FALSE("Undefined mode for tree setup.  Test harness improperly setup.");
-
-
-  /// Standard
-  for (uint64_t i = 0; i <  children.size(); i++)
-  {
-    geometry_msgs::msg::TransformStamped ts;
-    setIdentity(ts.transform);
-    ts.transform.translation.x = dx[i];
-    ts.transform.translation.y = dy[i];
-    double time_seconds = time.sec +  time.nanosec / 1e9;
-    double time_interpolation_space = tf2::durationToSec(interpolation_space) * .5;
-    if (time_seconds > time_interpolation_space ){
-      double time_stamp = time_seconds - time_interpolation_space;
-      ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-    }
-    else
-    {
-      ts.header.stamp = builtin_interfaces::msg::Time();
-    }
-
-    ts.header.frame_id = parents[i];
-    ts.child_frame_id = children[i];
-    EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-    if (interpolation_space > tf2::Duration(0))
-    {
-      // TODO (ahcorde): review this
-      double time_stamp = time_seconds;// + time_interpolation_space;
-      ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-      EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-    }
-  }
-}
-
-
-TEST(BufferCore_setTransform, NoInsertOnSelfTransform)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "same_frame";
-  tranStamped.child_frame_id = "same_frame";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-}
-
-TEST(BufferCore_setTransform, NoInsertWithNan)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "same_frame";
-  tranStamped.child_frame_id = "other_frame";
-  EXPECT_TRUE(mBC.setTransform(tranStamped, "authority"));
-  tranStamped.transform.translation.x = std::numeric_limits<float>::quiet_NaN();
-  EXPECT_TRUE(std::isnan(tranStamped.transform.translation.x));
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-}
-
-TEST(BufferCore_setTransform, NoInsertWithNoFrameID)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "same_frame";
-  tranStamped.child_frame_id = "";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-  tranStamped.child_frame_id = "/";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-
-}
-
-TEST(BufferCore_setTransform, NoInsertWithNoParentID)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "";
-  tranStamped.child_frame_id = "some_frame";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-
-  tranStamped.header.frame_id = "/";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-}
-
-// /*
-// TEST(tf, ListOneInverse)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped (btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "child");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("my_parent",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, ListTwoInverse)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "child", "grandchild");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "grandchild");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("my_parent",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), 2*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), 2*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), 2*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-//
-// TEST(tf, ListOneForward)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "my_parent");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("child",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), -xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), -yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), -zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, ListTwoForward)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "child", "grandchild");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "my_parent");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("grandchild",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), -2*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), -2*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), -2*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, TransformThrougRoot)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(1000 + i*100),  "my_parent", "childA");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(1000 + i*100),  "my_parent", "childB");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000 + i*100), "childA");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("childB",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), 0*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), 0*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), 0*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, TransformThroughNO_PARENT)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parentA", "childA");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parentB", "childB");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<btTransform> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "childA");
-//     bool exception_thrown = false;
-//
-//     try{
-//     Stamped<btTransform> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("childB",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), 0*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), 0*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), 0*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       exception_thrown = true;
-//     }
-//     EXPECT_TRUE(exception_thrown);
-//   }
-//
-// }
-//
-// */
-
-TEST(BufferCore_lookupTransform, i_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while(permuter.step())
-  {
-    tf2::BufferCore mBC;
-    setupTree(mBC, "i", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_EQ(outpose.header.stamp, eval_time);
-    EXPECT_EQ(outpose.header.frame_id, source_frame);
-    EXPECT_EQ(outpose.child_frame_id, target_frame);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-    //Zero distance
-    if (source_frame == target_frame)
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    }
-    else if ((source_frame == "a" && target_frame =="b") ||
-             (source_frame == "b" && target_frame =="c"))
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    }
-    else if ((source_frame == "b" && target_frame =="a") ||
-             (source_frame == "c" && target_frame =="b"))
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    }
-    else if (source_frame == "a" && target_frame =="c")
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    }
-    else if (source_frame == "c" && target_frame =="a")
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    }
-    else
-    {
-      EXPECT_FALSE("i configuration: Shouldn't get here");
-      printf("source_frame %s target_frame %s time %f\n", source_frame.c_str(), target_frame.c_str(), eval_time.sec + eval_time.nanosec /1e9 );
-    }
-  }
-}
-
-/* Check 1 result return false if test parameters unmet */
-bool check_1_result(const geometry_msgs::msg::TransformStamped& outpose, const std::string& source_frame, const std::string& target_frame, const builtin_interfaces::msg::Time& eval_time, double epsilon)
-{
-  EXPECT_EQ(outpose.header.stamp, eval_time);
-  EXPECT_EQ(outpose.header.frame_id, source_frame);
-  EXPECT_EQ(outpose.child_frame_id, target_frame);
-  EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-  //Zero distance
-  if (source_frame == target_frame)
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-  }
-  else if (source_frame == "1" && target_frame =="2")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-  }
-  else if (source_frame == "2" && target_frame =="1")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-  }
-  else
-  {
-    return false;
-  }
-  return true;
-}
-
-/* Check v result return false if test parameters unmet */
-bool check_v_result(const geometry_msgs::msg::TransformStamped& outpose, const std::string& source_frame, const std::string& target_frame, const builtin_interfaces::msg::Time& eval_time, double epsilon)
-{
-  EXPECT_EQ(outpose.header.stamp, eval_time);
-  EXPECT_EQ(outpose.header.frame_id, source_frame);
-  EXPECT_EQ(outpose.child_frame_id, target_frame);
-  EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-  //Zero distance
-  if (source_frame == target_frame)
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-  }
-  else if ((source_frame == "a" && target_frame =="b") ||
-           (source_frame == "b" && target_frame =="c"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "b" && target_frame =="a") ||
-           (source_frame == "c" && target_frame =="b"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "a" && target_frame =="f") ||
-           (source_frame == "f" && target_frame =="g"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if ((source_frame == "f" && target_frame =="a") ||
-           (source_frame == "g" && target_frame =="f"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="g")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "g" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "b" && target_frame =="f")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "f" && target_frame =="b")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="f")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "f" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "b" && target_frame =="g")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "g" && target_frame =="b")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="g")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "g" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else
-  {
-    return false;
-  }
-  return true;
-}
-
-/* Check v result return false if test parameters unmet */
-bool check_y_result(const geometry_msgs::msg::TransformStamped& outpose, const std::string& source_frame, const std::string& target_frame, const builtin_interfaces::msg::Time& eval_time, double epsilon)
-{
-  EXPECT_EQ(outpose.header.stamp, eval_time);
-  EXPECT_EQ(outpose.header.frame_id, source_frame);
-  EXPECT_EQ(outpose.child_frame_id, target_frame);
-  EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-  //Zero distance
-  if (source_frame == target_frame)
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-  }
-  else if ((source_frame == "a" && target_frame =="b") ||
-           (source_frame == "b" && target_frame =="c"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "b" && target_frame =="a") ||
-           (source_frame == "c" && target_frame =="b"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "b" && target_frame =="d") ||
-           (source_frame == "d" && target_frame =="e"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if ((source_frame == "d" && target_frame =="b") ||
-           (source_frame == "e" && target_frame =="d"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "b" && target_frame =="e")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "e" && target_frame =="b")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="d")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "d" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="d")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "d" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="e")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "e" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="e")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "e" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else
-  {
-    return false;
-  }
-  return true;
-}
-
-
-TEST(BufferCore_lookupTransform, one_link_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  // permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("1");
-  frames.push_back("2");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "1", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_TRUE(check_1_result(outpose, source_frame, target_frame, eval_time, epsilon));
-  }
-}
-
-
-TEST(BufferCore_lookupTransform, v_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  //  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("f");
-  frames.push_back("g");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "v", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_TRUE(check_v_result(outpose, source_frame, target_frame, eval_time, epsilon));
-  }
-}
-
-
-TEST(BufferCore_lookupTransform, y_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  //  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("d");
-  frames.push_back("e");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "y", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_TRUE(check_y_result(outpose, source_frame, target_frame, eval_time, epsilon));
-  }
-}
-
-TEST(BufferCore_lookupTransform, multi_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  //  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("1");
-  frames.push_back("2");
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("f");
-  frames.push_back("g");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "1_v", eval_time, interpolation_space);
-
-    if (mBC.canTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time)))
-    {
-      geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-      if ((source_frame == "1" || source_frame =="2") && (target_frame =="1" || target_frame == "2"))
-        EXPECT_TRUE(check_1_result(outpose, source_frame, target_frame, eval_time, epsilon));
-      else if ((source_frame == "a" || source_frame == "b" || source_frame == "c" || source_frame == "f" || source_frame == "g") &&
-               (target_frame == "a" || target_frame == "b" || target_frame == "c" || target_frame == "f" || target_frame == "g"))
-        EXPECT_TRUE(check_v_result(outpose, source_frame, target_frame, eval_time, epsilon));
-      else
-        EXPECT_FALSE("Frames unhandled");
-    }
-    else
-      EXPECT_TRUE(((source_frame == "a" || source_frame =="b" || source_frame == "c" || source_frame == "f" || source_frame == "g") &&
-                   (target_frame == "1" || target_frame == "2") )
-                  ||
-                  ((target_frame == "a" || target_frame =="b" || target_frame == "c" || target_frame == "f" || target_frame == "g") &&
-                   (source_frame == "1" || source_frame == "2"))
-                  );
-
-  }
-}
-
-#define CHECK_QUATERNION_NEAR(_q1, _x, _y, _z, _w, _epsilon)                 \
-	   {                        											 \
-	   tf2::Quaternion q1(_q1.x, _q1.y, _q1.z, _q1.w);                          \
-       tf2::Quaternion q2(_x, _y, _z, _w);                                      \
-       double angle = q1.angle(q2);                                          \
-	   EXPECT_TRUE(fabs(angle) < _epsilon || fabs(angle - M_PI) < _epsilon); \
-	   }
-
-#define CHECK_TRANSFORMS_NEAR(_out, _expected, _eps)       																							            	            \
-	EXPECT_NEAR(_out.transform.translation.x, _expected.getOrigin().x(), epsilon); 											              			            				\
-	EXPECT_NEAR(_out.transform.translation.y, _expected.getOrigin().y(), epsilon); 															                        			\
-	EXPECT_NEAR(_out.transform.translation.z, _expected.getOrigin().z(), epsilon); 													            	             				\
-	CHECK_QUATERNION_NEAR(_out.transform.rotation, _expected.getRotation().x(), _expected.getRotation().y(), _expected.getRotation().z(), _expected.getRotation().w(), _eps);
-//
-// // TODO(ahcorde): btTransform
-// // Simple test with compound transform
-// TEST(BufferCore_lookupTransform, compound_xfm_configuration)
-// {
-// 	/*
-// 	 * Frames
-// 	 *
-// 	 * root->a
-// 	 *
-// 	 * root->b->c->d
-// 	 *
-// 	 */
-//
-// 	double epsilon = 2e-5; // Larger epsilon for interpolation values
-//
-//     tf2::BufferCore mBC;
-//
-//     geometry_msgs::msg::TransformStamped tsa;
-//     tsa.header.frame_id = "root";
-//     tsa.child_frame_id  = "a";
-//     tsa.transform.translation.x = 1.0;
-//     tsa.transform.translation.y = 1.0;
-//     tsa.transform.translation.z = 1.0;
-//     tf2::Quaternion q1;
-//     q1.setEuler(0.25, .5, .75);
-//     tsa.transform.rotation.x = q1.x();
-//     tsa.transform.rotation.y = q1.y();
-//     tsa.transform.rotation.z = q1.z();
-//     tsa.transform.rotation.w = q1.w();
-//     EXPECT_TRUE(mBC.setTransform(tsa, "authority"));
-//
-//     geometry_msgs::msg::TransformStamped tsb;
-//     tsb.header.frame_id = "root";
-//     tsb.child_frame_id  = "b";
-//     tsb.transform.translation.x = -1.0;
-//     tsb.transform.translation.y =  0.0;
-//     tsb.transform.translation.z = -1.0;
-//     tf2::Quaternion q2;
-//     q2.setEuler(1.0, 0.25, 0.5);
-//     tsb.transform.rotation.x = q2.x();
-//     tsb.transform.rotation.y = q2.y();
-//     tsb.transform.rotation.z = q2.z();
-//     tsb.transform.rotation.w = q2.w();
-//     EXPECT_TRUE(mBC.setTransform(tsb, "authority"));
-//
-//     geometry_msgs::msg::TransformStamped tsc;
-//     tsc.header.frame_id = "b";
-//     tsc.child_frame_id  = "c";
-//     tsc.transform.translation.x =  0.0;
-//     tsc.transform.translation.y =  2.0;
-//     tsc.transform.translation.z =  0.5;
-//     tf2::Quaternion q3;
-//     q3.setEuler(0.25, .75, 1.25);
-//     tsc.transform.rotation.x = q3.x();
-//     tsc.transform.rotation.y = q3.y();
-//     tsc.transform.rotation.z = q3.z();
-//     tsc.transform.rotation.w = q3.w();
-//     EXPECT_TRUE(mBC.setTransform(tsc, "authority"));
-//
-//     geometry_msgs::msg::TransformStamped tsd;
-//     tsd.header.frame_id = "c";
-//     tsd.child_frame_id  = "d";
-//     tsd.transform.translation.x =  0.5;
-//     tsd.transform.translation.y =  -1;
-//     tsd.transform.translation.z =  1.5;
-//     tf2::Quaternion q4;
-//     q4.setEuler(-0.5, 1.0, -.75);
-//     tsd.transform.rotation.x = q4.x();
-//     tsd.transform.rotation.y = q4.y();
-//     tsd.transform.rotation.z = q4.z();
-//     tsd.transform.rotation.w = q4.w();
-//     EXPECT_TRUE(mBC.setTransform(tsd, "authority"));
-//
-//     btTransform ta, tb, tc, td, expected_ab, expected_bc, expected_cb, expected_ac, expected_ba, expected_ca, expected_ad, expected_da, expected_bd, expected_db, expected_rootd, expected_rootc;
-//     ta.setOrigin(btVector3(1.0,  1.0,  1.0));
-//     ta.setRotation(q1);
-//     tb.setOrigin(btVector3(-1.0, 0.0, -1.0));
-//     tb.setRotation(q2);
-//     tc.setOrigin(btVector3(0.0, 2.0, 0.5));
-//     tc.setRotation(q3);
-//     td.setOrigin(btVector3(0.5, -1, 1.5));
-//     td.setRotation(q4);
-//
-//
-//     expected_ab = ta.inverse() * tb;
-//     expected_ac = ta.inverse() * tb * tc;
-//     expected_ad = ta.inverse() * tb * tc * td;
-//     expected_cb = tc.inverse();
-//     expected_bc = tc;
-//     expected_bd = tc * td;
-//     expected_db = expected_bd.inverse();
-//     expected_ba = tb.inverse() * ta;
-//     expected_ca = tc.inverse() * tb.inverse() * ta;
-//     expected_da = td.inverse() * tc.inverse() * tb.inverse() * ta;
-//     expected_rootd = tb * tc * td;
-//     expected_rootc = tb * tc;
-//
-//     // root -> b -> c
-//     geometry_msgs::msg::TransformStamped out_rootc = mBC.lookupTransform("root", "c", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_rootc, expected_rootc, epsilon);
-//
-//     // root -> b -> c -> d
-//     geometry_msgs::msg::TransformStamped out_rootd = mBC.lookupTransform("root", "d", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_rootd, expected_rootd, epsilon);
-//
-//     // a <- root -> b
-//     geometry_msgs::msg::TransformStamped out_ab = mBC.lookupTransform("a", "b", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ab, expected_ab, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_ba = mBC.lookupTransform("b", "a", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ba, expected_ba, epsilon);
-//
-//     // a <- root -> b -> c
-//     geometry_msgs::msg::TransformStamped out_ac = mBC.lookupTransform("a", "c", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ac, expected_ac, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_ca = mBC.lookupTransform("c", "a", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ca, expected_ca, epsilon);
-//
-//     // a <- root -> b -> c -> d
-//     geometry_msgs::msg::TransformStamped out_ad = mBC.lookupTransform("a", "d", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ad, expected_ad, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_da = mBC.lookupTransform("d", "a", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_da, expected_da, epsilon);
-//
-//     // b -> c
-//     geometry_msgs::msg::TransformStamped out_cb = mBC.lookupTransform("c", "b", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_cb, expected_cb, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_bc = mBC.lookupTransform("b", "c", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_bc, expected_bc, epsilon);
-//
-//     // b -> c -> d
-//     geometry_msgs::msg::TransformStamped out_bd = mBC.lookupTransform("b", "d", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_bd, expected_bd, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_db = mBC.lookupTransform("d", "b", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_db, expected_db, epsilon);
-// }
-
-// TODO(ahcorde)
-// Time varying transforms, testing interpolation
-// TEST(BufferCore_lookupTransform, helix_configuration)
-// {
-// 	double epsilon = 2e-5; // Larger epsilon for interpolation values
-//
-//     tf2::BufferCore mBC;
-//
-//     builtin_interfaces::msg::Time t0;
-//     t0.sec = 10;
-//     t0.nanosec = 0;
-//     tf2::Duration step      = tf2::durationFromSec(0.05);
-//     tf2::Duration half_step = tf2::durationFromSec(0.025);
-//     builtin_interfaces::msg::Time t1;
-//     double t1_seconds = tf2::durationToSec(tf2::durationFromSec(5.0)) + t0.sec + t0.nanosec;
-//     t0.sec = (int)t1_seconds;
-//     t0.nanosec = (t1_seconds - (int)t1_seconds)/1e9;
-//
-//     /*
-//      * a->b->c
-//      *
-//      * b.z = vel * (t - t0)
-//      * c.x = cos(theta * (t - t0))
-//      * c.y = sin(theta * (t - t0))
-//      *
-//      * a->d
-//      *
-//      * d.z = 2 * cos(theta * (t - t0))
-//      * a->d transforms are at half-step between a->b->c transforms
-//      */
-//
-//     double theta = 0.25;
-//     double vel   = 1.0;
-//
-//     for (builtin_interfaces::msg::Time t = t0; t <= t1; t += step)
-//     {
-//     	builtin_interfaces::msg::Time t2 = t + half_step;
-//     	double dt  = (t - t0).toSec();
-//     	double dt2 = (t2 - t0).toSec();
-//
-//         geometry_msgs::msg::TransformStamped ts;
-//         ts.header.frame_id = "a";
-//         ts.header.stamp    = t;
-//         ts.child_frame_id  = "b";
-//         ts.transform.translation.z = vel * dt;
-//         ts.transform.rotation.w = 1.0;
-//         EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-//
-//         geometry_msgs::msg::TransformStamped ts2;
-//         ts2.header.frame_id = "b";
-//         ts2.header.stamp    = t;
-//         ts2.child_frame_id  = "c";
-//         ts2.transform.translation.x = cos(theta * dt);
-//         ts2.transform.translation.y = sin(theta * dt);
-//         tf2::Quaternion q;
-//         q.setEuler(0,0,theta*dt);
-//         ts2.transform.rotation.z = q.z();
-//         ts2.transform.rotation.w = q.w();
-//         EXPECT_TRUE(mBC.setTransform(ts2, "authority"));
-//
-//         geometry_msgs::msg::TransformStamped ts3;
-//         ts3.header.frame_id = "a";
-//         ts3.header.stamp    = t2;
-//         ts3.child_frame_id  = "d";
-//         ts3.transform.translation.z = cos(theta * dt2);
-//         ts3.transform.rotation.w = 1.0;
-//         EXPECT_TRUE(mBC.setTransform(ts3, "authority"));
-//     }
-//
-//
-//     for (builtin_interfaces::msg::Time t = t0 + half_step; t < t1; t += step)
-//     {
-//     	builtin_interfaces::msg::Time t2 = t + half_step;
-//     	double dt  = (t - t0).toSec();
-//     	double dt2 = (t2 - t0).toSec();
-//
-//         geometry_msgs::msg::TransformStamped out_ab = mBC.lookupTransform("a", "b", t);
-//         EXPECT_NEAR(out_ab.transform.translation.z, vel * dt, epsilon);
-//
-//         geometry_msgs::msg::TransformStamped out_ac = mBC.lookupTransform("a", "c", t);
-//         EXPECT_NEAR(out_ac.transform.translation.x, cos(theta * dt), epsilon);
-//         EXPECT_NEAR(out_ac.transform.translation.y, sin(theta * dt), epsilon);
-//         EXPECT_NEAR(out_ac.transform.translation.z, vel * dt, 		 epsilon);
-//         tf2::Quaternion q;
-//         q.setEuler(0,0,theta*dt);
-//         CHECK_QUATERNION_NEAR(out_ac.transform.rotation, 0, 0, q.z(), q.w(), epsilon);
-//
-//         geometry_msgs::msg::TransformStamped out_ad = mBC.lookupTransform("a", "d", t);
-//         EXPECT_NEAR(out_ad.transform.translation.z, cos(theta * dt), epsilon);
-//
-//         geometry_msgs::msg::TransformStamped out_cd = mBC.lookupTransform("c", "d", t2);
-//         EXPECT_NEAR(out_cd.transform.translation.x, -1,           			      epsilon);
-//         EXPECT_NEAR(out_cd.transform.translation.y,  0,  			              epsilon);
-//         EXPECT_NEAR(out_cd.transform.translation.z, cos(theta * dt2) - vel * dt2, epsilon);
-//         tf2::Quaternion mq;
-//         mq.setEuler(0,0,-theta*dt2);
-//         CHECK_QUATERNION_NEAR(out_cd.transform.rotation, 0, 0, mq.z(), mq.w(), epsilon);
-//     }
-//
-//     // Advanced API
-//     for (builtin_interfaces::msg::Time t = t0 + half_step; t < t1; t += (step + step))
-//     {
-//     	builtin_interfaces::msg::Time t2 = t + step;
-//     	double dt  = (t - t0).toSec();
-//     	double dt2 = (t2 - t0).toSec();
-//
-//         geometry_msgs::msg::TransformStamped out_cd2 = mBC.lookupTransform("c", t, "d", t2, "a");
-//         EXPECT_NEAR(out_cd2.transform.translation.x, -1,           			      epsilon);
-//         EXPECT_NEAR(out_cd2.transform.translation.y,  0,  			              epsilon);
-//         EXPECT_NEAR(out_cd2.transform.translation.z, cos(theta * dt2) - vel * dt, epsilon);
-//         tf2::Quaternion mq2;
-//         mq2.setEuler(0,0,-theta*dt);
-//         CHECK_QUATERNION_NEAR(out_cd2.transform.rotation, 0, 0, mq2.z(), mq2.w(), epsilon);
-//     }
-// }
-//
-
-TEST(BufferCore_lookupTransform, ring_45_configuration)
-{
-  double epsilon = 1e-6;
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("d");
-  frames.push_back("e");
-  frames.push_back("f");
-  frames.push_back("g");
-  frames.push_back("h");
-  frames.push_back("i");
-  /*  frames.push_back("inverse_b");
-  frames.push_back("inverse_c");
-  frames.push_back("inverse_d");
-  frames.push_back("inverse_e");
-  frames.push_back("inverse_f");
-  frames.push_back("inverse_g");
-  frames.push_back("inverse_h");
-  frames.push_back("inverse_i");*/
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "ring_45", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_EQ(outpose.header.stamp, eval_time);
-    EXPECT_EQ(outpose.header.frame_id, source_frame);
-    EXPECT_EQ(outpose.child_frame_id, target_frame);
-
-    //Zero distance or all the way
-    if (source_frame == target_frame               ||
-        (source_frame == "a" && target_frame == "i") ||
-        (source_frame == "i" && target_frame == "a") ||
-        (source_frame == "a" && target_frame == "inverse_i") ||
-        (source_frame == "inverse_i" && target_frame == "a") )
-    {
-      //printf ("here %s %s\n", source_frame.c_str(), target_frame.c_str());
-      EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-      EXPECT_NEAR(fabs(outpose.transform.rotation.w), 1, epsilon);
-    }
-    // Chaining 1
-    else if ((source_frame == "a" && target_frame =="b") ||
-             (source_frame == "b" && target_frame =="c") ||
-             (source_frame == "c" && target_frame =="d") ||
-             (source_frame == "d" && target_frame =="e") ||
-             (source_frame == "e" && target_frame =="f") ||
-             (source_frame == "f" && target_frame =="g") ||
-             (source_frame == "g" && target_frame =="h") ||
-             (source_frame == "h" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI/8), epsilon);
-    }
-    // Inverse Chaining 1
-    else if ((source_frame == "b" && target_frame =="a") ||
-             (source_frame == "c" && target_frame =="b") ||
-             (source_frame == "d" && target_frame =="c") ||
-             (source_frame == "e" && target_frame =="d") ||
-             (source_frame == "f" && target_frame =="e") ||
-             (source_frame == "g" && target_frame =="f") ||
-             (source_frame == "h" && target_frame =="g") ||
-             (source_frame == "i" && target_frame =="h")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(-M_PI/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(-M_PI/8), epsilon);
-    }
-    // Chaining 2
-    else if ((source_frame == "a" && target_frame =="c") ||
-             (source_frame == "b" && target_frame =="d") ||
-             (source_frame == "c" && target_frame =="e") ||
-             (source_frame == "d" && target_frame =="f") ||
-             (source_frame == "e" && target_frame =="g") ||
-             (source_frame == "f" && target_frame =="h") ||
-             (source_frame == "g" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI/4), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI/4), epsilon);
-    }
-    // Inverse Chaining 2
-    else if ((source_frame == "c" && target_frame =="a") ||
-             (source_frame == "d" && target_frame =="b") ||
-             (source_frame == "e" && target_frame =="c") ||
-             (source_frame == "f" && target_frame =="d") ||
-             (source_frame == "g" && target_frame =="e") ||
-             (source_frame == "h" && target_frame =="f") ||
-             (source_frame == "i" && target_frame =="g")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(-M_PI/4), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(-M_PI/4), epsilon);
-    }
-    // Chaining 3
-    else if ((source_frame == "a" && target_frame =="d") ||
-             (source_frame == "b" && target_frame =="e") ||
-             (source_frame == "c" && target_frame =="f") ||
-             (source_frame == "d" && target_frame =="g") ||
-             (source_frame == "e" && target_frame =="h") ||
-             (source_frame == "f" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2)/2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI*3/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI*3/8), epsilon);
-    }
-    // Inverse Chaining 3
-    else if ((target_frame == "a" && source_frame =="d") ||
-             (target_frame == "b" && source_frame =="e") ||
-             (target_frame == "c" && source_frame =="f") ||
-             (target_frame == "d" && source_frame =="g") ||
-             (target_frame == "e" && source_frame =="h") ||
-             (target_frame == "f" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2)/2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, - sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI*3/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*3/8), epsilon);
-    }
-    // Chaining 4
-    else if ((source_frame == "a" && target_frame =="e") ||
-             (source_frame == "b" && target_frame =="f") ||
-             (source_frame == "c" && target_frame =="g") ||
-             (source_frame == "d" && target_frame =="h") ||
-             (source_frame == "e" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 0 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI/2), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI/2), epsilon);
-    }
-    // Inverse Chaining 4
-    else if ((target_frame == "a" && source_frame =="e") ||
-             (target_frame == "b" && source_frame =="f") ||
-             (target_frame == "c" && source_frame =="g") ||
-             (target_frame == "d" && source_frame =="h") ||
-             (target_frame == "e" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 0 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI/2), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(-M_PI/2), epsilon);
-    }
-    // Chaining 5
-    else if ((source_frame == "a" && target_frame =="f") ||
-             (source_frame == "b" && target_frame =="g") ||
-             (source_frame == "c" && target_frame =="h") ||
-             (source_frame == "d" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2) /2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, - sqrt(2) /2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI*5/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI*5/8), epsilon);
-    }
-    // Inverse Chaining 5
-    else if ((target_frame == "a" && source_frame =="f") ||
-             (target_frame == "b" && source_frame =="g") ||
-             (target_frame == "c" && source_frame =="h") ||
-             (target_frame == "d" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2)/2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI*5/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*5/8), epsilon);
-    }
-    // Chaining 6
-    else if ((source_frame == "a" && target_frame =="g") ||
-             (source_frame == "b" && target_frame =="h") ||
-             (source_frame == "c" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(M_PI*6/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(M_PI*6/8), epsilon);
-    }
-    // Inverse Chaining 6
-    else if ((target_frame == "a" && source_frame =="g") ||
-             (target_frame == "b" && source_frame =="h") ||
-             (target_frame == "c" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI*6/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*6/8), epsilon);
-    }
-    // Chaining 7
-    else if ((source_frame == "a" && target_frame =="h") ||
-             (source_frame == "b" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(-M_PI*7/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*7/8), epsilon);
-    }
-    // Inverse Chaining 7
-    else if ((target_frame == "a" && source_frame =="h") ||
-             (target_frame == "b" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI*7/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(M_PI*7/8), epsilon);
-    }
-    else
-    {
-      EXPECT_FALSE("Ring_45 testing Shouldn't get here");
-      printf("source_frame %s target_frame %s time %f\n", source_frame.c_str(), target_frame.c_str(), eval_time.sec + eval_time.nanosec /1e9 );
-    }
-  }
-}
-
-TEST(BufferCore_lookupTransform, invalid_arguments)
-{
-  tf2::BufferCore mBC;
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(0) +
-      std::chrono::nanoseconds(0));
-
-  setupTree(mBC, "i", tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-
-  // EXPECT_NO_THROW
-  EXPECT_NO_THROW(mBC.lookupTransform("b", "a", eval_time_time_point));
-
-  //Empty frame_id
-  EXPECT_THROW(mBC.lookupTransform("", "a", eval_time_time_point), tf2::InvalidArgumentException);
-  EXPECT_THROW(mBC.lookupTransform("b", "", eval_time_time_point), tf2::InvalidArgumentException);
-  //
-  // //frame_id with /
-  EXPECT_THROW(mBC.lookupTransform("/b", "a", eval_time_time_point), tf2::InvalidArgumentException);
-  EXPECT_THROW(mBC.lookupTransform("b", "/a", eval_time_time_point), tf2::InvalidArgumentException);
-
-}
-
-TEST(BufferCore_canTransform, invalid_arguments)
-{
-  tf2::BufferCore mBC;
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(0) +
-      std::chrono::nanoseconds(0));
-
-  setupTree(mBC, "i", tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-
-  EXPECT_TRUE(mBC.canTransform("b", "a", eval_time_time_point));
-
-  //Empty frame_id
-  EXPECT_FALSE(mBC.canTransform("", "a", eval_time_time_point));
-  EXPECT_FALSE(mBC.canTransform("b", "", eval_time_time_point));
-
-  //frame_id with /
-  EXPECT_FALSE(mBC.canTransform("/b", "a", eval_time_time_point));
-  EXPECT_FALSE(mBC.canTransform("b", "/a", eval_time_time_point));
-
-}
-
-struct TransformableHelper
-{
-  TransformableHelper()
-  : called(false)
-  {}
-
-  void callback(tf2::TransformableRequestHandle request_handle,
-                const std::string & target_frame,
-                const std::string & source_frame,
-                tf2::TimePoint time,
-                tf2::TransformableResult result)
-  {
-    (void)request_handle;
-    (void)target_frame;
-    (void)source_frame;
-    (void)time;
-    (void)result;
-    called = true;
-  }
-
-  bool called;
-};
-
-TEST(BufferCore_transformableCallbacks, alreadyTransformable)
-{
-  tf2::BufferCore b;
-  TransformableHelper h;
-
-  geometry_msgs::msg::TransformStamped t;
-  t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(1.0));
-  t.header.frame_id = "a";
-  t.child_frame_id = "b";
-  t.transform.rotation.w = 1.0;
-  b.setTransform(t, "me");
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(1) +
-      std::chrono::nanoseconds(0));
-
-  tf2::BufferCore::TransformableCallback cb = std::bind(&TransformableHelper::callback,
-      &h,
-      std::placeholders::_1,
-      std::placeholders::_2,
-      std::placeholders::_3,
-      std::placeholders::_4,
-      std::placeholders::_5);
-
-  EXPECT_EQ(b.addTransformableRequest(cb, "a", "b", eval_time_time_point), 0U);
-}
-
-TEST(BufferCore_transformableCallbacks, waitForNewTransform)
-{
-  tf2::BufferCore b;
-  TransformableHelper h;
-  tf2::BufferCore::TransformableCallback cb = std::bind(&TransformableHelper::callback,
-      &h,
-      std::placeholders::_1,
-      std::placeholders::_2,
-      std::placeholders::_3,
-      std::placeholders::_4,
-      std::placeholders::_5);
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(10) +
-      std::chrono::nanoseconds(0));
-
-  EXPECT_GT(b.addTransformableRequest(cb, "a", "b", eval_time_time_point), 0U);
-
-  geometry_msgs::msg::TransformStamped t;
-  for (uint32_t i = 1; i <= 10; ++i)
-  {
-    t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(i));
-    t.header.frame_id = "a";
-    t.child_frame_id = "b";
-    t.transform.rotation.w = 1.0;
-    b.setTransform(t, "me");
-
-    if (i < 10)
-    {
-      ASSERT_FALSE(h.called);
-    }
-    else
-    {
-      ASSERT_TRUE(h.called);
-    }
-  }
-}
-
-TEST(BufferCore_transformableCallbacks, waitForOldTransform)
-{
-  tf2::BufferCore b;
-  TransformableHelper h;
-  tf2::BufferCore::TransformableCallback cb = std::bind(&TransformableHelper::callback,
-      &h,
-      std::placeholders::_1,
-      std::placeholders::_2,
-      std::placeholders::_3,
-      std::placeholders::_4,
-      std::placeholders::_5);
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(1) +
-      std::chrono::nanoseconds(0));
-
-  EXPECT_GT(b.addTransformableRequest(cb, "a", "b", eval_time_time_point), 0U);
-
-  geometry_msgs::msg::TransformStamped t;
-  for (uint32_t i = 10; i > 0; --i)
-  {
-    t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(i));
-    t.header.frame_id = "a";
-    t.child_frame_id = "b";
-    t.transform.rotation.w = 1.0;
-    b.setTransform(t, "me");
-
-    if (i > 1)
-    {
-      ASSERT_FALSE(h.called);
-    }
-    else
-    {
-      ASSERT_TRUE(h.called);
-    }
-  }
-}
-
-/*
-TEST(tf, Exceptions)
-{
-
- tf::Transformer mTR(true);
-
-
- Stamped<btTransform> outpose;
-
- //connectivity when no data
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(10000000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000000) , "me"), outpose);
-   EXPECT_FALSE("ConnectivityException Not Thrown");
- }
- catch ( tf::LookupException &ex)
- {
-   EXPECT_TRUE("Lookupgh Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
- mTR.setTransform( StampedTransform(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(100000), "parent", "me"));
-
- //Extrapolation not valid with one value
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(200000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(200000) , "me"), outpose);
-   EXPECT_TRUE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
- mTR.setTransform( StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(300000), "parent", "me"));
-
- //NO Extration when Interpolating
- //inverse list
- EXPECT_TRUE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(200000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(200000) , "me"), outpose);
-   EXPECT_TRUE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_FALSE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
-
- //forward list
- EXPECT_TRUE(mTR.canTransform("me", "parent", builtin_interfaces::msg::Time().fromNSec(200000)));
- try
- {
-   mTR.transformPose("me",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(200000) , "parent"), outpose);
-   EXPECT_TRUE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_FALSE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
- //Extrapolating backwards
- //inverse list
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(1000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000) , "me"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
- //forwards list
- EXPECT_FALSE(mTR.canTransform("me", "parent", builtin_interfaces::msg::Time().fromNSec(1000)));
- try
- {
-   mTR.transformPose("me",Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000) , "parent"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
-
- // Test extrapolation inverse and forward linkages FORWARD
-
- //inverse list
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(350000)));
- try
- {
-   mTR.transformPose("parent", Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(350000) , "me"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
- //forward list
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(350000)));
- try
- {
-   mTR.transformPose("me", Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(350000) , "parent"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
-
-
-}
-
-
-
-TEST(tf, NoExtrapolationExceptionFromParent)
-{
-  tf::Transformer mTR(true, tf2::Duration().fromNSec(1000000));
-
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000), "parent", "a"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent", "a"));
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent", "b"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent", "b"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent's parent", "parent"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent's parent's parent", "parent's parent"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent's parent", "parent"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent's parent's parent", "parent's parent"));
-
-  Stamped<Point> output;
-
-  try
-  {
-    mTR.transformPoint( "b", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(2000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    EXPECT_FALSE("Shouldn't have gotten this exception");
-  }
-
-
-
-};
-
-
-
-TEST(tf, ExtrapolationFromOneValue)
-{
-  tf::Transformer mTR(true, tf2::Duration().fromNSec(1000000));
-
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent", "a"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent's parent", "parent"));
-
-
-  Stamped<Point> output;
-
-  bool excepted = false;
-  //Past time
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(10), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  excepted = false;
-  //Future one element
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(100000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  //Past multi link
-  excepted = false;
-  try
-  {
-    mTR.transformPoint( "parent's parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(1), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  //Future case multi link
-  excepted = false;
-  try
-  {
-    mTR.transformPoint( "parent's parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(10000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(20000),  "parent", "a"));
-
-  excepted = false;
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(10000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_FALSE(excepted);
-
-};
-
-
-
-TEST(tf, getLatestCommonTime)
-{
-  tf::Transformer mTR(true);
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent", "a"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(2000),  "parent's parent", "parent"));
-
-  //simple case
-  builtin_interfaces::msg::Time t;
-  mTR.getLatestCommonTime("a", "parent's parent", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(1000));
-
-  //no connection
-  EXPECT_EQ(tf::LOOKUP_ERROR, mTR.getLatestCommonTime("a", "not valid", t, NULL));
-  EXPECT_EQ(t, builtin_interfaces::msg::Time());
-
-  //testing with update
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(3000),  "parent", "a"));
-  mTR.getLatestCommonTime("a", "parent's parent",t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(2000));
-
-  //longer chain
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "parent", "b"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(3000),  "b", "c"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(9000),  "c", "d"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(5000),  "f", "e"));
-
-  //shared parent
-  mTR.getLatestCommonTime("a", "b",t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-
-  //two degrees
-  mTR.getLatestCommonTime("a", "c", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-  //reversed
-  mTR.getLatestCommonTime("c", "a", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-
-  //three degrees
-  mTR.getLatestCommonTime("a", "d", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-  //reversed
-  mTR.getLatestCommonTime("d", "a", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-
-  //disconnected tree
-  mTR.getLatestCommonTime("e", "f", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(5000));
-  //reversed order
-  mTR.getLatestCommonTime("f", "e", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(5000));
-
-
-  mTR.setExtrapolationLimit(tf2::Duration().fromNSec(20000));
-
-  //check timestamps resulting
-  tf::Stamped<tf::Point> output, output2;
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time(), "b"), output);
-    mTR.transformPoint( "a", builtin_interfaces::msg::Time(),Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time(), "b"), "c",  output2);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("%s\n", ex.what());
-    EXPECT_FALSE("Shouldn't get this Exception");
-  }
-
-  EXPECT_EQ(output.stamp_, builtin_interfaces::msg::Time().fromNSec(4000));
-  EXPECT_EQ(output2.stamp_, builtin_interfaces::msg::Time().fromNSec(3000));
-
-
-  //zero length lookup zero time
-  builtin_interfaces::msg::Time now1 = builtin_interfaces::msg::Time::now();
-  builtin_interfaces::msg::Time time_output;
-  mTR.getLatestCommonTime("a", "a", time_output, NULL);
-  EXPECT_LE(now1.toSec(), time_output.toSec());
-  EXPECT_LE(time_output.toSec(), builtin_interfaces::msg::Time::now().toSec());
-
-
-}
-
-TEST(tf, RepeatedTimes)
-{
-  Transformer mTR;
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "parent", "b"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,1,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "parent", "b"));
-
-  tf::StampedTransform  output;
-  try{
-    mTR.lookupTransform("parent", "b" , builtin_interfaces::msg::Time().fromNSec(4000), output);
-    EXPECT_TRUE(!std::isnan(output.getOrigin().x()));
-    EXPECT_TRUE(!std::isnan(output.getOrigin().y()));
-    EXPECT_TRUE(!std::isnan(output.getOrigin().z()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().x()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().y()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().z()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().w()));
-  }
-  catch (...)
-  {
-    EXPECT_FALSE("Excetion improperly thrown");
-  }
-
-
-}
-
-TEST(tf, frameExists)
-{
-  Transformer mTR;
-
-  // test with fully qualified name
-  EXPECT_FALSE(mTR.frameExists("/b"));;
-  EXPECT_FALSE(mTR.frameExists("/parent"));
-  EXPECT_FALSE(mTR.frameExists("/other"));
-  EXPECT_FALSE(mTR.frameExists("/frame"));
-
-  //test with resolveping
-  EXPECT_FALSE(mTR.frameExists("b"));;
-  EXPECT_FALSE(mTR.frameExists("parent"));
-  EXPECT_FALSE(mTR.frameExists("other"));
-  EXPECT_FALSE(mTR.frameExists("frame"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/parent", "/b"));
-
-  // test with fully qualified name
-  EXPECT_TRUE(mTR.frameExists("/b"));
-  EXPECT_TRUE(mTR.frameExists("/parent"));
-  EXPECT_FALSE(mTR.frameExists("/other"));
-  EXPECT_FALSE(mTR.frameExists("/frame"));
-
-  //Test with resolveping
-  EXPECT_TRUE(mTR.frameExists("b"));
-  EXPECT_TRUE(mTR.frameExists("parent"));
-  EXPECT_FALSE(mTR.frameExists("other"));
-  EXPECT_FALSE(mTR.frameExists("frame"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,1,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/frame", "/other"));
-
-  // test with fully qualified name
-  EXPECT_TRUE(mTR.frameExists("/b"));
-  EXPECT_TRUE(mTR.frameExists("/parent"));
-  EXPECT_TRUE(mTR.frameExists("/other"));
-  EXPECT_TRUE(mTR.frameExists("/frame"));
-
-  //Test with resolveping
-  EXPECT_TRUE(mTR.frameExists("b"));
-  EXPECT_TRUE(mTR.frameExists("parent"));
-  EXPECT_TRUE(mTR.frameExists("other"));
-  EXPECT_TRUE(mTR.frameExists("frame"));
-
-}
-
-TEST(tf, resolve)
-{
-  //no prefix
-  EXPECT_STREQ("/id", tf::resolve("","id").c_str());
-  //prefix w/o /
-  EXPECT_STREQ("/asdf/id", tf::resolve("asdf","id").c_str());
-  //prefix w /
-  EXPECT_STREQ("/asdf/id", tf::resolve("/asdf","id").c_str());
-  // frame_id w / -> no prefix
-  EXPECT_STREQ("/id", tf::resolve("asdf","/id").c_str());
-  // frame_id w / -> no prefix
-  EXPECT_STREQ("/id", tf::resolve("/asdf","/id").c_str());
-
-}
-
-TEST(tf, canTransform)
-{
-  Transformer mTR;
-
-  //confirm zero length list disconnected will return true
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", builtin_interfaces::msg::Time()));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", builtin_interfaces::msg::Time::now()));
-
-  //Create a two link tree between times 10 and 20
-  for (int i = 10; i < 20; i++)
-  {
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "child"));
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "other_child"));
-  }
-
-  // four different timestamps related to tf state
-  builtin_interfaces::msg::Time zero_time = builtin_interfaces::msg::Time().fromSec(0);
-  builtin_interfaces::msg::Time old_time = builtin_interfaces::msg::Time().fromSec(5);
-  builtin_interfaces::msg::Time valid_time = builtin_interfaces::msg::Time().fromSec(15);
-  builtin_interfaces::msg::Time future_time = builtin_interfaces::msg::Time().fromSec(25);
-
-
-  //confirm zero length list disconnected will return true
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", zero_time));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", old_time));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", valid_time));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", future_time));
-
-  // Basic API Tests
-
-  //Valid data should pass
-  EXPECT_TRUE(mTR.canTransform("child", "parent", valid_time));
-  EXPECT_TRUE(mTR.canTransform("child", "other_child", valid_time));
-
-  //zero data should pass
-  EXPECT_TRUE(mTR.canTransform("child", "parent", zero_time));
-  EXPECT_TRUE(mTR.canTransform("child", "other_child", zero_time));
-
-  //Old data should fail
-  EXPECT_FALSE(mTR.canTransform("child", "parent", old_time));
-  EXPECT_FALSE(mTR.canTransform("child", "other_child", old_time));
-
-  //Future data should fail
-  EXPECT_FALSE(mTR.canTransform("child", "parent", future_time));
-  EXPECT_FALSE(mTR.canTransform("child", "other_child", future_time));
-
-  //Same Frame should pass for all times
-  EXPECT_TRUE(mTR.canTransform("child", "child", zero_time));
-  EXPECT_TRUE(mTR.canTransform("child", "child", old_time));
-  EXPECT_TRUE(mTR.canTransform("child", "child", valid_time));
-  EXPECT_TRUE(mTR.canTransform("child", "child", future_time));
-
-  // Advanced API Tests
-
-  // Source = Fixed
-  //zero data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", zero_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", zero_time, "other_child", valid_time, "child"));
-  //Old data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", old_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", old_time, "other_child", valid_time, "child"));
-  //valid data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "other_child", valid_time, "child"));
-  //future data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", future_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", future_time, "other_child", valid_time, "child"));
-
-  //transforming through fixed into the past
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "parent", old_time, "child"));
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "other_child", old_time, "child"));
-  //transforming through fixed into the future
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "parent", future_time, "child"));
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "other_child", future_time, "child"));
-
-  // Target = Fixed
-  //zero data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", zero_time, "parent", valid_time, "parent"));
-  //Old data in fixed frame should pass
-  EXPECT_FALSE(mTR.canTransform("child", old_time, "parent", valid_time, "parent"));
-  //valid data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", valid_time, "parent"));
-  //future data in fixed frame should pass
-  EXPECT_FALSE(mTR.canTransform("child", future_time, "parent", valid_time, "parent"));
-
-  //transforming through fixed into the zero
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", zero_time, "parent"));
-  //transforming through fixed into the past
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", old_time, "parent"));
-  //transforming through fixed into the valid
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", valid_time, "parent"));
-  //transforming through fixed into the future
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", future_time, "parent"));
-
-}
-
-TEST(tf, lookupTransform)
-{
-  Transformer mTR;
-  //Create a two link tree between times 10 and 20
-  for (int i = 10; i < 20; i++)
-  {
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "child"));
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "other_child"));
-  }
-
-  // four different timestamps related to tf state
-  builtin_interfaces::msg::Time zero_time = builtin_interfaces::msg::Time().fromSec(0);
-  builtin_interfaces::msg::Time old_time = builtin_interfaces::msg::Time().fromSec(5);
-  builtin_interfaces::msg::Time valid_time = builtin_interfaces::msg::Time().fromSec(15);
-  builtin_interfaces::msg::Time future_time = builtin_interfaces::msg::Time().fromSec(25);
-
-  //output
-  tf::StampedTransform output;
-
-  // Basic API Tests
-
-  try
-  {
-    //confirm zero length list disconnected will return true
-    mTR.lookupTransform("some_frame","some_frame", zero_time, output);
-    mTR.lookupTransform("some_frame","some_frame", old_time, output);
-    mTR.lookupTransform("some_frame","some_frame", valid_time, output);
-    mTR.lookupTransform("some_frame","some_frame", future_time, output);
-    mTR.lookupTransform("child","child", future_time, output);
-    mTR.lookupTransform("other_child","other_child", future_time, output);
-
-    //Valid data should pass
-    mTR.lookupTransform("child", "parent", valid_time, output);
-    mTR.lookupTransform("child", "other_child", valid_time, output);
-
-    //zero data should pass
-    mTR.lookupTransform("child", "parent", zero_time, output);
-    mTR.lookupTransform("child", "other_child", zero_time, output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception thrown");
-  }
-  try
-  {
-    //Old data should fail
-    mTR.lookupTransform("child", "parent", old_time, output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-  try {
-    //Future data should fail
-    mTR.lookupTransform("child", "parent", future_time, output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    //Same Frame should pass for all times
-    mTR.lookupTransform("child", "child", zero_time, output);
-    mTR.lookupTransform("child", "child", old_time, output);
-    mTR.lookupTransform("child", "child", valid_time, output);
-    mTR.lookupTransform("child", "child", future_time, output);
-
-    // Advanced API Tests
-
-    // Source = Fixed
-    //zero data in fixed frame should pass
-    mTR.lookupTransform("child", zero_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", zero_time, "other_child", valid_time, "child", output);
-    //Old data in fixed frame should pass
-    mTR.lookupTransform("child", old_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", old_time, "other_child", valid_time, "child", output);
-    //valid data in fixed frame should pass
-    mTR.lookupTransform("child", valid_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", valid_time, "other_child", valid_time, "child", output);
-    //future data in fixed frame should pass
-    mTR.lookupTransform("child", future_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", future_time, "other_child", valid_time, "child", output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception incorrectly thrown");
-  }
-
-  try {
-    //transforming through fixed into the past
-    mTR.lookupTransform("child", valid_time, "parent", old_time, "child", output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    //transforming through fixed into the future
-    mTR.lookupTransform("child", valid_time, "parent", future_time, "child", output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    // Target = Fixed
-    //zero data in fixed frame should pass
-    mTR.lookupTransform("child", zero_time, "parent", valid_time, "parent", output);
-    //valid data in fixed frame should pass
-    mTR.lookupTransform("child", valid_time, "parent", valid_time, "parent", output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception incorrectly thrown");
-  }
-
-  try {
-  //Old data in fixed frame should pass
-  mTR.lookupTransform("child", old_time, "parent", valid_time, "parent", output);
-      EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-  try {
-    //future data in fixed frame should pass
-    mTR.lookupTransform("child", future_time, "parent", valid_time, "parent", output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    //transforming through fixed into the zero
-    mTR.lookupTransform("child", valid_time, "parent", zero_time, "parent", output);
-    //transforming through fixed into the past
-    mTR.lookupTransform("child", valid_time, "parent", old_time, "parent", output);
-    //transforming through fixed into the valid
-    mTR.lookupTransform("child", valid_time, "parent", valid_time, "parent", output);
-    //transforming through fixed into the future
-    mTR.lookupTransform("child", valid_time, "parent", future_time, "parent", output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception improperly thrown");
-  }
-
-
-  //make sure zero goes to now for zero length
-  try
-  {
-    builtin_interfaces::msg::Time now1 = builtin_interfaces::msg::Time::now();
-
-    mTR.lookupTransform("a", "a", builtin_interfaces::msg::Time(),output);
-    EXPECT_LE(now1.toSec(), output.stamp_.toSec());
-    EXPECT_LE(output.stamp_.toSec(), builtin_interfaces::msg::Time::now().toSec());
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception improperly thrown");
-  }
-
-}
-
-
-TEST(tf, getFrameStrings)
-{
-  Transformer mTR;
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/parent", "/b"));
-  std::vector <std::string> frames_string;
-  mTR.getFrameStrings(frames_string);
-  ASSERT_EQ(frames_string.size(), (unsigned)2);
-  EXPECT_STREQ(frames_string[0].c_str(), std::string("/b").c_str());
-  EXPECT_STREQ(frames_string[1].c_str(), std::string("/parent").c_str());
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/frame", "/other"));
-
-  mTR.getFrameStrings(frames_string);
-  ASSERT_EQ(frames_string.size(), (unsigned)4);
-  EXPECT_STREQ(frames_string[0].c_str(), std::string("/b").c_str());
-  EXPECT_STREQ(frames_string[1].c_str(), std::string("/parent").c_str());
-  EXPECT_STREQ(frames_string[2].c_str(), std::string("/other").c_str());
-  EXPECT_STREQ(frames_string[3].c_str(), std::string("/frame").c_str());
-
-}
-
-bool expectInvalidQuaternion(tf::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-    printf("this should have thrown\n");
-    return false;
-  }
-  catch (tf::InvalidArgument &ex)
-  {
-    return true;
-  }
-  catch  (...)
-  {
-    printf("A different type of exception was expected\n");
-    return false;
-  }
-  return false;
-}
-
-bool expectValidQuaternion(tf::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-  }
-  catch (tf::TransformException &ex)
-  {
-    return false;
-  }
-  return true;
-}
-
-bool expectInvalidQuaternion(geometry_msgs::msg::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-    printf("this should have thrown\n");
-    return false;
-  }
-  catch (tf::InvalidArgument &ex)
-  {
-    return true;
-  }
-  catch  (...)
-  {
-    printf("A different type of exception was expected\n");
-    return false;
-  }
-  return false;
-}
-
-bool expectValidQuaternion(geometry_msgs::msg::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-  }
-  catch (tf::TransformException &ex)
-  {
-    return false;
-  }
-  return true;
-}
-
-
-TEST(tf, assertQuaternionValid)
-{
-  tf::Quaternion q(1,0,0,0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setX(0);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setY(1);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setZ(1);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setY(0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setW(1);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setZ(0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setZ(sqrt(2.0)/2.0);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setW(sqrt(2.0)/2.0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-
-  q.setZ(sqrt(2.0)/2.0 + 0.01);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-  q.setZ(sqrt(2.0)/2.0 - 0.01);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-  EXPECT_THROW(tf::assertQuaternionValid(q), tf::InvalidArgument);
-  //    Waiting for gtest 1.1 or later
-  //  EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-  //q.setX(0);
-  //EXPECT_THROW(tf::assertQuaternionValid(q), tf::InvalidArgument);
-  //q.setY(1);
-  //EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-
-}
-TEST(tf, assertQuaternionMsgValid)
-{
-  geometry_msgs::msg::Quaternion q;
-  q.x = 1;//others zeroed to start
-
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.x = 0;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.y = 1;
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.z = 1;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.y = 0;
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.w = 1;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.z = 0;
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.z = sqrt(2.0)/2.0;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.w = sqrt(2.0)/2.0;
-  EXPECT_TRUE(expectValidQuaternion(q));
-
-  q.z = sqrt(2.0)/2.0 + 0.01;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-  q.z = sqrt(2.0)/2.0 - 0.01;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-
-  //    Waiting for gtest 1.1 or later
-  //  EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-  //q.x = 0);
-  //EXPECT_THROW(tf::assertQuaternionValid(q), tf::InvalidArgument);
-  //q.y = 1);
-  //EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-
-}
-
-
-TEST(tf2_stamped, OperatorEqualEqual)
-{
-  btTransform transform0, transform1, transform0a;
-  transform0.setIdentity();
-  transform0a.setIdentity();
-  transform1.setIdentity();
-  transform1.setOrigin(btVector3(1, 0, 0));
-  tf2::StampedTransform stamped_transform_reference(transform0a, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id");
-  tf2::StampedTransform stamped_transform0A(transform0, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id");
-  EXPECT_TRUE(stamped_transform0A == stamped_transform_reference); // Equal
-  tf2::StampedTransform stamped_transform0B(transform0, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0B == stamped_transform_reference); // Different Frame id
-  tf2::StampedTransform stamped_transform0C(transform0, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0C == stamped_transform_reference); // Different Time
-  tf2::StampedTransform stamped_transform0D(transform0, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0D == stamped_transform_reference); // Different frame id and time
-  tf2::StampedTransform stamped_transform0E(transform1, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0E == stamped_transform_reference); // Different transform, frame id
-  tf2::StampedTransform stamped_transform0F(transform1, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0F == stamped_transform_reference); // Different transform, time
-  tf2::StampedTransform stamped_transform0G(transform1, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0G == stamped_transform_reference); // Different transform, frame id and time
-  tf2::StampedTransform stamped_transform0H(transform1, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0H == stamped_transform_reference); // Different transform
-
-
-  //Different child_frame_id
-  tf2::StampedTransform stamped_transform1A(transform0, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1A == stamped_transform_reference); // Equal
-  tf2::StampedTransform stamped_transform1B(transform0, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1B == stamped_transform_reference); // Different Frame id
-  tf2::StampedTransform stamped_transform1C(transform0, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1C == stamped_transform_reference); // Different Time
-  tf2::StampedTransform stamped_transform1D(transform0, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1D == stamped_transform_reference); // Different frame id and time
-  tf2::StampedTransform stamped_transform1E(transform1, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1E == stamped_transform_reference); // Different transform, frame id
-  tf2::StampedTransform stamped_transform1F(transform1, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1F == stamped_transform_reference); // Different transform, time
-  tf2::StampedTransform stamped_transform1G(transform1, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1G == stamped_transform_reference); // Different transform, frame id and time
-  tf2::StampedTransform stamped_transform1H(transform1, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1H == stamped_transform_reference); // Different transform
-
-}
-
-TEST(tf2_stamped, OperatorEqual)
-{
-  btTransform pose0, pose1, pose0a;
-  pose0.setIdentity();
-  pose1.setIdentity();
-  pose1.setOrigin(btVector3(1, 0, 0));
-  tf2::Stamped<btTransform> stamped_pose0(pose0, builtin_interfaces::msg::Time(), "frame_id");
-  tf2::Stamped<btTransform> stamped_pose1(pose1, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal");
-  EXPECT_FALSE(stamped_pose1 == stamped_pose0);
-  stamped_pose1 = stamped_pose0;
-  EXPECT_TRUE(stamped_pose1 == stamped_pose0);
-
-}
-  */
-int main(int argc, char **argv){
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/permuter.hpp b/test_tf2/test/permuter.hpp
deleted file mode 100644
index bd8d29d8..00000000
--- a/test_tf2/test/permuter.hpp
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (c) 2009, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/** \author Tully Foote */
-
-#ifndef ROSTEST_PERMUTER_HPP
-#define ROSTEST_PERMUTER_HPP
-
-#include <memory>
-#include <mutex>
-#include <vector>
-
-namespace rostest
-{
-/** \brief A base class for storing pointers to generic data types
- */
-class PermuteOptionBase
-{
-public:
-  virtual void reset() = 0;
-  virtual bool step() = 0;
-  virtual ~PermuteOptionBase() {};
-};
-
-
-/**\brief A class to hold a set of option values and currently used state
- *  This class holds
- */
-template<class T>
-class PermuteOption : public PermuteOptionBase
-{
-public:
-  PermuteOption(const std::vector<T>& options, T* output)
-  {
-    options_ = options;
-    output_ = output;
-    reset();
-  }
-
-  virtual ~PermuteOption(){};
-
-  void reset()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    current_element_ = options_.begin();
-    *output_ = *current_element_;
-  }
-
-  bool step()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    current_element_++;
-    if (current_element_ == options_.end())
-      return false;
-    *output_ = *current_element_;
-    return true;
-  }
-
-private:
-  /// Local storage of the possible values
-  std::vector<T> options_;
-  /// The output variable
-  T* output_;
-  typedef typename std::vector<T>::iterator V_T_iterator;
-  /// The last updated element
-  V_T_iterator current_element_;
-
-  std::mutex access_mutex_;
-
-};
-
-/** \brief A class to provide easy permutation of options
- * This class provides a way to collapse independent
- * permutations of options into a single loop.
- */
-class Permuter
-{
-public:
-  /** \brief Destructor to clean up allocated data */
-  virtual ~Permuter(){ clearAll();};
-
-
-  /** \brief Add a set of values and an output to the iteration
-   * @param values The set of possible values for this output
-   * @param output The value to set at each iteration
-   */
-  template<class T>
-  void addOptionSet(const std::vector<T>& values, T* output)
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    options_.emplace_back(std::make_unique<PermuteOption<T>>(values, output));
-    reset();
-  }
-
-
-  /** \brief Reset the internal counters */
-  void reset()
-  {
-    for (unsigned int level= 0; level < options_.size(); level++)
-    {
-      options_[level]->reset();
-    }
-  }
-
-  /** \brief Iterate to the next value in the iteration
-   * Returns true unless done iterating.
-   */
-  bool step()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    // base case just iterating
-    for (size_t level = 0; level < options_.size(); level++)
-    {
-      if(options_[level]->step())
-      {
-        //printf("stepping level %d returning true \n", level);
-        return true;
-      }
-      else
-      {
-        //printf("reseting level %d\n", level);
-        options_[level]->reset();
-      }
-    }
-    return false;
-  }
-
-  /** \brief Clear all stored data */
-  void clearAll()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    options_.clear();
-  }
-
-private:
-  std::vector<std::unique_ptr<PermuteOptionBase>> options_; ///< Store all the option objects
-  std::mutex access_mutex_;
-};
-
-
-}
-
-#endif //ROSTEST_PERMUTER_HPP
diff --git a/test_tf2/test/static_publisher.launch.py b/test_tf2/test/static_publisher.launch.py
deleted file mode 100644
index a995fa0c..00000000
--- a/test_tf2/test/static_publisher.launch.py
+++ /dev/null
@@ -1,54 +0,0 @@
-# generated from buildfarm_perf_tests/test/test_performance.py.in
-# generated code does not contain a copyright notice
-
-import unittest
-
-from launch import LaunchDescription
-import launch
-from launch_ros.actions import Node
-from launch.substitutions import LaunchConfiguration
-import launch_testing
-import launch_testing.actions
-
-def generate_test_description():
-    node_under_test = Node(
-        package='test_tf2',
-        executable='test_static_publisher',
-        output='screen',
-        arguments=[],
-    )
-    node_static_transform_publisher_1 = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "1", "--y", "0", "--z", "0", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "a", "--child-frame-id", "b"]
-    )
-    node_static_transform_publisher_2 = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "0", "--y", "1", "--z", "0", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "b", "--child-frame-id", "c"]
-    )
-
-    return LaunchDescription([
-        node_static_transform_publisher_1,
-        node_static_transform_publisher_2,
-        node_under_test,
-        launch_testing.util.KeepAliveProc(),
-        launch_testing.actions.ReadyToTest(),
-        ]), locals()
-
-
-class TestBufferClient(unittest.TestCase):
-
-    def test_termination(self, node_under_test, proc_info):
-        proc_info.assertWaitForShutdown(process=node_under_test, timeout=(60))
-
-
-@launch_testing.post_shutdown_test()
-class BufferClientTestAfterShutdown(unittest.TestCase):
-
-    def test_exit_code(self, proc_info):
-        # Check that all processes in the launch (in this case, there's just one) exit
-        # with code 0
-        launch_testing.asserts.assertExitCodes(proc_info)
diff --git a/test_tf2/test/test_buffer_client.cpp b/test_tf2/test/test_buffer_client.cpp
deleted file mode 100644
index 8b06a7d3..00000000
--- a/test_tf2/test/test_buffer_client.cpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/*********************************************************************
-*
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of Willow Garage, Inc. nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-* Author: Eitan Marder-Eppstein
-*********************************************************************/
-#include <gtest/gtest.h>
-
-#include <rclcpp/rclcpp.hpp>
-#include <tf2_bullet/tf2_bullet.hpp>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-#include <tf2_kdl/tf2_kdl.hpp>
-#include <tf2_ros/buffer_client.h>
-
-#include <chrono>
-#include <functional>
-#include <memory>
-#include <thread>
-
-static const double EPS = 1e-3;
-
-TEST(tf2_ros, buffer_client)
-{
-  rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>("tf_action_node");
-  std::unique_ptr<tf2_ros::BufferClient> client = std::make_unique<tf2_ros::BufferClient>(node, "tf_action");
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-
-  executor.add_node(node);
-
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  //make sure that things are set up
-  ASSERT_TRUE(client->waitForServer(std::chrono::seconds(4)));
-
-  geometry_msgs::msg::PointStamped p1;
-  p1.header.frame_id = "a";
-  p1.header.stamp = builtin_interfaces::msg::Time();
-  p1.point.x = 0.0;
-  p1.point.y = 0.0;
-  p1.point.z = 0.0;
-
-  try
-  {
-    geometry_msgs::msg::PointStamped p2 = client->transform(p1, "b");
-    RCLCPP_INFO(node->get_logger(),
-                "p1: (%.2f, %.2f, %.2f), p2: (%.2f, %.2f, %.2f)", p1.point.x,
-                p1.point.y, p1.point.z, p2.point.x, p2.point.y, p2.point.z);
-
-    EXPECT_NEAR(p2.point.x, -5.0, EPS);
-    EXPECT_NEAR(p2.point.y, -6.0, EPS);
-    EXPECT_NEAR(p2.point.z, -7.0, EPS);
-  }
-  catch(tf2::TransformException& ex)
-  {
-    RCLCPP_ERROR(node->get_logger(), "Failed to transform: %s", ex.what());
-    ASSERT_FALSE("Should not get here");
-  }
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(tf2_ros, buffer_client_different_types)
-{
-  rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>("tf_action_node");
-  std::unique_ptr<tf2_ros::BufferClient> client = std::make_unique<tf2_ros::BufferClient>(node, "tf_action");
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-
-  executor.add_node(node);
-
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  //make sure that things are set up
-  ASSERT_TRUE(client->waitForServer(std::chrono::seconds(4)));
-
-  tf2::Stamped<KDL::Vector> k1(KDL::Vector(0, 0, 0), tf2::TimePoint(), "a");
-
-  try
-  {
-    tf2::Stamped<btVector3> b1;
-    client->transform(k1, b1, "b");
-    RCLCPP_ERROR(node->get_logger(), "Bullet: (%.4f, %.4f, %.4f)", b1[0], b1[1], b1[2]);
-    RCLCPP_ERROR(node->get_logger(), "KDL: (%.4f, %.4f, %.4f)", k1[0], k1[1], k1[2]);
-    EXPECT_NEAR(b1[0], -5.0, EPS);
-    EXPECT_NEAR(b1[1], -6.0, EPS);
-    EXPECT_NEAR(b1[2], -7.0, EPS);
-    EXPECT_EQ(b1.frame_id_, "b");
-    EXPECT_EQ(k1.frame_id_, "a");
-  }
-  catch(tf2::TransformException& ex)
-  {
-    RCLCPP_ERROR(node->get_logger(), "Failed to transform: %s", ex.what());
-    ASSERT_FALSE("Should not get here");
-  }
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-
-}
-
-int main(int argc, char** argv)
-{
-  // This is needed because we need to wait a little bit for the other nodes
-  std::this_thread::sleep_for(std::chrono::milliseconds(1000));
-
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/test_buffer_client.launch.py b/test_tf2/test/test_buffer_client.launch.py
deleted file mode 100644
index edfa968a..00000000
--- a/test_tf2/test/test_buffer_client.launch.py
+++ /dev/null
@@ -1,55 +0,0 @@
-# generated from buildfarm_perf_tests/test/test_performance.py.in
-# generated code does not contain a copyright notice
-
-import unittest
-
-from launch import LaunchDescription
-import launch
-from launch_ros.actions import Node
-from launch.substitutions import LaunchConfiguration
-import launch_testing
-import launch_testing.actions
-
-
-def generate_test_description():
-    node_under_test = Node(
-        package='test_tf2',
-        executable='test_buffer_client.py',
-        output='screen',
-    )
-    node_static_transform_publisher = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "5", "--y", "6", "--z", "7", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "a", "--child-frame-id", "b"]
-    )
-
-    node_buffer_server = Node(
-        package='test_tf2',
-        executable='test_buffer_server',
-        output='screen',
-        arguments=[],
-        sigterm_timeout=LaunchConfiguration('sigterm_timeout', default=2)
-    )
-    return LaunchDescription([
-        node_static_transform_publisher,
-        node_buffer_server,
-        node_under_test,
-        launch_testing.util.KeepAliveProc(),
-        launch_testing.actions.ReadyToTest(),
-        ]), locals()
-
-
-class TestBufferClient(unittest.TestCase):
-
-    def test_termination(self, node_under_test, proc_info):
-        proc_info.assertWaitForShutdown(process=node_under_test, timeout=(10))
-
-
-@launch_testing.post_shutdown_test()
-class BufferClientTestAfterShutdown(unittest.TestCase):
-
-    def test_exit_code(self, proc_info):
-        # Check that all processes in the launch (in this case, there's just one) exit
-        # with code 0
-        launch_testing.asserts.assertExitCodes(proc_info)
diff --git a/test_tf2/test/test_buffer_client.py b/test_tf2/test/test_buffer_client.py
deleted file mode 100755
index 97570c01..00000000
--- a/test_tf2/test/test_buffer_client.py
+++ /dev/null
@@ -1,127 +0,0 @@
-#!/usr/bin/python3
-#***********************************************************
-#* Software License Agreement (BSD License)
-#*
-#*  Copyright (c) 2009, Willow Garage, Inc.
-#*  All rights reserved.
-#*
-#*  Redistribution and use in source and binary forms, with or without
-#*  modification, are permitted provided that the following conditions
-#*  are met:
-#*
-#*   * Redistributions of source code must retain the above copyright
-#*     notice, this list of conditions and the following disclaimer.
-#*   * Redistributions in binary form must reproduce the above
-#*     copyright notice, this list of conditions and the following
-#*     disclaimer in the documentation and/or other materials provided
-#*     with the distribution.
-#*   * Neither the name of Willow Garage, Inc. nor the names of its
-#*     contributors may be used to endorse or promote products derived
-#*     from this software without specific prior written permission.
-#*
-#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-#*  POSSIBILITY OF SUCH DAMAGE.
-#*
-#* Author: Eitan Marder-Eppstein
-#***********************************************************
-import sys
-import unittest
-
-import tf2_py as tf2
-import tf2_ros
-from geometry_msgs.msg import PointStamped
-import rclpy
-import tf2_geometry_msgs
-# TODO (ahcorde): Enable once python_orocos_kdl is ported
-# import tf2_kdl
-# import PyKDL
-from rclpy.executors import SingleThreadedExecutor
-import threading
-
-class TestBufferClient(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls):
-        cls.context = rclpy.context.Context()
-        rclpy.init(context=cls.context)
-        cls.executor = SingleThreadedExecutor(context=cls.context)
-        cls.node = rclpy.create_node('TestBufferClient', context=cls.context)
-        cls.executor.add_node(cls.node)
-
-    @classmethod
-    def tearDownClass(cls):
-        rclpy.shutdown(context=cls.context)
-
-    def setUp(self):
-        self.spinning = threading.Event()
-        self.spin_thread = threading.Thread(target=self.spin)
-        self.spin_thread.start()
-        return
-
-    def tearDown(self):
-        self.spinning.set()
-        self.spin_thread.join()
-        return
-
-    def spin(self):
-        try:
-            while self.context.ok() and not self.spinning.is_set():
-                self.executor.spin_once(timeout_sec=0.05)
-        finally:
-            return
-
-    def test_buffer_client(self):
-        buffer_client = tf2_ros.BufferClient(
-            self.node, '/tf_action', check_frequency=10.0, timeout_padding=0.0)
-
-        p1 = PointStamped()
-        p1.header.frame_id = "a"
-        p1.header.stamp = rclpy.time.Time(seconds=1.0).to_msg()
-        p1.point.x = 0.0
-        p1.point.y = 0.0
-        p1.point.z = 0.0
-
-        buffer_client.action_client.wait_for_server()
-
-        try:
-            p2 = buffer_client.transform(p1, "b", timeout=rclpy.time.Duration(seconds=1))
-            self.node.get_logger().info("p1: %s, p2: %s" % (p1, p2))
-        except tf2.TransformException as e:
-            self.node.get_logger().error("%s" % e)
-            self.assertEqual(0, 4)
-
-    # TODO (ahcorde): Enable once python_orocos_kdl is ported
-    # def test_transform_type(self):
-    #     buffer_client = tf2_ros.BufferClient(
-    #         self.node, '/tf_action', check_frequency=10.0, timeout_padding=0.0)
-    #
-    #     p1 = PointStamped()
-    #     p1.header.frame_id = "a"
-    #     p1.header.stamp = rclpy.time.Time(seconds=1.0).to_msg()
-    #     p1.point.x = 0.0
-    #     p1.point.y = 0.0
-    #     p1.point.z = 0.0
-    #
-    #     buffer_client.action_client.wait_for_server()
-    #
-    #     try:
-    #         p2 = buffer_client.transform(p1, "b", timeout=rclpy.time.Duration(seconds=1),
-    #                                      new_type = PyKDL.Vector)
-    #         self.node.get_logger().info("p1: %s, p2: %s" % (str(p1), str(p2)))
-    #     except tf2.TransformException as e:
-    #         self.node.get_logger().error("%s" % e)
-
-
-if __name__ == '__main__':
-    rclpy.init(args=sys.argv)
-    sys.argv = [sys.argv[0]]
-    unittest.main()
diff --git a/test_tf2/test/test_buffer_server.cpp b/test_tf2/test/test_buffer_server.cpp
deleted file mode 100644
index c9361cf4..00000000
--- a/test_tf2/test/test_buffer_server.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/*********************************************************************
-*
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of Willow Garage, Inc. nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-* Author: Eitan Marder-Eppstein
-*********************************************************************/
-#include <tf2_ros/buffer.h>
-#include <tf2_ros/buffer_server.h>
-#include <tf2_ros/transform_listener.h>
-#include <rclcpp/rclcpp.hpp>
-#include <memory>
-
-int main(int argc, char** argv)
-{
-  rclcpp::init(argc, argv);
-
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  tf2_ros::TransformListener tfl(buffer, node, false);
-  std::unique_ptr<tf2_ros::BufferServer> server = std::make_unique<tf2_ros::BufferServer>(buffer, node, "tf_action");
-
-  rclcpp::spin(node);
-}
diff --git a/test_tf2/test/test_convert.cpp b/test_tf2/test/test_convert.cpp
deleted file mode 100644
index 432bbfe5..00000000
--- a/test_tf2/test/test_convert.cpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/*********************************************************************
-*
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of Willow Garage, Inc. nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-* Author: Eitan Marder-Eppstein
-*********************************************************************/
-#include <gtest/gtest.h>
-#include <geometry_msgs/msg/point_stamped.hpp>
-#include <geometry_msgs/msg/point.hpp>
-#include <geometry_msgs/msg/vector3.hpp>
-#include <tf2/convert.h>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2_kdl/tf2_kdl.hpp>
-#include <tf2_bullet/tf2_bullet.hpp>
-#include <tf2_eigen/tf2_eigen.hpp>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-
-#include <Eigen/Geometry>
-
-TEST(tf2Convert, kdlToBullet)
-{
-  double epsilon = 1e-9;
-
-  tf2::Stamped<btVector3> b(btVector3(1, 2, 3), tf2::timeFromSec(0), "my_frame");
-
-  tf2::Stamped<btVector3> b1 = b;
-  tf2::Stamped<KDL::Vector> k1;
-  tf2::convert(b1, k1);
-
-  tf2::Stamped<btVector3> b2;
-  tf2::convert(k1, b2);
-
-  EXPECT_EQ(b.frame_id_, b2.frame_id_);
-  EXPECT_NEAR(tf2::timeToSec(b.stamp_), tf2::timeToSec(b2.stamp_), epsilon);
-  EXPECT_NEAR(b.x(), b2.x(), epsilon);
-  EXPECT_NEAR(b.y(), b2.y(), epsilon);
-  EXPECT_NEAR(b.z(), b2.z(), epsilon);
-
-
-  EXPECT_EQ(b1.frame_id_, b2.frame_id_);
-  EXPECT_NEAR(tf2::timeToSec(b1.stamp_), tf2::timeToSec(b2.stamp_), epsilon);
-  EXPECT_NEAR(b1.x(), b2.x(), epsilon);
-  EXPECT_NEAR(b1.y(), b2.y(), epsilon);
-  EXPECT_NEAR(b1.z(), b2.z(), epsilon);
-}
-
-TEST(tf2Convert, kdlBulletROSConversions)
-{
-  double epsilon = 1e-9;
-
-  tf2::Stamped<btVector3> b1(btVector3(1, 2, 3), tf2::timeFromSec(0), "my_frame"), b2, b3, b4;
-  geometry_msgs::msg::PointStamped r1, r2, r3;
-  tf2::Stamped<KDL::Vector> k1, k2, k3;
-
-  // Do bullet -> self -> bullet -> KDL -> self -> KDL -> ROS -> self
-  //   -> ROS -> KDL -> bullet -> ROS -> bullet
-  tf2::convert(b1, b1);
-  tf2::convert(b1, b2);
-  tf2::convert(b2, k1);
-  tf2::convert(k1, k1);
-  tf2::convert(k1, k2);
-  tf2::convert(k2, r1);
-  tf2::convert(r1, r1);
-  tf2::convert(r1, r2);
-  tf2::convert(r2, k3);
-  tf2::convert(k3, b3);
-  tf2::convert(b3, r3);
-  tf2::convert(r3, b4);
-
-  EXPECT_EQ(b1.frame_id_, b4.frame_id_);
-  EXPECT_NEAR(tf2::timeToSec(b1.stamp_), tf2::timeToSec(b4.stamp_), epsilon);
-  EXPECT_NEAR(b1.x(), b4.x(), epsilon);
-  EXPECT_NEAR(b1.y(), b4.y(), epsilon);
-  EXPECT_NEAR(b1.z(), b4.z(), epsilon);
-}
-
-TEST(tf2Convert, ConvertTf2Quaternion)
-{
-  const tf2::Quaternion tq(1, 2, 3, 4);
-  Eigen::Quaterniond eq;
-  // TODO(gleichdick): switch to tf2::convert() when it's working
-  tf2::fromMsg(tf2::toMsg(tq), eq);
-
-  EXPECT_EQ(tq.w(), eq.w());
-  EXPECT_EQ(tq.x(), eq.x());
-  EXPECT_EQ(tq.y(), eq.y());
-  EXPECT_EQ(tq.z(), eq.z());
-}
-
-TEST(tf2Convert, PointVectorDefaultMessagetype)
-{
-  // Verify the return type of `toMsg()`
-  // as it can return a Vector3 or a Point for certain datatypes
-  {
-    // Bullet
-    const tf2::Stamped<btVector3> b1{btVector3{1.0, 3.0, 4.0}, tf2::TimePoint(), "my_frame"};
-    const geometry_msgs::msg::PointStamped msg = tf2::toMsg(b1);
-
-    EXPECT_EQ(msg.point.x, 1.0);
-    EXPECT_EQ(msg.point.y, 3.0);
-    EXPECT_EQ(msg.point.z, 4.0);
-    EXPECT_EQ(msg.header.frame_id, b1.frame_id_);
-  }
-  {
-    // Eigen
-    const Eigen::Vector3d e1{2.0, 4.0, 5.0};
-    const geometry_msgs::msg::Point msg = tf2::toMsg(e1);
-
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-  {
-    // tf2
-    const tf2::Vector3 t1{2.0, 4.0, 5.0};
-    const geometry_msgs::msg::Vector3 msg = tf2::toMsg(t1);
-
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-  {
-    // KDL
-    const tf2::Stamped<KDL::Vector> k1{KDL::Vector{1.0, 3.0, 4.0}, tf2::TimePoint(), "my_frame"};
-    const geometry_msgs::msg::PointStamped msg = tf2::toMsg(k1);
-
-    EXPECT_EQ(msg.point.x, 1.0);
-    EXPECT_EQ(msg.point.y, 3.0);
-    EXPECT_EQ(msg.point.z, 4.0);
-    EXPECT_EQ(msg.header.frame_id, k1.frame_id_);
-  }
-}
-
-TEST(tf2Convert, PointVectorOtherMessagetype)
-{
-  {
-    const tf2::Vector3 t1{2.0, 4.0, 5.0};
-    geometry_msgs::msg::Point msg;
-    const geometry_msgs::msg::Point & msg2 = tf2::toMsg(t1, msg);
-
-    // returned reference is second argument
-    EXPECT_EQ(&msg2, &msg);
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-  {
-    // Eigen
-    const Eigen::Vector3d e1{2.0, 4.0, 5.0};
-    geometry_msgs::msg::Vector3 msg;
-    const geometry_msgs::msg::Vector3 & msg2 = tf2::toMsg(e1, msg);
-
-    // returned reference is second argument
-    EXPECT_EQ(&msg2, &msg);
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-}
-
-int main(int argc, char ** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/test_convert.py b/test_tf2/test/test_convert.py
deleted file mode 100755
index 988c9baa..00000000
--- a/test_tf2/test/test_convert.py
+++ /dev/null
@@ -1,63 +0,0 @@
-#! /usr/bin/python
-#***********************************************************
-#* Software License Agreement (BSD License)
-#*
-#*  Copyright (c) 2009, Willow Garage, Inc.
-#*  All rights reserved.
-#*
-#*  Redistribution and use in source and binary forms, with or without
-#*  modification, are permitted provided that the following conditions
-#*  are met:
-#*
-#*   * Redistributions of source code must retain the above copyright
-#*     notice, this list of conditions and the following disclaimer.
-#*   * Redistributions in binary form must reproduce the above
-#*     copyright notice, this list of conditions and the following
-#*     disclaimer in the documentation and/or other materials provided
-#*     with the distribution.
-#*   * Neither the name of Willow Garage, Inc. nor the names of its
-#*     contributors may be used to endorse or promote products derived
-#*     from this software without specific prior written permission.
-#*
-#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-#*  POSSIBILITY OF SUCH DAMAGE.
-#*
-#* Author: Eitan Marder-Eppstein
-#***********************************************************
-import sys
-import unittest
-
-import tf2_py as tf2
-import tf2_ros
-import tf2_geometry_msgs
-from geometry_msgs.msg import PointStamped
-import builtin_interfaces
-import rclpy
-import tf2_kdl
-import PyKDL
-
-
-class TestConvert(unittest.TestCase):
-    def test_convert(self):
-        p = tf2_ros.Stamped(PyKDL.Vector(1, 2, 3), builtin_interfaces.msg.Time(sec=0), 'my_frame')
-        msg = tf2_ros.convert(p, PointStamped)
-        p2 = tf2_ros.convert(msg, PyKDL.Vector)
-
-        self.assertEqual(p2[0], p[0])
-        self.assertEqual(p2[1], p[1])
-        self.assertEqual(p2[2], p[2])
-        self.assertEqual(p2.header, p.header)
-
-
-if __name__ == '__main__':
-    unittest.main()
diff --git a/test_tf2/test/test_message_filter.cpp b/test_tf2/test/test_message_filter.cpp
deleted file mode 100644
index fddca0ba..00000000
--- a/test_tf2/test/test_message_filter.cpp
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** \author Josh Faust */
-
-#include <functional>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include <gtest/gtest.h>
-
-#include <builtin_interfaces/msg/time.hpp>
-#include <geometry_msgs/msg/point_stamped.hpp>
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rclcpp/rclcpp.hpp>
-#include <tf2/buffer_core.h>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2/LinearMath/Vector3.h>
-#include <tf2/time.h>
-#include <tf2_ros/buffer_interface.h>
-#include <tf2_ros/create_timer_ros.h>
-#include <tf2_ros/message_filter.h>
-
-class Notification
-{
-public:
-  Notification(int expected_count) :
-    count_(0), expected_count_(expected_count), failure_count_(0)
-  {
-  }
-
-  void notify(const geometry_msgs::msg::PointStamped::ConstSharedPtr& message)
-  {
-    (void)message;
-    ++count_;
-  }
-
-  void failure(const geometry_msgs::msg::PointStamped::ConstSharedPtr& message, tf2_ros::filter_failure_reasons::FilterFailureReason reason)
-  {
-    (void)message;
-    (void)reason;
-    ++failure_count_;
-  }
-
-  int count_;
-  int expected_count_;
-  int failure_count_;
-};
-
-TEST(MessageFilter, noTransforms)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  msg->header.frame_id = "frame2";
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_);
-}
-
-TEST(MessageFilter, noTransformsSameFrame)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  msg->header.frame_id = "frame1";
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-geometry_msgs::msg::TransformStamped createTransform(tf2::Quaternion q, tf2::Vector3 v, builtin_interfaces::msg::Time stamp, const std::string& frame1, const std::string& frame2)
-{
-  geometry_msgs::msg::TransformStamped t;
-  t.header.frame_id = frame1;
-  t.child_frame_id = frame2;
-  t.header.stamp = stamp;
-  t.transform.translation.x = v.x();
-  t.transform.translation.y = v.y();
-  t.transform.translation.z = v.z();
-  t.transform.rotation.x = q.x();
-  t.transform.rotation.y = q.y();
-  t.transform.rotation.z = q.z();
-  t.transform.rotation.w = q.w();
-  return t;
-}
-
-TEST(MessageFilter, preexistingTransforms)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-TEST(MessageFilter, postTransforms)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_);
-
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  EXPECT_EQ(1, n.count_);
-}
-
-TEST(MessageFilter, concurrentTransforms)
-{
-  const int messages = 30;
-  const int buffer_size = messages;
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  tf2_ros::Buffer buffer(clock);
-  for (int i = 0; i < 50; i++) {
-    buffer.setCreateTimerInterface(create_timer_interface);
-    tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", buffer_size, node);
-    Notification n(1);
-    filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-    std::thread t([&](){
-      std::this_thread::sleep_for(std::chrono::milliseconds(1));
-      buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-    });
-    for (int j = 0; j < messages; j++) {
-      filter.add(msg);
-    }
-    t.join();
-
-    EXPECT_EQ(messages, n.count_);
-
-    buffer.clear();
-  }
-}
-
-// TODO (ahcorde): For some unknown reason message_filters::Connection registerFailureCallback is disable
-// with #if 0 https://github.com/ros2/geometry2/blob/ros2/tf2_ros/include/tf2_ros/message_filter.h#L463
-// rework this part when this is available
-// TEST(MessageFilter, queueSize)
-// {
-//   auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-//   auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-//     node->get_node_base_interface(),
-//     node->get_node_timers_interface());
-//
-//   rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-//   tf2_ros::Buffer buffer(clock);
-//   buffer.setCreateTimerInterface(create_timer_interface);
-//   tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-//   Notification n(10);
-//
-//   filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-//   // filter.registerFailureCallback(std::bind(&Notification::failure, &n,  std::placeholders::_1,  std::placeholders::_2));
-//
-//   builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-//
-//   for (int i = 0; i < 20; ++i)
-//   {
-//     std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-//     msg->header.stamp = stamp;
-//     msg->header.frame_id = "frame2";
-//
-//     filter.add(msg);
-//   }
-//
-//   EXPECT_EQ(0, n.count_);
-//   EXPECT_EQ(10, n.failure_count_);
-//
-//   buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-//
-//   EXPECT_EQ(10, n.count_);
-//
-//
-// }
-
-TEST(MessageFilter, setTargetFrame)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-  filter.setTargetFrame("frame1000");
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1000", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-TEST(MessageFilter, multipleTargetFrames)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  std::vector<std::string> target_frames;
-  target_frames.push_back("frame1");
-  target_frames.push_back("frame2");
-  filter.setTargetFrames(target_frames);
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame3"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame3";
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_); // frame1->frame3 exists, frame2->frame3 does not (yet)
-
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  EXPECT_EQ(1, n.count_); // frame2->frame3 now exists
-}
-
-TEST(MessageFilter, tolerance)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  tf2::Duration offset = tf2::durationFromSec(0.2);
-  filter.setTolerance(offset);
-
-  builtin_interfaces::msg::Time stamp = rclcpp::Time(1, 0);
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_); //No return due to lack of space for offset
-
-  double time_stamp = (stamp.sec + stamp.nanosec/1e9) + tf2::durationToSec(offset)*1.1;
-  builtin_interfaces::msg::Time stamp_transform = rclcpp::Time(static_cast<int32_t>((int)time_stamp), static_cast<uint32_t>((time_stamp - (int)time_stamp)*1e9));
-
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp_transform, "frame1", "frame2"), "me");
-
-  EXPECT_EQ(1, n.count_); // Now have data for the message published earlier
-
-  time_stamp = (stamp.sec + stamp.nanosec/1e9) + tf2::durationToSec(offset);
-
-  msg->header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp));
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_); // Latest message is off the end of the offset
-}
-
-// TODO(ahcorde): For some unknown reason message_filters::Connection registerFailureCallback is disable
-// with #if 0 https://github.com/ros2/geometry2/blob/ros2/tf2_ros/include/tf2_ros/message_filter.h#L463
-// rework this part when this is available
-
-// TEST(MessageFilter, outTheBackFailure)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, 0);
-//   filter.registerFailureCallback(boost::bind(&Notification::failure, &n, _1, _2));
-//
-//   builtin_interfaces::msg::Time stamp(1);
-//   bc.setTransform(createTransform(Quaternion(0,0,0,1), Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-//   bc.setTransform(createTransform(Quaternion(0,0,0,1), Vector3(1,2,3), stamp + tf2::durationFromSec(10000), "frame1", "frame2"), "me");
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.stamp = stamp;
-//   msg->header.frame_id = "frame2";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(1, n.failure_count_);
-// }
-//
-// TEST(MessageFilter, outTheBackFailure2)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, 0);
-//   filter.registerFailureCallback(boost::bind(&Notification::failure, &n, _1, _2));
-//
-//   builtin_interfaces::msg::Time stamp(1);
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.stamp = stamp;
-//   msg->header.frame_id = "frame2";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(0, n.count_);
-//   EXPECT_EQ(0, n.failure_count_);
-//
-//   bc.setTransform(createTransform(Quaternion(0,0,0,1), Vector3(1,2,3), stamp + tf2::durationFromSec(10000), "frame1", "frame2"), "me");
-//
-//   EXPECT_EQ(1, n.failure_count_);
-// }
-//
-// TEST(MessageFilter, emptyFrameIDFailure)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, 0);
-//   filter.registerFailureCallback(boost::bind(&Notification::failure, &n, _1, _2));
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.frame_id = "";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(1, n.failure_count_);
-// }
-//
-// TEST(MessageFilter, callbackQueue)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   ros::CallbackQueue queue;
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, &queue);
-//   filter.registerCallback(boost::bind(&Notification::notify, &n, _1));
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.stamp = builtin_interfaces::msg::Time(1);
-//   msg->header.frame_id = "frame1";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(0, n.count_);
-//
-//   queue.callAvailable();
-//
-//   EXPECT_EQ(1, n.count_);
-// }
-
-// See: https://github.com/ros2/geometry2/pull/511
-TEST(MessageFilter, checkStampPrecisionLoss)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-  filter.setTargetFrame("frame1");
-
-  // Use a large timestamp to trigger potential precision loss if converted to a double somewhere
-  builtin_interfaces::msg::Time stamp(rclcpp::Time(1000000000, 000000001));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-int main(int argc, char** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  int ret = RUN_ALL_TESTS();
-  return ret;
-}
diff --git a/test_tf2/test/test_static_publisher.cpp b/test_tf2/test/test_static_publisher.cpp
deleted file mode 100644
index 731a9e04..00000000
--- a/test_tf2/test/test_static_publisher.cpp
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <chrono>
-#include <functional>
-#include <memory>
-#include <thread>
-
-#include <gtest/gtest.h>
-
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rclcpp/rclcpp.hpp>
-#include <tf2/buffer_core.h>
-#include <tf2/exceptions.h>
-#include <tf2/time.h>
-#include <tf2_ros/buffer.h>
-#include <tf2_ros/buffer_interface.h>
-#include <tf2_ros/static_transform_broadcaster.h>
-#include <tf2_ros/transform_listener.h>
-
-#include "permuter.hpp"
-
-const int MAX_ATTEMPTS = 400;
-
-TEST(StaticTransformPublisher, a_b_different_times)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_b_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-
-  while (!mB.canTransform("a", "b", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  EXPECT_TRUE(mB.canTransform("a", "b", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "b", tf2::timeFromSec(100)));
-  EXPECT_TRUE(mB.canTransform("a", "b", tf2::timeFromSec(1000)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(StaticTransformPublisher, a_c_different_times)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_c_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-  while (!mB.canTransform("a", "c", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(10)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(1000)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(StaticTransformPublisher, a_d_different_times)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_d_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-
-  while (!mB.canTransform("a", "c", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  geometry_msgs::msg::TransformStamped ts;
-  ts.transform.rotation.w = 1;
-  ts.header.frame_id = "c";
-  ts.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10));
-  ts.child_frame_id = "d";
-
-  // make sure listener has populated
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(100)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(1000)));
-
-  mB.setTransform(ts, "authority");
-  //printf("%s\n", mB.allFramesAsString().c_str());
-  EXPECT_TRUE(mB.canTransform("c", "d", tf2::timeFromSec(10)));
-
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(0)));
-  EXPECT_FALSE(mB.canTransform("a", "d", tf2::timeFromSec(1)));
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(10)));
-  EXPECT_FALSE(mB.canTransform("a", "d", tf2::timeFromSec(1000)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(StaticTransformPublisher, multiple_parent_test)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_d_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-
-  while (!mB.canTransform("a", "b", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  tf2_ros::StaticTransformBroadcaster stb(node);
-  geometry_msgs::msg::TransformStamped ts;
-  ts.transform.rotation.w = 1;
-  ts.header.frame_id = "c";
-  ts.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10));
-  ts.child_frame_id = "d";
-
-  stb.sendTransform(ts);
-
-  std::this_thread::sleep_for(std::chrono::milliseconds(200));
-
-  // make sure listener has populated
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(100)));
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(1000)));
-
-  // Publish new transform with child 'd', should replace old one in static tf
-  ts.header.frame_id = "new_parent";
-  stb.sendTransform(ts);
-  ts.child_frame_id = "other_child";
-  stb.sendTransform(ts);
-  ts.child_frame_id = "other_child2";
-  stb.sendTransform(ts);
-
-  std::this_thread::sleep_for(std::chrono::milliseconds(200));
-
-  EXPECT_TRUE(mB.canTransform("new_parent", "d", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("new_parent", "other_child", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("new_parent", "other_child2", tf2::timeFromSec(0)));
-  EXPECT_FALSE(mB.canTransform("a", "d", tf2::timeFromSec(0)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-// TODO (ahcorde) static_transform_publisher allows to load transforma from yaml files
-// Revisit this test when "Load transform from yaml" is available
-// TEST(StaticTransformPublisher, tf_from_param_server_valid)
-// {
-//   // This TF is loaded from the parameter server; ensure it is valid.
-//   auto node = rclcpp::Node::make_shared("StaticTransformPublisher_tf_from_param_server_valid_test");
-//
-//   rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-//   tf2_ros::Buffer mB(clock);
-//   tf2_ros::TransformListener tfl(mB, node, false);
-//
-//   rclcpp::executors::SingleThreadedExecutor executor;
-//   executor.add_node(node);
-//   // Start spinning in a thread
-//   std::thread spin_thread = std::thread(
-//     std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-//
-//   std::this_thread::sleep_for(std::chrono::milliseconds(200));
-//
-//   EXPECT_TRUE(mB.canTransform("robot_calibration", "world", tf2::timeFromSec(0)));
-//   EXPECT_TRUE(mB.canTransform("robot_calibration", "world", tf2::timeFromSec(100)));
-//   EXPECT_TRUE(mB.canTransform("robot_calibration", "world", tf2::timeFromSec(1000)));
-//
-//   executor.cancel();
-//   spin_thread.join();
-//   node.reset();
-// }
-
-int main(int argc, char **argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/test_static_publisher.py b/test_tf2/test/test_static_publisher.py
deleted file mode 100755
index 0869ee06..00000000
--- a/test_tf2/test/test_static_publisher.py
+++ /dev/null
@@ -1,93 +0,0 @@
-#! /usr/bin/python
-#***********************************************************
-#* Software License Agreement (BSD License)
-#*
-#*  Copyright (c) 2016, Felix Duvallet
-#*  All rights reserved.
-#*
-#*  Redistribution and use in source and binary forms, with or without
-#*  modification, are permitted provided that the following conditions
-#*  are met:
-#*
-#*   * Redistributions of source code must retain the above copyright
-#*     notice, this list of conditions and the following disclaimer.
-#*   * Redistributions in binary form must reproduce the above
-#*     copyright notice, this list of conditions and the following
-#*     disclaimer in the documentation and/or other materials provided
-#*     with the distribution.
-#*   * Neither the name of Willow Garage, Inc. nor the names of its
-#*     contributors may be used to endorse or promote products derived
-#*     from this software without specific prior written permission.
-#*
-#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-#*  POSSIBILITY OF SUCH DAMAGE.
-#*
-#* Author: Felix Duvallet
-#***********************************************************
-
-import subprocess
-import unittest
-
-import rclpy
-
-class TestStaticPublisher(unittest.TestCase):
-    """
-    These tests ensure the static transform publisher dies gracefully when
-    provided with an invalid (or non-existent) transform parameter.
-
-    These tests are started by the static_publisher.launch, which loads
-    parameters into the param server.
-
-    We check the output to make sure the correct error is occurring, since the
-    return code is always -1 (255).
-
-    Note that this *could* cause a problem if a valid TF is stored in the param
-    server for one of the names; in this case the subprocess would never return
-    and the test would run forever.
-    """
-
-    def test_publisher_no_args(self):
-        # Start the publisher with no argument.
-        cmd = 'ros2 run tf2_ros static_transform_publisher'
-        with self.assertRaises(subprocess.CalledProcessError) as cm:
-            ret = subprocess.check_output(
-                cmd.split(' '), stderr=subprocess.STDOUT)
-        self.assertEqual(255, cm.exception.returncode)
-        self.assertIn('not having the right number of arguments',
-                      str(cm.exception.output))
-
-    def test_publisher_nonexistent_param(self):
-        # Here there is no paramater by that name.
-        cmd = 'ros2 run tf2_ros static_transform_publisher /test_tf2/tf_null'
-        with self.assertRaises(subprocess.CalledProcessError) as cm:
-            ret = subprocess.check_output(
-                cmd.split(' '), stderr=subprocess.STDOUT)
-
-        self.assertEqual(255, cm.exception.returncode)
-        self.assertIn('not having the right number of arguments',
-                      str(cm.exception.output))
-
-    def test_publisher_invalid_param(self):
-        # Here there is an invalid parameter stored in the parameter server.
-        cmd = 'ros2 run tf2_ros static_transform_publisher /test_tf2/tf_invalid'
-        with self.assertRaises(subprocess.CalledProcessError) as cm:
-            ret = subprocess.check_output(
-                cmd.split(' '), stderr=subprocess.STDOUT)
-
-        self.assertEqual(255, cm.exception.returncode)
-        self.assertIn('exited due to not having the right number', str(cm.exception.output))
-
-
-if __name__ == '__main__':
-    rclpy.init(args=None)
-    unittest.main()
diff --git a/test_tf2/test/test_tf2_bullet.cpp b/test_tf2/test/test_tf2_bullet.cpp
deleted file mode 100644
index 1b71d13b..00000000
--- a/test_tf2/test/test_tf2_bullet.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** \author Wim Meeussen */
-
-#include <tf2_bullet/tf2_bullet.hpp>
-#include <tf2_ros/buffer.h>
-#include <rclcpp/rclcpp.hpp>
-#include <gtest/gtest.h>
-#include <tf2/convert.h>
-
-std::unique_ptr<tf2_ros::Buffer> tf_buffer = nullptr;
-static const double EPS = 1e-3;
-
-TEST(TfBullet, Transform)
-{
-  tf2::Stamped<btTransform> v1(btTransform(btQuaternion(1,0,0,0), btVector3(1,2,3)), tf2::timeFromSec(2.0), "A");
-
-  // simple api
-  btTransform v_simple = tf_buffer->transform(v1, "B", tf2::durationFromSec(2.0));
-  EXPECT_NEAR(v_simple.getOrigin().getX(), -9, EPS);
-  EXPECT_NEAR(v_simple.getOrigin().getY(), 18, EPS);
-  EXPECT_NEAR(v_simple.getOrigin().getZ(), 27, EPS);
-
-  // advanced api
-  btTransform v_advanced = tf_buffer->transform(v1, "B", tf2::timeFromSec(2.0),
-					       "B", tf2::durationFromSec(3.0));
-  EXPECT_NEAR(v_advanced.getOrigin().getX(), -9, EPS);
-  EXPECT_NEAR(v_advanced.getOrigin().getY(), 18, EPS);
-  EXPECT_NEAR(v_advanced.getOrigin().getZ(), 27, EPS);
-}
-
-TEST(TfBullet, Vector)
-{
-  tf2::Stamped<btVector3>  v1(btVector3(1,2,3), tf2::timeFromSec(2.0), "A");
-
-  // simple api
-  btVector3 v_simple = tf_buffer->transform(v1, "B", tf2::durationFromSec(2.0));
-  EXPECT_NEAR(v_simple.getX(), -9, EPS);
-  EXPECT_NEAR(v_simple.getY(), 18, EPS);
-  EXPECT_NEAR(v_simple.getZ(), 27, EPS);
-
-  // advanced api
-  btVector3 v_advanced = tf_buffer->transform(v1, "B", tf2::timeFromSec(2.0),
-  					     "B", tf2::durationFromSec(3.0));
-  EXPECT_NEAR(v_advanced.getX(), -9, EPS);
-  EXPECT_NEAR(v_advanced.getY(), 18, EPS);
-  EXPECT_NEAR(v_advanced.getZ(), 27, EPS);
-}
-
-int main(int argc, char **argv){
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-
-  auto node = rclcpp::Node::make_shared("test_tf2_bullet");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf_buffer = std::make_unique<tf2_ros::Buffer>(clock);
-
-  // populate buffer
-  geometry_msgs::msg::TransformStamped t;
-  t.transform.translation.x = 10;
-  t.transform.translation.y = 20;
-  t.transform.translation.z = 30;
-  t.transform.rotation.w = 0;
-  t.transform.rotation.x = 1;
-  t.transform.rotation.y = 0;
-  t.transform.rotation.z = 0;
-  t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(2));
-  t.header.frame_id = "A";
-  t.child_frame_id = "B";
-  tf_buffer->setTransform(t, "test");
-
-  int ret = RUN_ALL_TESTS();
-  rclcpp::shutdown();
-  return ret;
-}
diff --git a/test_tf2/test/test_tf2_bullet.launch b/test_tf2/test/test_tf2_bullet.launch
deleted file mode 100644
index 3ab2701c..00000000
--- a/test_tf2/test/test_tf2_bullet.launch
+++ /dev/null
@@ -1,3 +0,0 @@
-<launch>
-  <test test-name="test_tf_bullet" pkg="tf2_bullet" type="test_bullet" time-limit="120" />
-</launch>
\ No newline at end of file
diff --git a/test_tf2/test/test_tf_invalid.yaml b/test_tf2/test/test_tf_invalid.yaml
deleted file mode 100644
index 0cb8bb6d..00000000
--- a/test_tf2/test/test_tf_invalid.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
-# This is not a valid TF.
-
-child_frame_id: calibration
-some_data:
-    - 1
-    - 2
-    - 3
diff --git a/test_tf2/test/test_tf_valid.yaml b/test_tf2/test/test_tf_valid.yaml
deleted file mode 100644
index 33a8b2d0..00000000
--- a/test_tf2/test/test_tf_valid.yaml
+++ /dev/null
@@ -1,17 +0,0 @@
-header:
-  seq: 0
-  stamp:
-    secs: 1619
-    nsecs: 601000000
-  frame_id: world
-child_frame_id: robot_calibration
-transform:
-  translation:
-    x: 0.75
-    y: 0.5
-    z: 1.0
-  rotation:
-    x: -0.62908825919
-    y: 0.210952809338
-    z: 0.640171445021
-    w: 0.38720459109
diff --git a/test_tf2/test/test_utils.cpp b/test_tf2/test/test_utils.cpp
deleted file mode 100644
index 6aa2394c..00000000
--- a/test_tf2/test/test_utils.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright 2014 Open Source Robotics Foundation, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <gtest/gtest.h>
-
-#include <geometry_msgs/msg/quaternion.hpp>
-#include <geometry_msgs/msg/quaternion_stamped.hpp>
-#include <geometry_msgs/msg/transform.hpp>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2/utils.h>
-#include <tf2_kdl/tf2_kdl.hpp>
-
-double epsilon = 1e-9;
-
-template<typename T>
-void yprTest(const T& t, double yaw1, double pitch1, double roll1) {
-  double yaw2, pitch2, roll2;
-
-  tf2::getEulerYPR(t, yaw2, pitch2, roll2);
-
-  EXPECT_NEAR(yaw1, yaw2, epsilon);
-  EXPECT_NEAR(pitch1, pitch2, epsilon);
-  EXPECT_NEAR(roll1, roll2, epsilon);
-  EXPECT_NEAR(tf2::getYaw(t), yaw1, epsilon);
-}
-
-TEST(tf2Utils, yaw)
-{
-  double x, y, z, w;
-  x = 0.4;
-  y = 0.5;
-  z = 0.6;
-  w = 0.7;
-
-  double yaw1, pitch1, roll1;
-  // Compute results one way with KDL
-  KDL::Rotation::Quaternion(x, y, z, w).GetRPY(roll1, pitch1, yaw1);
-  {
-    // geometry_msgs::msg::Quaternion
-    geometry_msgs::msg::Quaternion q;
-    q.x = x; q.y =y; q.z = z; q.w = w;
-    yprTest(q, yaw1, pitch1, roll1);
-
-    // geometry_msgs::msg::QuaternionStamped
-    geometry_msgs::msg::QuaternionStamped qst;
-    qst.quaternion = q;
-    yprTest(qst, yaw1, pitch1, roll1);
-  }
-
-
-  {
-    // tf2::Quaternion
-    tf2::Quaternion q(x, y, z, w);
-    yprTest(q, yaw1, pitch1, roll1);
-
-    // TODO (ahcorde): This PR fix this issue https://github.com/ros/geometry2/pull/357
-    // // tf2::Stamped<tf2::Quaternion>
-    // tf2::Stamped<tf2::Quaternion> sq;
-    // sq.setData(q);
-    // yprTest(sq, yaw1, pitch1, roll1);
-  }
-}
-
-TEST(tf2Utils, identity)
-{
-  geometry_msgs::msg::Transform t;
-  t.translation.x = 0.1;
-  t.translation.y = 0.2;
-  t.translation.z = 0.3;
-  t.rotation.x = 0.4;
-  t.rotation.y = 0.5;
-  t.rotation.z = 0.6;
-  t.rotation.w = 0.7;
-
-  // Test identity
-  t = tf2::getTransformIdentity<geometry_msgs::msg::Transform>();
-
-  EXPECT_EQ(t.translation.x, 0);
-  EXPECT_EQ(t.translation.y, 0);
-  EXPECT_EQ(t.translation.z, 0);
-  EXPECT_EQ(t.rotation.x, 0);
-  EXPECT_EQ(t.rotation.y, 0);
-  EXPECT_EQ(t.rotation.z, 0);
-  EXPECT_EQ(t.rotation.w, 1);
-}
-
-int main(int argc, char** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/tf2_bullet/CHANGELOG.rst b/tf2_bullet/CHANGELOG.rst
deleted file mode 100644
index 3baf2675..00000000
--- a/tf2_bullet/CHANGELOG.rst
+++ /dev/null
@@ -1,242 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package tf2_bullet
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-0.25.7 (2024-05-29)
--------------------
-
-0.25.6 (2024-02-16)
--------------------
-
-0.25.5 (2023-11-13)
--------------------
-
-0.25.4 (2023-09-19)
--------------------
-
-0.25.3 (2023-07-17)
--------------------
-
-0.25.2 (2023-01-10)
--------------------
-
-0.25.1 (2022-08-05)
--------------------
-
-0.25.0 (2022-04-05)
--------------------
-* Install includes to include/${PROJECT_NAME} and use modern CMake (`#493 <https://github.com/ros2/geometry2/issues/493>`_)
-* Contributors: Shane Loretz
-
-0.24.0 (2022-03-31)
--------------------
-* Export a tf2_bullet::tf2_bullet target (`#495 <https://github.com/ros2/geometry2/issues/495>`_)
-* Contributors: Shane Loretz
-
-0.23.0 (2022-03-28)
--------------------
-
-0.22.0 (2022-03-01)
--------------------
-
-0.21.0 (2022-01-14)
--------------------
-* Fix cpplint errors (`#497 <https://github.com/ros2/geometry2/issues/497>`_)
-* Contributors: Jacob Perron
-
-0.20.0 (2021-12-17)
--------------------
-
-0.19.0 (2021-10-15)
--------------------
-* Remove some references to the ROS 1 wiki.
-* Contributors: Chris Lalancette
-
-0.18.0 (2021-06-01)
--------------------
-* Fix tf2_bullet dependency export (`#428 <https://github.com/ros2/geometry2/issues/428>`_)
-* Deprecate tf2_bullet.h (`#412 <https://github.com/ros2/geometry2/issues/412>`_)
-* Contributors: Bjar Ne, Chris Lalancette
-
-0.17.1 (2021-04-06)
--------------------
-
-0.17.0 (2021-03-19)
--------------------
-
-0.16.0 (2021-01-25)
--------------------
-
-0.15.1 (2020-12-08)
--------------------
-
-0.15.0 (2020-11-02)
--------------------
-* Update maintainers of the ros2/geometry2 fork. (`#328 <https://github.com/ros2/geometry2/issues/328>`_)
-* Contributors: Chris Lalancette
-
-0.14.1 (2020-09-21)
--------------------
-* Activate usual compiler warnings and fix errors (`#270 <https://github.com/ros2/geometry2/issues/270>`_)
-* Contributors: Ivan Santiago Paunovic
-
-0.14.0 (2020-08-14)
--------------------
-* Suppress compiler warning on Centos (`#290 <https://github.com/ros2/geometry2/issues/290>`_)
-* Contributors: Michael Carroll
-
-0.13.4 (2020-06-03)
--------------------
-
-0.13.3 (2020-05-26)
--------------------
-
-0.13.2 (2020-05-18)
--------------------
-
-0.13.1 (2020-05-08)
--------------------
-
-0.13.0 (2020-04-30)
--------------------
-* Added doxyfiles and sphinx Makefiles (`#257 <https://github.com/ros2/geometry2/issues/257>`_)
-* Porting tf2_bullet to ros2 (`#205 <https://github.com/ros2/geometry2/issues/205>`_)
-* Contributors: Alejandro Hernández Cordero
-
-0.5.15 (2017-01-24)
--------------------
-
-0.5.14 (2017-01-16)
--------------------
-* Improve documentation
-* Contributors: Jackie Kay
-
-0.5.13 (2016-03-04)
--------------------
-* Don't export catkin includes
-  They only point to the temporary include in the build directory.
-* Contributors: Jochen Sprickerhof
-
-0.5.12 (2015-08-05)
--------------------
-
-0.5.11 (2015-04-22)
--------------------
-
-0.5.10 (2015-04-21)
--------------------
-
-0.5.9 (2015-03-25)
-------------------
-
-0.5.8 (2015-03-17)
-------------------
-* remove useless Makefile files
-* fix ODR violations
-* Contributors: Vincent Rabaud
-
-0.5.7 (2014-12-23)
-------------------
-* fixing install rules and adding backwards compatible include with #warning
-* Contributors: Tully Foote
-
-0.5.6 (2014-09-18)
-------------------
-
-0.5.5 (2014-06-23)
-------------------
-
-0.5.4 (2014-05-07)
-------------------
-
-0.5.3 (2014-02-21)
-------------------
-
-0.5.2 (2014-02-20)
-------------------
-
-0.5.1 (2014-02-14)
-------------------
-
-0.5.0 (2014-02-14)
-------------------
-
-0.4.10 (2013-12-26)
--------------------
-
-0.4.9 (2013-11-06)
-------------------
-* adding missing buildtool dependency on pkg-config
-
-0.4.8 (2013-11-06)
-------------------
-
-0.4.7 (2013-08-28)
-------------------
-
-0.4.6 (2013-08-28)
-------------------
-
-0.4.5 (2013-07-11)
-------------------
-
-0.4.4 (2013-07-09)
-------------------
-* making repo use CATKIN_ENABLE_TESTING correctly and switching rostest to be a test_depend with that change.
-
-0.4.3 (2013-07-05)
-------------------
-
-0.4.2 (2013-07-05)
-------------------
-* removing unused dependency on rostest
-
-0.4.1 (2013-07-05)
-------------------
-* stripping tf2_ros dependency from tf2_bullet.  Test was moved to test_tf2
-
-0.4.0 (2013-06-27)
-------------------
-* moving convert methods back into tf2 because it does not have any ros dependencies beyond ros::Time which is already a dependency of tf2
-* Cleaning up unnecessary dependency on roscpp
-* converting contents of tf2_ros to be properly namespaced in the tf2_ros namespace
-* Cleaning up packaging of tf2 including:
-  removing unused nodehandle
-  cleaning up a few dependencies and linking
-  removing old backup of package.xml
-  making diff minimally different from tf version of library
-* Restoring test packages and bullet packages.
-  reverting 3570e8c42f9b394ecbfd9db076b920b41300ad55 to get back more of the packages previously implemented
-  reverting 04cf29d1b58c660fdc999ab83563a5d4b76ab331 to fix `#7 <https://github.com/ros/geometry_experimental/issues/7>`_
-
-0.3.6 (2013-03-03)
-------------------
-
-0.3.5 (2013-02-15 14:46)
-------------------------
-
-0.3.4 (2013-02-15 13:14)
-------------------------
-
-0.3.3 (2013-02-15 11:30)
-------------------------
-
-0.3.2 (2013-02-15 00:42)
-------------------------
-
-0.3.1 (2013-02-14)
-------------------
-
-0.3.0 (2013-02-13)
-------------------
-* fixing groovy-devel
-* removing bullet and kdl related packages
-* catkinizing geometry-experimental
-* catkinizing tf2_bullet
-* merge tf2_cpp and tf2_py into tf2_ros
-* A working first version of transforming and converting between different types
-* Fixing tests now that Buffer creates a NodeHandle
-* add frame unit tests to kdl and bullet
-* add first regression tests for kdl and bullet tf
-* add btTransform transform
-* add bullet transforms, and create tests for bullet and kdl
diff --git a/tf2_bullet/CMakeLists.txt b/tf2_bullet/CMakeLists.txt
deleted file mode 100644
index e83e1abd..00000000
--- a/tf2_bullet/CMakeLists.txt
+++ /dev/null
@@ -1,51 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(tf2_bullet)
-
-# Default to C14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)
-endif()
-
-
-find_package(ament_cmake REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(tf2 REQUIRED)
-find_package(tf2_ros REQUIRED)
-
-include(bullet-extras.cmake)
-
-add_library(tf2_bullet INTERFACE)
-target_include_directories(tf2_bullet INTERFACE
-  "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
-  "$<INSTALL_INTERFACE:include/${PROJECT_NAME}>")
-target_link_libraries(tf2_bullet INTERFACE
-  tf2_bullet::Bullet
-  tf2::tf2
-  ${geometry_msgs_TARGETS}
-  tf2_ros::tf2_ros)
-
-install(TARGETS tf2_bullet EXPORT export_tf2_bullet)
-
-install(DIRECTORY include/ DESTINATION include/${PROJECT_NAME})
-
-if(BUILD_TESTING)
-  find_package(ament_lint_auto REQUIRED)
-  find_package(ament_cmake_cppcheck REQUIRED)
-  list(APPEND AMENT_LINT_AUTO_EXCLUDE
-    ament_cmake_cppcheck
-  )
-  ament_lint_auto_find_test_dependencies()
-  ament_cppcheck(LANGUAGE c++)
-
-  find_package(ament_cmake_gtest REQUIRED)
-  ament_add_gtest(test_bullet test/test_tf2_bullet.cpp)
-  target_link_libraries(test_bullet tf2_bullet)
-endif()
-
-ament_export_targets(export_tf2_bullet)
-
-ament_package(CONFIG_EXTRAS bullet-extras.cmake)
diff --git a/tf2_bullet/Doxyfile b/tf2_bullet/Doxyfile
deleted file mode 100644
index abada890..00000000
--- a/tf2_bullet/Doxyfile
+++ /dev/null
@@ -1,27 +0,0 @@
-# All settings not listed here will use the Doxygen default values.
-
-PROJECT_NAME           = "tf2_bullet"
-PROJECT_NUMBER         = master
-PROJECT_BRIEF          = "Bullet binding for tf2."
-
-INPUT                  = ./include mainpage.dox
-RECURSIVE              = YES
-OUTPUT_DIRECTORY       = doc_output
-
-EXTRACT_ALL            = YES
-SORT_MEMBER_DOCS       = NO
-
-GENERATE_LATEX         = NO
-
-ENABLE_PREPROCESSING   = YES
-MACRO_EXPANSION        = YES
-EXPAND_ONLY_PREDEF     = YES
-PREDEFINED             += TF2_PUBLIC=
-
-# Tag files that do not exist will produce a warning and cross-project linking will not work.
-TAGFILES += "../../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/"
-# Consider changing "latest" to the version you want to reference (e.g. beta1 or 1.0.0)
-TAGFILES += "../../../../doxygen_tag_files/rcutils.tag=http://docs.ros2.org/latest/api/rcutils/"
-TAGFILES += "../../../../doxygen_tag_files/tf2.tag=http://docs.ros2.org/latest/api/tf2/"
-TAGFILES += "../../../../doxygen_tag_files/tf2_ros.tag=http://docs.ros2.org/latest/api/tf2_ros/"
-GENERATE_TAGFILE = "../../../../doxygen_tag_files/tf2_bullet.tag"
diff --git a/tf2_bullet/bullet-extras.cmake b/tf2_bullet/bullet-extras.cmake
deleted file mode 100644
index 03c77e30..00000000
--- a/tf2_bullet/bullet-extras.cmake
+++ /dev/null
@@ -1,40 +0,0 @@
-# Copyright 2021 Open Source Robotics Foundation, Inc.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are met:
-#
-#    * Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#
-#    * Redistributions in binary form must reproduce the above copyright
-#      notice, this list of conditions and the following disclaimer in the
-#      documentation and/or other materials provided with the distribution.
-#
-#    * Neither the name of the Open Source Robotics Foundation, Inc. nor the names of its
-#      contributors may be used to endorse or promote products derived from
-#      this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-# Bullet CMake only exports old-style CMake variables.
-# This script makes an imported target for them.
-
-if(WIN32)
-  set(BULLET_ROOT $ENV{ChocolateyInstall}/lib/bullet)
-endif()
-find_package(Bullet REQUIRED)
-
-add_library(tf2_bullet::Bullet INTERFACE IMPORTED)
-target_include_directories(tf2_bullet::Bullet INTERFACE ${BULLET_INCLUDE_DIRS})
-target_link_libraries(tf2_bullet::Bullet INTERFACE ${BULLET_LIBRARIES})
-target_compile_definitions(tf2_bullet::Bullet INTERFACE ${BULLET_DEFINITIONS})
diff --git a/tf2_bullet/include/tf2_bullet/tf2_bullet.h b/tf2_bullet/include/tf2_bullet/tf2_bullet.h
deleted file mode 100644
index 99a5f9bd..00000000
--- a/tf2_bullet/include/tf2_bullet/tf2_bullet.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2008 Willow Garage, Inc.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage, Inc. nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Wim Meeussen */
-
-#ifndef TF2_BULLET__TF2_BULLET_H_
-#define TF2_BULLET__TF2_BULLET_H_
-
-#warning This header is obsolete, please include tf2_bullet/tf2_bullet.hpp instead
-
-#include <tf2_bullet/tf2_bullet.hpp>
-
-#endif  // TF2_BULLET__TF2_BULLET_H_
diff --git a/tf2_bullet/include/tf2_bullet/tf2_bullet.hpp b/tf2_bullet/include/tf2_bullet/tf2_bullet.hpp
deleted file mode 100644
index 061e076f..00000000
--- a/tf2_bullet/include/tf2_bullet/tf2_bullet.hpp
+++ /dev/null
@@ -1,146 +0,0 @@
-// Copyright 2008 Willow Garage, Inc.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage, Inc. nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Wim Meeussen */
-
-#ifndef TF2_BULLET__TF2_BULLET_HPP_
-#define TF2_BULLET__TF2_BULLET_HPP_
-
-#include <iostream>
-
-#include "tf2/convert.h"
-#include "LinearMath/btQuaternion.h"
-#include "LinearMath/btScalar.h"
-#include "LinearMath/btTransform.h"
-#include "geometry_msgs/msg/point_stamped.hpp"
-#include "tf2_ros/buffer_interface.h"
-
-#if (BT_BULLET_VERSION <= 282)
-// Suppress compilation warning on older versions of Bullet.
-// TODO(mjcarroll): Remove this when all platforms have the fix upstream.
-inline int bullet_btInfinityMask()
-{
-  return btInfinityMask;
-}
-#endif
-
-namespace tf2
-{
-/** \brief Convert a timestamped transform to the equivalent Bullet data type.
- * \param t The transform to convert, as a geometry_msgs TransformedStamped message.
- * \return The transform message converted to a Bullet btTransform.
- */
-inline
-btTransform transformToBullet(const geometry_msgs::msg::TransformStamped & t)
-{
-  return btTransform(
-    btQuaternion(
-      static_cast<float>(t.transform.rotation.x),
-      static_cast<float>(t.transform.rotation.y),
-      static_cast<float>(t.transform.rotation.z),
-      static_cast<float>(t.transform.rotation.w)),
-    btVector3(
-      static_cast<float>(t.transform.translation.x),
-      static_cast<float>(t.transform.translation.y),
-      static_cast<float>(t.transform.translation.z)));
-}
-
-
-/** \brief Apply a geometry_msgs TransformStamped to a Bullet-specific Vector3 type.
- * This function is a specialization of the doTransform template defined in tf2/convert.h
- * \param t_in The vector to transform, as a timestamped Bullet btVector3 data type.
- * \param t_out The transformed vector, as a timestamped Bullet btVector3 data type.
- * \param transform The timestamped transform to apply, as a TransformStamped message.
- */
-template< >
-inline
-void doTransform(
-  const tf2::Stamped<btVector3> & t_in, tf2::Stamped<btVector3> & t_out,
-  const geometry_msgs::msg::TransformStamped & transform)
-{
-  t_out =
-    tf2::Stamped<btVector3>(
-    transformToBullet(transform) * t_in,
-    tf2_ros::fromMsg(transform.header.stamp), transform.header.frame_id);
-}
-
-/** \brief Convert a stamped Bullet Vector3 type to a PointStamped message.
- * This function is a specialization of the toMsg template defined in tf2/convert.h
- * \param in The timestamped Bullet btVector3 to convert.
- * \return The vector converted to a PointStamped message.
- */
-inline
-geometry_msgs::msg::PointStamped toMsg(const tf2::Stamped<btVector3> & in)
-{
-  geometry_msgs::msg::PointStamped msg;
-  msg.header.stamp = tf2_ros::toMsg(in.stamp_);
-  msg.header.frame_id = in.frame_id_;
-  msg.point.x = in[0];
-  msg.point.y = in[1];
-  msg.point.z = in[2];
-  return msg;
-}
-
-/** \brief Convert a PointStamped message type to a stamped Bullet-specific Vector3 type.
- * This function is a specialization of the fromMsg template defined in tf2/convert.h
- * \param msg The PointStamped message to convert.
- * \param out The point converted to a timestamped Bullet Vector3.
- */
-inline
-void fromMsg(const geometry_msgs::msg::PointStamped & msg, tf2::Stamped<btVector3> & out)
-{
-  out.stamp_ = tf2_ros::fromMsg(msg.header.stamp);
-  out.frame_id_ = msg.header.frame_id;
-  out[0] = static_cast<float>(msg.point.x);
-  out[1] = static_cast<float>(msg.point.y);
-  out[2] = static_cast<float>(msg.point.z);
-}
-
-
-/** \brief Apply a geometry_msgs TransformStamped to a Bullet-specific Transform data type.
- * This function is a specialization of the doTransform template defined in tf2/convert.h
- * \param t_in The frame to transform, as a timestamped Bullet btTransform.
- * \param t_out The transformed frame, as a timestamped Bullet btTransform.
- * \param transform The timestamped transform to apply, as a TransformStamped message.
- */
-template< >
-inline
-void doTransform(
-  const tf2::Stamped<btTransform> & t_in, tf2::Stamped<btTransform> & t_out,
-  const geometry_msgs::msg::TransformStamped & transform)
-{
-  t_out =
-    tf2::Stamped<btTransform>(
-    transformToBullet(transform) * t_in,
-    tf2_ros::fromMsg(transform.header.stamp), transform.header.frame_id);
-}
-
-
-}  // namespace tf2
-
-#endif  // TF2_BULLET__TF2_BULLET_HPP_
diff --git a/tf2_bullet/mainpage.dox b/tf2_bullet/mainpage.dox
deleted file mode 100644
index 2438d298..00000000
--- a/tf2_bullet/mainpage.dox
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
-\mainpage
-\htmlinclude manifest.html
-
-\b tf2_bullet contains functions for converting between geometry_msgs and Bullet data types.
-
-This library is an implementation of the templated conversion interface specified in tf/convert.h.
-It enables easy conversion from geometry_msgs Transform and Point types to the types specified
-by the Bullet physics engine API (see http://bulletphysics.org).
-
-\section codeapi Code API
-
-This library consists of one header only, tf2_bullet/tf2_bullet.hpp, which consists mostly of
-specializations of template functions defined in tf2/convert.h.
-
-*/
diff --git a/tf2_bullet/package.xml b/tf2_bullet/package.xml
deleted file mode 100644
index 14dcbbe9..00000000
--- a/tf2_bullet/package.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<package format="2">
-  <name>tf2_bullet</name>
-  <version>0.25.7</version>
-  <description>
-    tf2_bullet
-  </description>
-  <maintainer email="clalancette@openrobotics.org">Chris Lalancette</maintainer>
-  <maintainer email="alejandro@openrobotics.org">Alejandro Hernandez Cordero</maintainer>
-  <license>BSD</license>
-  <url type="website">http://www.ros.org/wiki/tf2_bullet</url>
-  <author email="tfoote@osrfoundation.org">Tully Foote</author>
-  <author>Wim Meeussen</author>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <build_depend>bullet</build_depend>
-  <build_depend>geometry_msgs</build_depend>
-  <build_depend>tf2</build_depend>
-  <build_depend>tf2_ros</build_depend>
-
-  <exec_depend>bullet</exec_depend>
-  <exec_depend>geometry_msgs</exec_depend>
-  <exec_depend>tf2</exec_depend>
-  <exec_depend>tf2_ros</exec_depend>
-
-  <test_depend>ament_cmake_gtest</test_depend>
-  <test_depend>ament_lint_auto</test_depend>
-  <test_depend>ament_lint_common</test_depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-
-</package>
diff --git a/tf2_bullet/test/test_tf2_bullet.cpp b/tf2_bullet/test/test_tf2_bullet.cpp
deleted file mode 100644
index 9678d8b2..00000000
--- a/tf2_bullet/test/test_tf2_bullet.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2008 Willow Garage, Inc.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage, Inc. nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Wim Meeussen */
-
-#include "tf2_bullet/tf2_bullet.hpp"
-#include "rclcpp/rclcpp.hpp"
-#include "gtest/gtest.h"
-#include "tf2/convert.h"
-
-TEST(TfBullet, ConvertVector)
-{
-  btVector3 v(1, 2, 3);
-
-  btVector3 v1 = v;
-  tf2::convert(v1, v1);
-
-  EXPECT_EQ(v, v1);
-
-  btVector3 v2(3, 4, 5);
-  tf2::convert(v1, v2);
-
-  EXPECT_EQ(v, v2);
-  EXPECT_EQ(v1, v2);
-}
-
-
-int main(int argc, char ** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-
-  int ret = RUN_ALL_TESTS();
-  return ret;
-}
