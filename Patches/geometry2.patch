diff --git a/geometry2/package.xml b/geometry2/package.xml
index 5d32c060..c0d88090 100644
--- a/geometry2/package.xml
+++ b/geometry2/package.xml
@@ -18,7 +18,6 @@
   <buildtool_depend>ament_cmake</buildtool_depend>
 
   <exec_depend>tf2</exec_depend>
-  <exec_depend>tf2_bullet</exec_depend>
   <exec_depend>tf2_eigen</exec_depend>
   <exec_depend>tf2_eigen_kdl</exec_depend>
   <exec_depend>tf2_geometry_msgs</exec_depend>
diff --git a/test_tf2/CHANGELOG.rst b/test_tf2/CHANGELOG.rst
deleted file mode 100644
index 221d2821..00000000
--- a/test_tf2/CHANGELOG.rst
+++ /dev/null
@@ -1,335 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package test_tf2
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-0.25.7 (2024-05-29)
--------------------
-
-0.25.6 (2024-02-16)
--------------------
-
-0.25.5 (2023-11-13)
--------------------
-
-0.25.4 (2023-09-19)
--------------------
-
-0.25.3 (2023-07-17)
--------------------
-
-0.25.2 (2023-01-10)
--------------------
-
-0.25.1 (2022-08-05)
--------------------
-
-0.25.0 (2022-04-05)
--------------------
-* Fix more instances of Eigen problems on RHEL. (`#515 <https://github.com/ros2/geometry2/issues/515>`_)
-* Install includes to include/${PROJECT_NAME} and use modern CMake (`#493 <https://github.com/ros2/geometry2/issues/493>`_)
-* Contributors: Chris Lalancette, Shane Loretz
-
-0.24.0 (2022-03-31)
--------------------
-
-0.23.0 (2022-03-28)
--------------------
-* Fix precision loss from using rclcpp::Time::seconds() (`#511 <https://github.com/ros2/geometry2/issues/511>`_)
-* Contributors: Kenji Brameld
-
-0.22.0 (2022-03-01)
--------------------
-
-0.21.0 (2022-01-14)
--------------------
-
-0.20.0 (2021-12-17)
--------------------
-
-0.19.0 (2021-10-15)
--------------------
-* More Intuitive CLI for Static Transform Publisher (`#392 <https://github.com/ros2/geometry2/issues/392>`_)
-* Contributors: Hunter L. Allen
-
-0.18.0 (2021-06-01)
--------------------
-* Conversion tests for toMsg() (`#423 <https://github.com/ros2/geometry2/issues/423>`_)
-* Deprecate tf2_geometry_msgs.h (`#418 <https://github.com/ros2/geometry2/issues/418>`_)
-* Deprecate tf2_kdl.h (`#414 <https://github.com/ros2/geometry2/issues/414>`_)
-* Deprecate tf2_bullet.h (`#412 <https://github.com/ros2/geometry2/issues/412>`_)
-* Contributors: Bjar Ne, Chris Lalancette
-
-0.17.1 (2021-04-06)
--------------------
-
-0.17.0 (2021-03-19)
--------------------
-
-0.16.0 (2021-01-25)
--------------------
-
-0.15.1 (2020-12-08)
--------------------
-
-0.15.0 (2020-11-02)
--------------------
-* Update maintainers of the ros2/geometry2 fork. (`#328 <https://github.com/ros2/geometry2/issues/328>`_)
-* Contributors: Chris Lalancette
-
-0.14.1 (2020-09-21)
--------------------
-* Activate usual compiler warnings and fix errors (`#270 <https://github.com/ros2/geometry2/issues/270>`_)
-* Contributors: Ivan Santiago Paunovic
-
-0.14.0 (2020-08-14)
--------------------
-* Fix a TOCTTOU race in tf2. (`#307 <https://github.com/ros2/geometry2/issues/307>`_)
-* Fixed memory leak in Buffer::waitForTransform (`#281 <https://github.com/ros2/geometry2/issues/281>`_)
-* relax test timings to pass with Connext (`#304 <https://github.com/ros2/geometry2/issues/304>`_)
-* Explicitly initialize instances of tf2::Duration (`#291 <https://github.com/ros2/geometry2/issues/291>`_)
-* Generate callbacks after updating message\_ (`#274 <https://github.com/ros2/geometry2/issues/274>`_)
-* fix test_static_publisher in macos (`#284 <https://github.com/ros2/geometry2/issues/284>`_)
-* Fix up the dependencies in test_tf2. (`#277 <https://github.com/ros2/geometry2/issues/277>`_)
-* Split tf2_ros in tf2_ros and tf2_ros_py (`#210 <https://github.com/ros2/geometry2/issues/210>`_)
-* Contributors: Alejandro Hernández Cordero, Chris Lalancette, Dirk Thomas, Martin Ganeff, Michael Carroll, ymd-stella
-
-0.13.4 (2020-06-03)
--------------------
-
-0.13.3 (2020-05-26)
--------------------
-
-0.13.2 (2020-05-18)
--------------------
-* Fix deprecation warnings from launch (`#264 <https://github.com/ros2/geometry2/issues/264>`_)
-* Contributors: Chris Lalancette
-
-0.13.1 (2020-05-08)
--------------------
-
-0.13.0 (2020-04-30)
--------------------
-* Replace deprecated launch_ros usage (`#250 <https://github.com/ros2/geometry2/issues/250>`_)
-* Remote ready_fn from launch_testing tests (`#243 <https://github.com/ros2/geometry2/issues/243>`_)
-* [test_tf2] Call project() and ament_package() if not building tests (`#233 <https://github.com/ros2/geometry2/issues/233>`_)
-* Porting test_tf2  (`#203 <https://github.com/ros2/geometry2/issues/203>`_)
-* Contributors: Alejandro Hernández Cordero, Jacob Perron, Peter Baughman
-
-0.5.15 (2017-01-24)
--------------------
-
-0.5.14 (2017-01-16)
--------------------
-* Typos.
-* Adds unit tests for TF loaded from parameter server.
-  This tests both success (loading a valid TF into the param server) and
-  failures (parameter does not exist, parameter contents are invalid).
-* Code linting & reorganization
-  - whitespace
-  - indentation
-  - re-organized code to remove duplications.
-  whitespace & indentation changes only.
-  simplified (de-duplicated) duplicate code.
-  missing a duplicate variable.
-  whitespace changes only.
-* Contributors: Felix Duvallet
-
-0.5.13 (2016-03-04)
--------------------
-* Remove LGPL from license tags
-  LGPL was erroneously included in 2a38724. As there are no files with it
-  in the package.
-* Contributors: Jochen Sprickerhof
-
-0.5.12 (2015-08-05)
--------------------
-* add utilities to get yaw, pitch, roll and identity transform
-* provide more conversions between types
-  The previous conversion always assumed that it was converting a
-  non-message type to a non-message type. Now, one, both or none
-  can be a message or a non-message.
-* Contributors: Vincent Rabaud
-
-0.5.11 (2015-04-22)
--------------------
-
-0.5.10 (2015-04-21)
--------------------
-
-0.5.9 (2015-03-25)
-------------------
-
-0.5.8 (2015-03-17)
-------------------
-* remove useless Makefile files
-* Contributors: Vincent Rabaud
-
-0.5.7 (2014-12-23)
-------------------
-
-0.5.6 (2014-09-18)
-------------------
-
-0.5.5 (2014-06-23)
-------------------
-* Removed AsyncSpinner workaround
-* Contributors: Esteve Fernandez
-
-0.5.4 (2014-05-07)
-------------------
-* Clean up warnings about autostart and add some assertions for coverage
-* Contributors: Tully Foote
-
-0.5.3 (2014-02-21)
-------------------
-
-0.5.2 (2014-02-20)
-------------------
-
-0.5.1 (2014-02-14)
-------------------
-
-0.5.0 (2014-02-14)
-------------------
-
-0.4.10 (2013-12-26)
--------------------
-* fixing kdl linking for tests
-* Contributors: Tully Foote
-
-0.4.9 (2013-11-06)
-------------------
-
-0.4.8 (2013-11-06)
-------------------
-* Fixed static_transform_publisher duplicate check, added rostest.
-
-0.4.7 (2013-08-28)
-------------------
-
-0.4.6 (2013-08-28)
-------------------
-
-0.4.5 (2013-07-11)
-------------------
-* fixing quaternion in unit test and adding a timeout on the waitForServer
-* fixing usage string to show quaternions and using quaternions in the test app
-* removing redundant declaration
-* disabling whole cmake invocation in test_tf2 when not CATKIN_ENABLE_TESTING
-
-0.4.4 (2013-07-09)
-------------------
-
-0.4.3 (2013-07-05)
-------------------
-
-0.4.2 (2013-07-05)
-------------------
-
-0.4.1 (2013-07-05)
-------------------
-* fixing test target dependencies
-* fixing colliding target names between geometry and geometry_experimental
-* stripping tf2_ros dependency from tf2_bullet.  Test was moved to test_tf2
-
-0.4.0 (2013-06-27)
-------------------
-* splitting rospy dependency into tf2_py so tf2 is pure c++ library.
-* switching to console_bridge from rosconsole
-* moving convert methods back into tf2 because it does not have any ros dependencies beyond ros::Time which is already a dependency of tf2
-* Cleaning up unnecessary dependency on roscpp
-* converting contents of tf2_ros to be properly namespaced in the tf2_ros namespace
-* Cleaning up packaging of tf2 including:
-  removing unused nodehandle
-  fixing overmatch on search and replace
-  cleaning up a few dependencies and linking
-  removing old backup of package.xml
-  making diff minimally different from tf version of library
-* Restoring test packages and bullet packages.
-  reverting 3570e8c42f9b394ecbfd9db076b920b41300ad55 to get back more of the packages previously implemented
-  reverting 04cf29d1b58c660fdc999ab83563a5d4b76ab331 to fix `#7 <https://github.com/ros/geometry_experimental/issues/7>`_
-
-0.3.6 (2013-03-03)
-------------------
-
-0.3.5 (2013-02-15 14:46)
-------------------------
-
-0.3.4 (2013-02-15 13:14)
-------------------------
-
-0.3.3 (2013-02-15 11:30)
-------------------------
-
-0.3.2 (2013-02-15 00:42)
-------------------------
-
-0.3.1 (2013-02-14)
-------------------
-
-0.3.0 (2013-02-13)
-------------------
-* removing packages with missing deps
-* catkinizing geometry-experimental
-* add boost linkage
-* fixing test for header cleanup
-* fixing usage of bullet for migration to native bullet
-* Cleanup on test code, all tests pass
-* cleanup on optimized tests, still failing
-* Cleanup in compound transform test
-* Adding more frames to compound transform case
-* Compound transform test fails on optimized case after more frames added
-* Compound transform test has more frames in it
-* Cleanup of compount transform test
-* Compound transform at root node test fails for optimized branch
-* compount transform test, non-optimized
-* time-varying tests with different time-steps for optimized case
-* Time-varying test inserts data at different time-steps for non-optimized case
-* Helix (time-varying) test works on optimized branch
-* Adding more complicated case to helix test
-* Adding helix test for time-varying transforms in non-optimized case
-* Corrected ring45 values in buffer core test
-* Corrected values of ring45 test for non-optimized case
-* Ring 45 test running on non-optimized tf2 branch, from Tully's commit r880
-* filling out ring test case which finds errors in the optimization
-* Add option to use a callback queue in the message filter
-* another out-the-back test
-* move the message filter to tf2_ros
-* fix warnings
-* merge from tf_rework
-* tf2::MessageFilter + tests.  Still need to change it around to pass in a callback queue, since we're being triggered directly from the tf2 buffer
-* adding in y configuration test
-* a little more realistic
-* Don't add the request if the transform is already available.  Add some new tests
-* working transformable callbacks with a simple (incomplete) test case
-* cleaning up test setup
-* check_v implemented and passing v test and multi tree test
-* working toward multi configuration tests
-* removing restructuring for it won't nest like I thought
-* continuing restructuring and filling in test case setup
-* restructuring before scaling
-* Completely remove lookupLists().  canTransform() now uses the same walking code as lookupTransform().  Also fixed a bug in the static transform publisher test
-* testing chaining in a ring
-* test dataset generator
-* more complicated test with interleaving static and dynamic frames passing
-* static transform tested and working
-* test in progress, need to unshelve changes.
-* tests passing and all throw catches removed too\!
-* move to tf2_ros completed. tests pass again
-* merge tf2_cpp and tf2_py into tf2_ros
-* merging and fixing broken unittest
-* Got transform with types working in python
-* A working first version of transforming and converting between different types
-* removing unused datatypes
-* removing include of old tf from tf2
-* testing new argument validation and catching bug
-* unit test of single link one to try to debug eitan's client bug
-* working towards interpolation too
-* A working version of a test case for the python buffer client
-* merging
-* adding else to catch uncovered cases, and changing time for easier use
-* Adding a test for the python buffer client
-* using permuter now and doing a,b,c to a,b,c, at three different times including 0
-* Moving tf2_tests to test_tf2
-* moving test to new package
-* initial package created for testing tf2
diff --git a/test_tf2/CMakeLists.txt b/test_tf2/CMakeLists.txt
deleted file mode 100644
index a05818f3..00000000
--- a/test_tf2/CMakeLists.txt
+++ /dev/null
@@ -1,141 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-
-project(test_tf2)
-
-find_package(ament_cmake REQUIRED)
-
-if(NOT BUILD_TESTING)
-  ament_package()
-  return()
-endif()
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)
-endif()
-
-find_package(ament_cmake_gtest REQUIRED)
-find_package(builtin_interfaces REQUIRED)
-# Work around broken find module in AlmaLinux/RHEL eigen3-devel from PowerTools repo
-find_package(Eigen3 QUIET NO_MODULE)
-if(NOT Eigen3_FOUND)
-  find_package(Eigen3 REQUIRED)
-endif()
-find_package(geometry_msgs REQUIRED)
-find_package(launch_testing_ament_cmake REQUIRED)
-find_package(rclcpp REQUIRED)
-find_package(tf2 REQUIRED)
-find_package(tf2_bullet REQUIRED)
-find_package(tf2_eigen REQUIRED)
-find_package(tf2_geometry_msgs REQUIRED)
-find_package(tf2_kdl REQUIRED)
-find_package(tf2_ros REQUIRED)
-
-ament_find_gtest()
-
-ament_add_gtest(buffer_core_test test/buffer_core_test.cpp)
-if(TARGET buffer_core_test)
-  target_link_libraries(buffer_core_test
-    ${builtin_interfaces_TARGETS}
-    ${geometry_msgs_TARGETS}
-    rclcpp::rclcpp
-    tf2::tf2
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_ros::tf2_ros)
-endif()
-
-ament_add_gtest(test_message_filter test/test_message_filter.cpp)
-if(TARGET test_message_filter)
-  target_link_libraries(test_message_filter
-    ${builtin_interfaces_TARGETS}
-    ${geometry_msgs_TARGETS}
-    rclcpp::rclcpp
-    tf2::tf2
-    tf2_ros::tf2_ros)
-endif()
-
-ament_add_gtest(test_convert test/test_convert.cpp)
-if(TARGET test_convert)
-  target_link_libraries(test_convert
-    ${geometry_msgs_TARGETS}
-    tf2::tf2
-    tf2_bullet::tf2_bullet
-    tf2_eigen::tf2_eigen
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_kdl::tf2_kdl)
-  if(TARGET Eigen3::Eigen)
-    # TODO(sloretz) require target to exist when https://github.com/ros2/choco-packages/issues/19 is addressed
-    target_link_libraries(test_convert Eigen3::Eigen)
-  else()
-    target_include_directories(test_convert PRIVATE ${Eigen3_INCLUDE_DIRS})
-  endif()
-endif()
-
-ament_add_gtest(test_utils test/test_utils.cpp)
-if(TARGET test_utils)
-  target_link_libraries(test_utils
-    ${geometry_msgs_TARGETS}
-    tf2::tf2
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_kdl::tf2_kdl)
-endif()
-
-add_executable(test_buffer_server test/test_buffer_server.cpp)
-if(TARGET test_buffer_server)
-  target_link_libraries(test_buffer_server
-    rclcpp::rclcpp
-    tf2_ros::tf2_ros)
-endif()
-
-add_executable(test_buffer_client test/test_buffer_client.cpp)
-if(TARGET test_buffer_client)
-  target_link_libraries(test_buffer_client
-    ${GTEST_LIBRARIES}
-    rclcpp::rclcpp
-    tf2_bullet::tf2_bullet
-    ${tf2_geometry_msgs_TARGETS}
-    tf2_kdl::tf2_kdl
-    tf2_ros::tf2_ros)
-  add_launch_test(test/buffer_client_tester.launch.py)
-endif()
-
-add_executable(test_static_publisher test/test_static_publisher.cpp)
-if(TARGET test_static_publisher)
-  target_link_libraries(test_static_publisher
-    ${GTEST_LIBRARIES}
-    ${geometry_msgs_TARGETS}
-    rclcpp::rclcpp
-    tf2::tf2
-    tf2_ros::tf2_ros)
-  add_launch_test(test/static_publisher.launch.py)
-endif()
-
-ament_add_gtest(test_tf2_bullet test/test_tf2_bullet.cpp)
-if(TARGET test_tf2_bullet)
-  target_link_libraries(test_tf2_bullet
-    rclcpp::rclcpp
-    tf2_bullet::tf2_bullet
-    tf2_ros::tf2_ros
-    tf2::tf2)
-endif()
-
-# TODO(ahcorde): enable once python part of tf2_geometry_msgs is working
-# add_launch_test(test/test_buffer_client.launch.py)
-
-# install executables
-install(TARGETS
-  test_buffer_client
-  test_buffer_server
-  test_static_publisher
-  DESTINATION lib/${PROJECT_NAME}
-)
-install(PROGRAMS
-  test/test_buffer_client.py
-  DESTINATION lib/${PROJECT_NAME}
-)
-
-ament_package()
diff --git a/test_tf2/mainpage.dox b/test_tf2/mainpage.dox
deleted file mode 100644
index a01bfa21..00000000
--- a/test_tf2/mainpage.dox
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
-\mainpage
-\htmlinclude manifest.html
-
-\b test_tf2 is ... 
-
-<!-- 
-Provide an overview of your package.
--->
-
-
-\section codeapi Code API
-
-<!--
-Provide links to specific auto-generated API documentation within your
-package that is of particular interest to a reader. Doxygen will
-document pretty much every part of your code, so do your best here to
-point the reader to the actual API.
-
-If your codebase is fairly large or has different sets of APIs, you
-should use the doxygen 'group' tag to keep these APIs together. For
-example, the roscpp documentation has 'libros' group.
--->
-
-
-*/
diff --git a/test_tf2/package.xml b/test_tf2/package.xml
deleted file mode 100644
index b0cdbe42..00000000
--- a/test_tf2/package.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<package format="2">
-  <name>test_tf2</name>
-  <version>0.25.7</version>
-  <description>
-    tf2 unit tests
-  </description>
-  <maintainer email="clalancette@openrobotics.org">Chris Lalancette</maintainer>
-  <maintainer email="alejandro@openrobotics.org">Alejandro Hernandez Cordero</maintainer>
-  <license>BSD</license>
-  <url type="website">http://www.ros.org/wiki/geometry_experimental</url>
-  <author email="tfoote@osrfoundation.org">Tully Foote</author>
-  <author>Eitan Marder-Eppstein</author>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <build_depend>eigen</build_depend>
-
-  <depend>builtin_interfaces</depend>
-  <depend>geometry_msgs</depend>
-  <depend>rclcpp</depend>
-  <depend>tf2</depend>
-  <depend>tf2_bullet</depend>
-  <depend>tf2_eigen</depend>
-  <depend>tf2_geometry_msgs</depend>
-  <depend>tf2_kdl</depend>
-  <depend>tf2_ros</depend>
-
-  <test_depend>ament_cmake_gtest</test_depend>
-  <test_depend>launch_ros</test_depend>
-  <test_depend>launch_testing_ament_cmake</test_depend>
-  <test_depend>tf2_ros_py</test_depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
diff --git a/test_tf2/test/buffer_client_tester.launch.py b/test_tf2/test/buffer_client_tester.launch.py
deleted file mode 100644
index 5cd426c5..00000000
--- a/test_tf2/test/buffer_client_tester.launch.py
+++ /dev/null
@@ -1,56 +0,0 @@
-# generated from buildfarm_perf_tests/test/test_performance.py.in
-# generated code does not contain a copyright notice
-
-import unittest
-
-from launch import LaunchDescription
-import launch
-from launch_ros.actions import Node
-from launch.substitutions import LaunchConfiguration
-import launch_testing
-import launch_testing.actions
-
-
-def generate_test_description():
-    node_under_test = Node(
-        package='test_tf2',
-        executable='test_buffer_client',
-        output='screen',
-        arguments=[],
-    )
-    node_static_transform_publisher = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "5", "--y", "6", "--z", "7", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "a", "--child-frame-id", "b"]
-    )
-
-    node_buffer_server = Node(
-        package='test_tf2',
-        executable='test_buffer_server',
-        output='screen',
-        arguments=[],
-        sigterm_timeout=LaunchConfiguration('sigterm_timeout', default=2)
-    )
-    return LaunchDescription([
-        node_static_transform_publisher,
-        node_buffer_server,
-        node_under_test,
-        launch_testing.util.KeepAliveProc(),
-        launch_testing.actions.ReadyToTest(),
-        ]), locals()
-
-
-class TestBufferClient(unittest.TestCase):
-
-    def test_termination(self, node_under_test, proc_info):
-        proc_info.assertWaitForShutdown(process=node_under_test, timeout=(10))
-
-
-@launch_testing.post_shutdown_test()
-class BufferClientTestAfterShutdown(unittest.TestCase):
-
-    def test_exit_code(self, proc_info):
-        # Check that all processes in the launch (in this case, there's just one) exit
-        # with code 0
-        launch_testing.asserts.assertExitCodes(proc_info)
diff --git a/test_tf2/test/buffer_core_test.cpp b/test_tf2/test/buffer_core_test.cpp
deleted file mode 100644
index 8c50112f..00000000
--- a/test_tf2/test/buffer_core_test.cpp
+++ /dev/null
@@ -1,2875 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#if _WIN32
-#define _USE_MATH_DEFINES
-#endif
-#include <chrono>
-#include <cmath>
-#include <functional>
-#include <limits>
-#include <string>
-#include <vector>
-
-#include <gtest/gtest.h>
-
-#include <builtin_interfaces/msg/time.hpp>
-#include <geometry_msgs/msg/quaternion.hpp>
-#include <geometry_msgs/msg/transform.hpp>
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rclcpp/rclcpp.hpp>
-#include <tf2/buffer_core.h>
-#include <tf2/exceptions.h>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2/time.h>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-#include <tf2_ros/buffer_interface.h>
-
-#include "permuter.hpp"
-
-void seed_rand()
-{
-  //Seed random number generator with current time.
-  srand((unsigned) time(0));
-}
-
-void generate_rand_vectors(double scale, uint64_t runs, std::vector<double>& xvalues, std::vector<double>& yvalues, std::vector<double>&zvalues)
-{
-  (void)scale;
-  seed_rand();
-  for ( uint64_t i = 0; i < runs ; i++ )
-  {
-    xvalues[i] = 1.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-    yvalues[i] = 1.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-    zvalues[i] = 1.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-  }
-}
-
-
-void setIdentity(geometry_msgs::msg::Transform& trans)
-{
-  trans.translation.x = 0;
-  trans.translation.y = 0;
-  trans.translation.z = 0;
-  trans.rotation.x = 0;
-  trans.rotation.y = 0;
-  trans.rotation.z = 0;
-  trans.rotation.w = 1;
-}
-
-
-void push_back_i(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-  /*
-     "a"
-     v   (1,0)
-     "b"
-     v   (1,0)
-     "c"
-  */
-
-  children.push_back("b");
-  parents.push_back("a");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-  children.push_back("c");
-  parents.push_back("b");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-}
-
-
-void push_back_y(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-    /*
-      "a"
-      v  (1,0)
-      "b" ------(0,1)-----> "d"
-      v  (1,0)              v  (0,1)
-      "c"                   "e"
-    */
-    // a>b
-    children.push_back("b");
-    parents.push_back("a");
-    dx.push_back(1.0);
-    dy.push_back(0.0);
-     // b>c
-    children.push_back("c");
-    parents.push_back("b");
-    dx.push_back(1.0);
-    dy.push_back(0.0);
-     // b>d
-    children.push_back("d");
-    parents.push_back("b");
-    dx.push_back(0.0);
-    dy.push_back(1.0);
-     // d>e
-    children.push_back("e");
-    parents.push_back("d");
-    dx.push_back(0.0);
-    dy.push_back(1.0);
-}
-
-void push_back_v(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-  /*
-    "a" ------(0,1)-----> "f"
-    v  (1,0)              v  (0,1)
-    "b"                   "g"
-    v  (1,0)
-    "c"
-  */
-  // a>b
-  children.push_back("b");
-  parents.push_back("a");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-  // b>c
-  children.push_back("c");
-  parents.push_back("b");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-  // a>f
-  children.push_back("f");
-  parents.push_back("a");
-  dx.push_back(0.0);
-  dy.push_back(1.0);
-  // f>g
-  children.push_back("g");
-  parents.push_back("f");
-  dx.push_back(0.0);
-  dy.push_back(1.0);
-
-}
-
-void push_back_1(std::vector<std::string>& children, std::vector<std::string>& parents,
-                 std::vector<double>& dx, std::vector<double>& dy)
-{
-  children.push_back("2");
-  parents.push_back("1");
-  dx.push_back(1.0);
-  dy.push_back(0.0);
-}
-
-void setupTree(tf2::BufferCore& mBC, const std::string& mode, const builtin_interfaces::msg::Time & time, const tf2::Duration& interpolation_space = tf2::durationFromSec(0.0))
-{
-
-  mBC.clear();
-
-  std::vector<std::string> children;
-  std::vector<std::string> parents;
-  std::vector<double> dx, dy;
-
-  if (mode == "i")
-  {
-    push_back_i(children, parents, dx, dy);
-  }
-  else if (mode == "y")
-  {
-    push_back_y(children, parents, dx, dy);
-  }
-
-  else if (mode == "v")
-  {
-    push_back_v(children, parents, dx, dy);
-  }
-
-  else if (mode == "ring_45")
-  {
-    /* Form a ring of transforms at every 45 degrees on the unit circle.  */
-
-    std::vector<std::string> frames;
-
-    frames.push_back("a");
-    frames.push_back("b");
-    frames.push_back("c");
-    frames.push_back("d");
-    frames.push_back("e");
-    frames.push_back("f");
-    frames.push_back("g");
-    frames.push_back("h");
-    frames.push_back("i");
-
-    for (uint8_t iteration = 0; iteration < 2; ++iteration)
-    {
-      double direction = 1;
-      std::string frame_prefix;
-      if (iteration == 0)
-      {
-        frame_prefix = "inverse_";
-        direction = -1;
-      }
-      else
-      {
-        frame_prefix ="";
-      }
-      for (uint64_t i = 1; i <  frames.size(); i++)
-      {
-        geometry_msgs::msg::TransformStamped ts;
-        setIdentity(ts.transform);
-        ts.transform.translation.x = direction * ( sqrt(2)/2 - 1);
-        ts.transform.translation.y = direction * sqrt(2)/2;
-        ts.transform.rotation.x = 0;
-        ts.transform.rotation.y = 0;
-        ts.transform.rotation.z = sin(direction * M_PI/8);
-        ts.transform.rotation.w = cos(direction * M_PI/8);
-
-        double time_seconds = time.sec + time.nanosec / 1e9;
-        double time_interpolation_space = tf2::durationToSec(interpolation_space) * .5;
-
-        if (time_seconds > time_interpolation_space )
-        {
-          double time_stamp = time_seconds - time_interpolation_space;
-          ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-        }
-        else
-        {
-          ts.header.stamp = builtin_interfaces::msg::Time();
-        }
-
-        ts.header.frame_id = frame_prefix + frames[i-1];
-        if (i > 1)
-          ts.child_frame_id = frame_prefix + frames[i];
-        else
-          ts.child_frame_id = frames[i]; // connect first frame
-        EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-        if (interpolation_space > tf2::Duration(0))
-        {
-          // TODO (ahcorde): review this
-          double time_stamp = time_seconds;// + time_interpolation_space;
-          ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-          EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-        }
-      }
-    }
-    return; // nonstandard setup return before standard executinog
-  }
-  else if (mode == "1")
-  {
-    push_back_1(children, parents, dx, dy);
-  }
-  else if (mode =="1_v")
-  {
-    push_back_1(children, parents, dx, dy);
-    push_back_v(children, parents, dx, dy);
-  }
-  else
-    EXPECT_FALSE("Undefined mode for tree setup.  Test harness improperly setup.");
-
-
-  /// Standard
-  for (uint64_t i = 0; i <  children.size(); i++)
-  {
-    geometry_msgs::msg::TransformStamped ts;
-    setIdentity(ts.transform);
-    ts.transform.translation.x = dx[i];
-    ts.transform.translation.y = dy[i];
-    double time_seconds = time.sec +  time.nanosec / 1e9;
-    double time_interpolation_space = tf2::durationToSec(interpolation_space) * .5;
-    if (time_seconds > time_interpolation_space ){
-      double time_stamp = time_seconds - time_interpolation_space;
-      ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-    }
-    else
-    {
-      ts.header.stamp = builtin_interfaces::msg::Time();
-    }
-
-    ts.header.frame_id = parents[i];
-    ts.child_frame_id = children[i];
-    EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-    if (interpolation_space > tf2::Duration(0))
-    {
-      // TODO (ahcorde): review this
-      double time_stamp = time_seconds;// + time_interpolation_space;
-      ts.header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp*1e9));
-      EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-    }
-  }
-}
-
-
-TEST(BufferCore_setTransform, NoInsertOnSelfTransform)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "same_frame";
-  tranStamped.child_frame_id = "same_frame";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-}
-
-TEST(BufferCore_setTransform, NoInsertWithNan)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "same_frame";
-  tranStamped.child_frame_id = "other_frame";
-  EXPECT_TRUE(mBC.setTransform(tranStamped, "authority"));
-  tranStamped.transform.translation.x = std::numeric_limits<float>::quiet_NaN();
-  EXPECT_TRUE(std::isnan(tranStamped.transform.translation.x));
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-}
-
-TEST(BufferCore_setTransform, NoInsertWithNoFrameID)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "same_frame";
-  tranStamped.child_frame_id = "";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-  tranStamped.child_frame_id = "/";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-
-}
-
-TEST(BufferCore_setTransform, NoInsertWithNoParentID)
-{
-  tf2::BufferCore mBC;
-  geometry_msgs::msg::TransformStamped tranStamped;
-  setIdentity(tranStamped.transform);
-  tranStamped.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10.0));
-  tranStamped.header.frame_id = "";
-  tranStamped.child_frame_id = "some_frame";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-
-  tranStamped.header.frame_id = "/";
-  EXPECT_FALSE(mBC.setTransform(tranStamped, "authority"));
-}
-
-// /*
-// TEST(tf, ListOneInverse)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped (btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "child");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("my_parent",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, ListTwoInverse)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "child", "grandchild");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "grandchild");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("my_parent",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), 2*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), 2*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), 2*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-//
-// TEST(tf, ListOneForward)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( uint64_t i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "my_parent");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("child",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), -xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), -yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), -zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, ListTwoForward)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parent", "child");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "child", "grandchild");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "my_parent");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("grandchild",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), -2*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), -2*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), -2*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, TransformThrougRoot)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(1000 + i*100),  "my_parent", "childA");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(1000 + i*100),  "my_parent", "childB");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<Pose> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000 + i*100), "childA");
-//
-//     try{
-//     Stamped<Pose> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("childB",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), 0*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), 0*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), 0*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       std::cout << "TransformExcepion got through!!!!! " << ex.what() << std::endl;
-//       bool exception_improperly_thrown = true;
-//       EXPECT_FALSE(exception_improperly_thrown);
-//     }
-//   }
-//
-// }
-//
-// TEST(tf, TransformThroughNO_PARENT)
-// {
-//   unsigned int runs = 4;
-//   double epsilon = 1e-6;
-//   seed_rand();
-//
-//   tf::Transformer mTR(true);
-//   std::vector<double> xvalues(runs), yvalues(runs), zvalues(runs);
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//   {
-//     xvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     yvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//     zvalues[i] = 10.0 * ((double) rand() - (double)RAND_MAX /2.0) /(double)RAND_MAX;
-//
-//     StampedTransform tranStamped(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parentA", "childA");
-//     mTR.setTransform(tranStamped);
-//     StampedTransform tranStamped2(btTransform(tf2::Quaternion(0,0,0,1), btVector3(xvalues[i],yvalues[i],zvalues[i])), builtin_interfaces::msg::Time().fromNSec(10 + i),  "my_parentB", "childB");
-//     mTR.setTransform(tranStamped2);
-//   }
-//
-//   //  std::cout << mTR.allFramesAsString() << std::endl;
-//   //  std::cout << mTR.chainAsString("child", 0, "my_parent2", 0, "my_parent2") << std::endl;
-//
-//   for ( unsigned int i = 0; i < runs ; i++ )
-//
-//   {
-//     Stamped<btTransform> inpose (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10 + i), "childA");
-//     bool exception_thrown = false;
-//
-//     try{
-//     Stamped<btTransform> outpose;
-//     outpose.setIdentity(); //to make sure things are getting mutated
-//     mTR.transformPose("childB",inpose, outpose);
-//     EXPECT_NEAR(outpose.getOrigin().x(), 0*xvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().y(), 0*yvalues[i], epsilon);
-//     EXPECT_NEAR(outpose.getOrigin().z(), 0*zvalues[i], epsilon);
-//     }
-//     catch (tf::TransformException & ex)
-//     {
-//       exception_thrown = true;
-//     }
-//     EXPECT_TRUE(exception_thrown);
-//   }
-//
-// }
-//
-// */
-
-TEST(BufferCore_lookupTransform, i_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while(permuter.step())
-  {
-    tf2::BufferCore mBC;
-    setupTree(mBC, "i", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_EQ(outpose.header.stamp, eval_time);
-    EXPECT_EQ(outpose.header.frame_id, source_frame);
-    EXPECT_EQ(outpose.child_frame_id, target_frame);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-    //Zero distance
-    if (source_frame == target_frame)
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    }
-    else if ((source_frame == "a" && target_frame =="b") ||
-             (source_frame == "b" && target_frame =="c"))
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    }
-    else if ((source_frame == "b" && target_frame =="a") ||
-             (source_frame == "c" && target_frame =="b"))
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    }
-    else if (source_frame == "a" && target_frame =="c")
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    }
-    else if (source_frame == "c" && target_frame =="a")
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    }
-    else
-    {
-      EXPECT_FALSE("i configuration: Shouldn't get here");
-      printf("source_frame %s target_frame %s time %f\n", source_frame.c_str(), target_frame.c_str(), eval_time.sec + eval_time.nanosec /1e9 );
-    }
-  }
-}
-
-/* Check 1 result return false if test parameters unmet */
-bool check_1_result(const geometry_msgs::msg::TransformStamped& outpose, const std::string& source_frame, const std::string& target_frame, const builtin_interfaces::msg::Time& eval_time, double epsilon)
-{
-  EXPECT_EQ(outpose.header.stamp, eval_time);
-  EXPECT_EQ(outpose.header.frame_id, source_frame);
-  EXPECT_EQ(outpose.child_frame_id, target_frame);
-  EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-  //Zero distance
-  if (source_frame == target_frame)
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-  }
-  else if (source_frame == "1" && target_frame =="2")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-  }
-  else if (source_frame == "2" && target_frame =="1")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-  }
-  else
-  {
-    return false;
-  }
-  return true;
-}
-
-/* Check v result return false if test parameters unmet */
-bool check_v_result(const geometry_msgs::msg::TransformStamped& outpose, const std::string& source_frame, const std::string& target_frame, const builtin_interfaces::msg::Time& eval_time, double epsilon)
-{
-  EXPECT_EQ(outpose.header.stamp, eval_time);
-  EXPECT_EQ(outpose.header.frame_id, source_frame);
-  EXPECT_EQ(outpose.child_frame_id, target_frame);
-  EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-  //Zero distance
-  if (source_frame == target_frame)
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-  }
-  else if ((source_frame == "a" && target_frame =="b") ||
-           (source_frame == "b" && target_frame =="c"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "b" && target_frame =="a") ||
-           (source_frame == "c" && target_frame =="b"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "a" && target_frame =="f") ||
-           (source_frame == "f" && target_frame =="g"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if ((source_frame == "f" && target_frame =="a") ||
-           (source_frame == "g" && target_frame =="f"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="g")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "g" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "b" && target_frame =="f")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "f" && target_frame =="b")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="f")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "f" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "b" && target_frame =="g")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "g" && target_frame =="b")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="g")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "g" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else
-  {
-    return false;
-  }
-  return true;
-}
-
-/* Check v result return false if test parameters unmet */
-bool check_y_result(const geometry_msgs::msg::TransformStamped& outpose, const std::string& source_frame, const std::string& target_frame, const builtin_interfaces::msg::Time& eval_time, double epsilon)
-{
-  EXPECT_EQ(outpose.header.stamp, eval_time);
-  EXPECT_EQ(outpose.header.frame_id, source_frame);
-  EXPECT_EQ(outpose.child_frame_id, target_frame);
-  EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-  EXPECT_NEAR(outpose.transform.rotation.w, 1, epsilon);
-
-  //Zero distance
-  if (source_frame == target_frame)
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-  }
-  else if ((source_frame == "a" && target_frame =="b") ||
-           (source_frame == "b" && target_frame =="c"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "b" && target_frame =="a") ||
-           (source_frame == "c" && target_frame =="b"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if ((source_frame == "b" && target_frame =="d") ||
-           (source_frame == "d" && target_frame =="e"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if ((source_frame == "d" && target_frame =="b") ||
-           (source_frame == "e" && target_frame =="d"))
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "b" && target_frame =="e")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "e" && target_frame =="b")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="d")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "d" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="d")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 1, epsilon);
-  }
-  else if (source_frame == "d" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -1, epsilon);
-  }
-  else if (source_frame == "a" && target_frame =="e")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "e" && target_frame =="a")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else if (source_frame == "c" && target_frame =="e")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, 2, epsilon);
-  }
-  else if (source_frame == "e" && target_frame =="c")
-  {
-    EXPECT_NEAR(outpose.transform.translation.x, 1, epsilon);
-    EXPECT_NEAR(outpose.transform.translation.y, -2, epsilon);
-  }
-  else
-  {
-    return false;
-  }
-  return true;
-}
-
-
-TEST(BufferCore_lookupTransform, one_link_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  // permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("1");
-  frames.push_back("2");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "1", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_TRUE(check_1_result(outpose, source_frame, target_frame, eval_time, epsilon));
-  }
-}
-
-
-TEST(BufferCore_lookupTransform, v_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  //  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("f");
-  frames.push_back("g");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "v", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_TRUE(check_v_result(outpose, source_frame, target_frame, eval_time, epsilon));
-  }
-}
-
-
-TEST(BufferCore_lookupTransform, y_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  //  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("d");
-  frames.push_back("e");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "y", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_TRUE(check_y_result(outpose, source_frame, target_frame, eval_time, epsilon));
-  }
-}
-
-TEST(BufferCore_lookupTransform, multi_configuration)
-{
-  double epsilon = 1e-6;
-
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  //  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("1");
-  frames.push_back("2");
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("f");
-  frames.push_back("g");
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "1_v", eval_time, interpolation_space);
-
-    if (mBC.canTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time)))
-    {
-      geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-      if ((source_frame == "1" || source_frame =="2") && (target_frame =="1" || target_frame == "2"))
-        EXPECT_TRUE(check_1_result(outpose, source_frame, target_frame, eval_time, epsilon));
-      else if ((source_frame == "a" || source_frame == "b" || source_frame == "c" || source_frame == "f" || source_frame == "g") &&
-               (target_frame == "a" || target_frame == "b" || target_frame == "c" || target_frame == "f" || target_frame == "g"))
-        EXPECT_TRUE(check_v_result(outpose, source_frame, target_frame, eval_time, epsilon));
-      else
-        EXPECT_FALSE("Frames unhandled");
-    }
-    else
-      EXPECT_TRUE(((source_frame == "a" || source_frame =="b" || source_frame == "c" || source_frame == "f" || source_frame == "g") &&
-                   (target_frame == "1" || target_frame == "2") )
-                  ||
-                  ((target_frame == "a" || target_frame =="b" || target_frame == "c" || target_frame == "f" || target_frame == "g") &&
-                   (source_frame == "1" || source_frame == "2"))
-                  );
-
-  }
-}
-
-#define CHECK_QUATERNION_NEAR(_q1, _x, _y, _z, _w, _epsilon)                 \
-	   {                        											 \
-	   tf2::Quaternion q1(_q1.x, _q1.y, _q1.z, _q1.w);                          \
-       tf2::Quaternion q2(_x, _y, _z, _w);                                      \
-       double angle = q1.angle(q2);                                          \
-	   EXPECT_TRUE(fabs(angle) < _epsilon || fabs(angle - M_PI) < _epsilon); \
-	   }
-
-#define CHECK_TRANSFORMS_NEAR(_out, _expected, _eps)       																							            	            \
-	EXPECT_NEAR(_out.transform.translation.x, _expected.getOrigin().x(), epsilon); 											              			            				\
-	EXPECT_NEAR(_out.transform.translation.y, _expected.getOrigin().y(), epsilon); 															                        			\
-	EXPECT_NEAR(_out.transform.translation.z, _expected.getOrigin().z(), epsilon); 													            	             				\
-	CHECK_QUATERNION_NEAR(_out.transform.rotation, _expected.getRotation().x(), _expected.getRotation().y(), _expected.getRotation().z(), _expected.getRotation().w(), _eps);
-//
-// // TODO(ahcorde): btTransform
-// // Simple test with compound transform
-// TEST(BufferCore_lookupTransform, compound_xfm_configuration)
-// {
-// 	/*
-// 	 * Frames
-// 	 *
-// 	 * root->a
-// 	 *
-// 	 * root->b->c->d
-// 	 *
-// 	 */
-//
-// 	double epsilon = 2e-5; // Larger epsilon for interpolation values
-//
-//     tf2::BufferCore mBC;
-//
-//     geometry_msgs::msg::TransformStamped tsa;
-//     tsa.header.frame_id = "root";
-//     tsa.child_frame_id  = "a";
-//     tsa.transform.translation.x = 1.0;
-//     tsa.transform.translation.y = 1.0;
-//     tsa.transform.translation.z = 1.0;
-//     tf2::Quaternion q1;
-//     q1.setEuler(0.25, .5, .75);
-//     tsa.transform.rotation.x = q1.x();
-//     tsa.transform.rotation.y = q1.y();
-//     tsa.transform.rotation.z = q1.z();
-//     tsa.transform.rotation.w = q1.w();
-//     EXPECT_TRUE(mBC.setTransform(tsa, "authority"));
-//
-//     geometry_msgs::msg::TransformStamped tsb;
-//     tsb.header.frame_id = "root";
-//     tsb.child_frame_id  = "b";
-//     tsb.transform.translation.x = -1.0;
-//     tsb.transform.translation.y =  0.0;
-//     tsb.transform.translation.z = -1.0;
-//     tf2::Quaternion q2;
-//     q2.setEuler(1.0, 0.25, 0.5);
-//     tsb.transform.rotation.x = q2.x();
-//     tsb.transform.rotation.y = q2.y();
-//     tsb.transform.rotation.z = q2.z();
-//     tsb.transform.rotation.w = q2.w();
-//     EXPECT_TRUE(mBC.setTransform(tsb, "authority"));
-//
-//     geometry_msgs::msg::TransformStamped tsc;
-//     tsc.header.frame_id = "b";
-//     tsc.child_frame_id  = "c";
-//     tsc.transform.translation.x =  0.0;
-//     tsc.transform.translation.y =  2.0;
-//     tsc.transform.translation.z =  0.5;
-//     tf2::Quaternion q3;
-//     q3.setEuler(0.25, .75, 1.25);
-//     tsc.transform.rotation.x = q3.x();
-//     tsc.transform.rotation.y = q3.y();
-//     tsc.transform.rotation.z = q3.z();
-//     tsc.transform.rotation.w = q3.w();
-//     EXPECT_TRUE(mBC.setTransform(tsc, "authority"));
-//
-//     geometry_msgs::msg::TransformStamped tsd;
-//     tsd.header.frame_id = "c";
-//     tsd.child_frame_id  = "d";
-//     tsd.transform.translation.x =  0.5;
-//     tsd.transform.translation.y =  -1;
-//     tsd.transform.translation.z =  1.5;
-//     tf2::Quaternion q4;
-//     q4.setEuler(-0.5, 1.0, -.75);
-//     tsd.transform.rotation.x = q4.x();
-//     tsd.transform.rotation.y = q4.y();
-//     tsd.transform.rotation.z = q4.z();
-//     tsd.transform.rotation.w = q4.w();
-//     EXPECT_TRUE(mBC.setTransform(tsd, "authority"));
-//
-//     btTransform ta, tb, tc, td, expected_ab, expected_bc, expected_cb, expected_ac, expected_ba, expected_ca, expected_ad, expected_da, expected_bd, expected_db, expected_rootd, expected_rootc;
-//     ta.setOrigin(btVector3(1.0,  1.0,  1.0));
-//     ta.setRotation(q1);
-//     tb.setOrigin(btVector3(-1.0, 0.0, -1.0));
-//     tb.setRotation(q2);
-//     tc.setOrigin(btVector3(0.0, 2.0, 0.5));
-//     tc.setRotation(q3);
-//     td.setOrigin(btVector3(0.5, -1, 1.5));
-//     td.setRotation(q4);
-//
-//
-//     expected_ab = ta.inverse() * tb;
-//     expected_ac = ta.inverse() * tb * tc;
-//     expected_ad = ta.inverse() * tb * tc * td;
-//     expected_cb = tc.inverse();
-//     expected_bc = tc;
-//     expected_bd = tc * td;
-//     expected_db = expected_bd.inverse();
-//     expected_ba = tb.inverse() * ta;
-//     expected_ca = tc.inverse() * tb.inverse() * ta;
-//     expected_da = td.inverse() * tc.inverse() * tb.inverse() * ta;
-//     expected_rootd = tb * tc * td;
-//     expected_rootc = tb * tc;
-//
-//     // root -> b -> c
-//     geometry_msgs::msg::TransformStamped out_rootc = mBC.lookupTransform("root", "c", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_rootc, expected_rootc, epsilon);
-//
-//     // root -> b -> c -> d
-//     geometry_msgs::msg::TransformStamped out_rootd = mBC.lookupTransform("root", "d", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_rootd, expected_rootd, epsilon);
-//
-//     // a <- root -> b
-//     geometry_msgs::msg::TransformStamped out_ab = mBC.lookupTransform("a", "b", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ab, expected_ab, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_ba = mBC.lookupTransform("b", "a", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ba, expected_ba, epsilon);
-//
-//     // a <- root -> b -> c
-//     geometry_msgs::msg::TransformStamped out_ac = mBC.lookupTransform("a", "c", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ac, expected_ac, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_ca = mBC.lookupTransform("c", "a", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ca, expected_ca, epsilon);
-//
-//     // a <- root -> b -> c -> d
-//     geometry_msgs::msg::TransformStamped out_ad = mBC.lookupTransform("a", "d", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_ad, expected_ad, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_da = mBC.lookupTransform("d", "a", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_da, expected_da, epsilon);
-//
-//     // b -> c
-//     geometry_msgs::msg::TransformStamped out_cb = mBC.lookupTransform("c", "b", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_cb, expected_cb, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_bc = mBC.lookupTransform("b", "c", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_bc, expected_bc, epsilon);
-//
-//     // b -> c -> d
-//     geometry_msgs::msg::TransformStamped out_bd = mBC.lookupTransform("b", "d", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_bd, expected_bd, epsilon);
-//
-//     geometry_msgs::msg::TransformStamped out_db = mBC.lookupTransform("d", "b", builtin_interfaces::msg::Time());
-//     CHECK_TRANSFORMS_NEAR(out_db, expected_db, epsilon);
-// }
-
-// TODO(ahcorde)
-// Time varying transforms, testing interpolation
-// TEST(BufferCore_lookupTransform, helix_configuration)
-// {
-// 	double epsilon = 2e-5; // Larger epsilon for interpolation values
-//
-//     tf2::BufferCore mBC;
-//
-//     builtin_interfaces::msg::Time t0;
-//     t0.sec = 10;
-//     t0.nanosec = 0;
-//     tf2::Duration step      = tf2::durationFromSec(0.05);
-//     tf2::Duration half_step = tf2::durationFromSec(0.025);
-//     builtin_interfaces::msg::Time t1;
-//     double t1_seconds = tf2::durationToSec(tf2::durationFromSec(5.0)) + t0.sec + t0.nanosec;
-//     t0.sec = (int)t1_seconds;
-//     t0.nanosec = (t1_seconds - (int)t1_seconds)/1e9;
-//
-//     /*
-//      * a->b->c
-//      *
-//      * b.z = vel * (t - t0)
-//      * c.x = cos(theta * (t - t0))
-//      * c.y = sin(theta * (t - t0))
-//      *
-//      * a->d
-//      *
-//      * d.z = 2 * cos(theta * (t - t0))
-//      * a->d transforms are at half-step between a->b->c transforms
-//      */
-//
-//     double theta = 0.25;
-//     double vel   = 1.0;
-//
-//     for (builtin_interfaces::msg::Time t = t0; t <= t1; t += step)
-//     {
-//     	builtin_interfaces::msg::Time t2 = t + half_step;
-//     	double dt  = (t - t0).toSec();
-//     	double dt2 = (t2 - t0).toSec();
-//
-//         geometry_msgs::msg::TransformStamped ts;
-//         ts.header.frame_id = "a";
-//         ts.header.stamp    = t;
-//         ts.child_frame_id  = "b";
-//         ts.transform.translation.z = vel * dt;
-//         ts.transform.rotation.w = 1.0;
-//         EXPECT_TRUE(mBC.setTransform(ts, "authority"));
-//
-//         geometry_msgs::msg::TransformStamped ts2;
-//         ts2.header.frame_id = "b";
-//         ts2.header.stamp    = t;
-//         ts2.child_frame_id  = "c";
-//         ts2.transform.translation.x = cos(theta * dt);
-//         ts2.transform.translation.y = sin(theta * dt);
-//         tf2::Quaternion q;
-//         q.setEuler(0,0,theta*dt);
-//         ts2.transform.rotation.z = q.z();
-//         ts2.transform.rotation.w = q.w();
-//         EXPECT_TRUE(mBC.setTransform(ts2, "authority"));
-//
-//         geometry_msgs::msg::TransformStamped ts3;
-//         ts3.header.frame_id = "a";
-//         ts3.header.stamp    = t2;
-//         ts3.child_frame_id  = "d";
-//         ts3.transform.translation.z = cos(theta * dt2);
-//         ts3.transform.rotation.w = 1.0;
-//         EXPECT_TRUE(mBC.setTransform(ts3, "authority"));
-//     }
-//
-//
-//     for (builtin_interfaces::msg::Time t = t0 + half_step; t < t1; t += step)
-//     {
-//     	builtin_interfaces::msg::Time t2 = t + half_step;
-//     	double dt  = (t - t0).toSec();
-//     	double dt2 = (t2 - t0).toSec();
-//
-//         geometry_msgs::msg::TransformStamped out_ab = mBC.lookupTransform("a", "b", t);
-//         EXPECT_NEAR(out_ab.transform.translation.z, vel * dt, epsilon);
-//
-//         geometry_msgs::msg::TransformStamped out_ac = mBC.lookupTransform("a", "c", t);
-//         EXPECT_NEAR(out_ac.transform.translation.x, cos(theta * dt), epsilon);
-//         EXPECT_NEAR(out_ac.transform.translation.y, sin(theta * dt), epsilon);
-//         EXPECT_NEAR(out_ac.transform.translation.z, vel * dt, 		 epsilon);
-//         tf2::Quaternion q;
-//         q.setEuler(0,0,theta*dt);
-//         CHECK_QUATERNION_NEAR(out_ac.transform.rotation, 0, 0, q.z(), q.w(), epsilon);
-//
-//         geometry_msgs::msg::TransformStamped out_ad = mBC.lookupTransform("a", "d", t);
-//         EXPECT_NEAR(out_ad.transform.translation.z, cos(theta * dt), epsilon);
-//
-//         geometry_msgs::msg::TransformStamped out_cd = mBC.lookupTransform("c", "d", t2);
-//         EXPECT_NEAR(out_cd.transform.translation.x, -1,           			      epsilon);
-//         EXPECT_NEAR(out_cd.transform.translation.y,  0,  			              epsilon);
-//         EXPECT_NEAR(out_cd.transform.translation.z, cos(theta * dt2) - vel * dt2, epsilon);
-//         tf2::Quaternion mq;
-//         mq.setEuler(0,0,-theta*dt2);
-//         CHECK_QUATERNION_NEAR(out_cd.transform.rotation, 0, 0, mq.z(), mq.w(), epsilon);
-//     }
-//
-//     // Advanced API
-//     for (builtin_interfaces::msg::Time t = t0 + half_step; t < t1; t += (step + step))
-//     {
-//     	builtin_interfaces::msg::Time t2 = t + step;
-//     	double dt  = (t - t0).toSec();
-//     	double dt2 = (t2 - t0).toSec();
-//
-//         geometry_msgs::msg::TransformStamped out_cd2 = mBC.lookupTransform("c", t, "d", t2, "a");
-//         EXPECT_NEAR(out_cd2.transform.translation.x, -1,           			      epsilon);
-//         EXPECT_NEAR(out_cd2.transform.translation.y,  0,  			              epsilon);
-//         EXPECT_NEAR(out_cd2.transform.translation.z, cos(theta * dt2) - vel * dt, epsilon);
-//         tf2::Quaternion mq2;
-//         mq2.setEuler(0,0,-theta*dt);
-//         CHECK_QUATERNION_NEAR(out_cd2.transform.rotation, 0, 0, mq2.z(), mq2.w(), epsilon);
-//     }
-// }
-//
-
-TEST(BufferCore_lookupTransform, ring_45_configuration)
-{
-  double epsilon = 1e-6;
-  rostest::Permuter permuter;
-
-  std::vector<builtin_interfaces::msg::Time> times;
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(10.0)));
-  times.push_back(tf2_ros::toMsg(tf2::timeFromSec(0.0)));
-  builtin_interfaces::msg::Time eval_time;
-  permuter.addOptionSet(times, &eval_time);
-
-  std::vector<tf2::Duration> durations;
-  durations.push_back(tf2::durationFromSec(1.0));
-  durations.push_back(tf2::durationFromSec(0.001));
-  durations.push_back(tf2::durationFromSec(0.1));
-  tf2::Duration interpolation_space(0);
-  permuter.addOptionSet(durations, &interpolation_space);
-
-  std::vector<std::string> frames;
-  frames.push_back("a");
-  frames.push_back("b");
-  frames.push_back("c");
-  frames.push_back("d");
-  frames.push_back("e");
-  frames.push_back("f");
-  frames.push_back("g");
-  frames.push_back("h");
-  frames.push_back("i");
-  /*  frames.push_back("inverse_b");
-  frames.push_back("inverse_c");
-  frames.push_back("inverse_d");
-  frames.push_back("inverse_e");
-  frames.push_back("inverse_f");
-  frames.push_back("inverse_g");
-  frames.push_back("inverse_h");
-  frames.push_back("inverse_i");*/
-  std::string source_frame;
-  permuter.addOptionSet(frames, &source_frame);
-
-  std::string target_frame;
-  permuter.addOptionSet(frames, &target_frame);
-
-  while  (permuter.step())
-  {
-
-    tf2::BufferCore mBC;
-    setupTree(mBC, "ring_45", eval_time, interpolation_space);
-
-    geometry_msgs::msg::TransformStamped outpose = mBC.lookupTransform(source_frame, target_frame, tf2_ros::fromMsg(eval_time));
-
-    EXPECT_EQ(outpose.header.stamp, eval_time);
-    EXPECT_EQ(outpose.header.frame_id, source_frame);
-    EXPECT_EQ(outpose.child_frame_id, target_frame);
-
-    //Zero distance or all the way
-    if (source_frame == target_frame               ||
-        (source_frame == "a" && target_frame == "i") ||
-        (source_frame == "i" && target_frame == "a") ||
-        (source_frame == "a" && target_frame == "inverse_i") ||
-        (source_frame == "inverse_i" && target_frame == "a") )
-    {
-      //printf ("here %s %s\n", source_frame.c_str(), target_frame.c_str());
-      EXPECT_NEAR(outpose.transform.translation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, 0, epsilon);
-      EXPECT_NEAR(fabs(outpose.transform.rotation.w), 1, epsilon);
-    }
-    // Chaining 1
-    else if ((source_frame == "a" && target_frame =="b") ||
-             (source_frame == "b" && target_frame =="c") ||
-             (source_frame == "c" && target_frame =="d") ||
-             (source_frame == "d" && target_frame =="e") ||
-             (source_frame == "e" && target_frame =="f") ||
-             (source_frame == "f" && target_frame =="g") ||
-             (source_frame == "g" && target_frame =="h") ||
-             (source_frame == "h" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI/8), epsilon);
-    }
-    // Inverse Chaining 1
-    else if ((source_frame == "b" && target_frame =="a") ||
-             (source_frame == "c" && target_frame =="b") ||
-             (source_frame == "d" && target_frame =="c") ||
-             (source_frame == "e" && target_frame =="d") ||
-             (source_frame == "f" && target_frame =="e") ||
-             (source_frame == "g" && target_frame =="f") ||
-             (source_frame == "h" && target_frame =="g") ||
-             (source_frame == "i" && target_frame =="h")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(-M_PI/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(-M_PI/8), epsilon);
-    }
-    // Chaining 2
-    else if ((source_frame == "a" && target_frame =="c") ||
-             (source_frame == "b" && target_frame =="d") ||
-             (source_frame == "c" && target_frame =="e") ||
-             (source_frame == "d" && target_frame =="f") ||
-             (source_frame == "e" && target_frame =="g") ||
-             (source_frame == "f" && target_frame =="h") ||
-             (source_frame == "g" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI/4), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI/4), epsilon);
-    }
-    // Inverse Chaining 2
-    else if ((source_frame == "c" && target_frame =="a") ||
-             (source_frame == "d" && target_frame =="b") ||
-             (source_frame == "e" && target_frame =="c") ||
-             (source_frame == "f" && target_frame =="d") ||
-             (source_frame == "g" && target_frame =="e") ||
-             (source_frame == "h" && target_frame =="f") ||
-             (source_frame == "i" && target_frame =="g")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(-M_PI/4), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(-M_PI/4), epsilon);
-    }
-    // Chaining 3
-    else if ((source_frame == "a" && target_frame =="d") ||
-             (source_frame == "b" && target_frame =="e") ||
-             (source_frame == "c" && target_frame =="f") ||
-             (source_frame == "d" && target_frame =="g") ||
-             (source_frame == "e" && target_frame =="h") ||
-             (source_frame == "f" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2)/2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI*3/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI*3/8), epsilon);
-    }
-    // Inverse Chaining 3
-    else if ((target_frame == "a" && source_frame =="d") ||
-             (target_frame == "b" && source_frame =="e") ||
-             (target_frame == "c" && source_frame =="f") ||
-             (target_frame == "d" && source_frame =="g") ||
-             (target_frame == "e" && source_frame =="h") ||
-             (target_frame == "f" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2)/2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, - sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI*3/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*3/8), epsilon);
-    }
-    // Chaining 4
-    else if ((source_frame == "a" && target_frame =="e") ||
-             (source_frame == "b" && target_frame =="f") ||
-             (source_frame == "c" && target_frame =="g") ||
-             (source_frame == "d" && target_frame =="h") ||
-             (source_frame == "e" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 0 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI/2), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI/2), epsilon);
-    }
-    // Inverse Chaining 4
-    else if ((target_frame == "a" && source_frame =="e") ||
-             (target_frame == "b" && source_frame =="f") ||
-             (target_frame == "c" && source_frame =="g") ||
-             (target_frame == "d" && source_frame =="h") ||
-             (target_frame == "e" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 0 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI/2), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(-M_PI/2), epsilon);
-    }
-    // Chaining 5
-    else if ((source_frame == "a" && target_frame =="f") ||
-             (source_frame == "b" && target_frame =="g") ||
-             (source_frame == "c" && target_frame =="h") ||
-             (source_frame == "d" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2) /2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, - sqrt(2) /2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI*5/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, cos(M_PI*5/8), epsilon);
-    }
-    // Inverse Chaining 5
-    else if ((target_frame == "a" && source_frame =="f") ||
-             (target_frame == "b" && source_frame =="g") ||
-             (target_frame == "c" && source_frame =="h") ||
-             (target_frame == "d" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1 - sqrt(2)/2, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI*5/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*5/8), epsilon);
-    }
-    // Chaining 6
-    else if ((source_frame == "a" && target_frame =="g") ||
-             (source_frame == "b" && target_frame =="h") ||
-             (source_frame == "c" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(M_PI*6/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(M_PI*6/8), epsilon);
-    }
-    // Inverse Chaining 6
-    else if ((target_frame == "a" && source_frame =="g") ||
-             (target_frame == "b" && source_frame =="h") ||
-             (target_frame == "c" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, -1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, 1 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, -sin(-M_PI*6/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*6/8), epsilon);
-    }
-    // Chaining 7
-    else if ((source_frame == "a" && target_frame =="h") ||
-             (source_frame == "b" && target_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, -sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(-M_PI*7/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(-M_PI*7/8), epsilon);
-    }
-    // Inverse Chaining 7
-    else if ((target_frame == "a" && source_frame =="h") ||
-             (target_frame == "b" && source_frame =="i")
-             )
-    {
-      EXPECT_NEAR(outpose.transform.translation.x, sqrt(2)/2 - 1, epsilon);
-      EXPECT_NEAR(outpose.transform.translation.y, sqrt(2)/2 , epsilon);
-      EXPECT_NEAR(outpose.transform.translation.z, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.x, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.y, 0, epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.z, sin(M_PI*7/8), epsilon);
-      EXPECT_NEAR(outpose.transform.rotation.w, -cos(M_PI*7/8), epsilon);
-    }
-    else
-    {
-      EXPECT_FALSE("Ring_45 testing Shouldn't get here");
-      printf("source_frame %s target_frame %s time %f\n", source_frame.c_str(), target_frame.c_str(), eval_time.sec + eval_time.nanosec /1e9 );
-    }
-  }
-}
-
-TEST(BufferCore_lookupTransform, invalid_arguments)
-{
-  tf2::BufferCore mBC;
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(0) +
-      std::chrono::nanoseconds(0));
-
-  setupTree(mBC, "i", tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-
-  // EXPECT_NO_THROW
-  EXPECT_NO_THROW(mBC.lookupTransform("b", "a", eval_time_time_point));
-
-  //Empty frame_id
-  EXPECT_THROW(mBC.lookupTransform("", "a", eval_time_time_point), tf2::InvalidArgumentException);
-  EXPECT_THROW(mBC.lookupTransform("b", "", eval_time_time_point), tf2::InvalidArgumentException);
-  //
-  // //frame_id with /
-  EXPECT_THROW(mBC.lookupTransform("/b", "a", eval_time_time_point), tf2::InvalidArgumentException);
-  EXPECT_THROW(mBC.lookupTransform("b", "/a", eval_time_time_point), tf2::InvalidArgumentException);
-
-}
-
-TEST(BufferCore_canTransform, invalid_arguments)
-{
-  tf2::BufferCore mBC;
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(0) +
-      std::chrono::nanoseconds(0));
-
-  setupTree(mBC, "i", tf2_ros::toMsg(tf2::timeFromSec(1.0)));
-
-  EXPECT_TRUE(mBC.canTransform("b", "a", eval_time_time_point));
-
-  //Empty frame_id
-  EXPECT_FALSE(mBC.canTransform("", "a", eval_time_time_point));
-  EXPECT_FALSE(mBC.canTransform("b", "", eval_time_time_point));
-
-  //frame_id with /
-  EXPECT_FALSE(mBC.canTransform("/b", "a", eval_time_time_point));
-  EXPECT_FALSE(mBC.canTransform("b", "/a", eval_time_time_point));
-
-}
-
-struct TransformableHelper
-{
-  TransformableHelper()
-  : called(false)
-  {}
-
-  void callback(tf2::TransformableRequestHandle request_handle,
-                const std::string & target_frame,
-                const std::string & source_frame,
-                tf2::TimePoint time,
-                tf2::TransformableResult result)
-  {
-    (void)request_handle;
-    (void)target_frame;
-    (void)source_frame;
-    (void)time;
-    (void)result;
-    called = true;
-  }
-
-  bool called;
-};
-
-TEST(BufferCore_transformableCallbacks, alreadyTransformable)
-{
-  tf2::BufferCore b;
-  TransformableHelper h;
-
-  geometry_msgs::msg::TransformStamped t;
-  t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(1.0));
-  t.header.frame_id = "a";
-  t.child_frame_id = "b";
-  t.transform.rotation.w = 1.0;
-  b.setTransform(t, "me");
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(1) +
-      std::chrono::nanoseconds(0));
-
-  tf2::BufferCore::TransformableCallback cb = std::bind(&TransformableHelper::callback,
-      &h,
-      std::placeholders::_1,
-      std::placeholders::_2,
-      std::placeholders::_3,
-      std::placeholders::_4,
-      std::placeholders::_5);
-
-  EXPECT_EQ(b.addTransformableRequest(cb, "a", "b", eval_time_time_point), 0U);
-}
-
-TEST(BufferCore_transformableCallbacks, waitForNewTransform)
-{
-  tf2::BufferCore b;
-  TransformableHelper h;
-  tf2::BufferCore::TransformableCallback cb = std::bind(&TransformableHelper::callback,
-      &h,
-      std::placeholders::_1,
-      std::placeholders::_2,
-      std::placeholders::_3,
-      std::placeholders::_4,
-      std::placeholders::_5);
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(10) +
-      std::chrono::nanoseconds(0));
-
-  EXPECT_GT(b.addTransformableRequest(cb, "a", "b", eval_time_time_point), 0U);
-
-  geometry_msgs::msg::TransformStamped t;
-  for (uint32_t i = 1; i <= 10; ++i)
-  {
-    t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(i));
-    t.header.frame_id = "a";
-    t.child_frame_id = "b";
-    t.transform.rotation.w = 1.0;
-    b.setTransform(t, "me");
-
-    if (i < 10)
-    {
-      ASSERT_FALSE(h.called);
-    }
-    else
-    {
-      ASSERT_TRUE(h.called);
-    }
-  }
-}
-
-TEST(BufferCore_transformableCallbacks, waitForOldTransform)
-{
-  tf2::BufferCore b;
-  TransformableHelper h;
-  tf2::BufferCore::TransformableCallback cb = std::bind(&TransformableHelper::callback,
-      &h,
-      std::placeholders::_1,
-      std::placeholders::_2,
-      std::placeholders::_3,
-      std::placeholders::_4,
-      std::placeholders::_5);
-
-  tf2::TimePoint eval_time_time_point = tf2::TimePoint(
-      std::chrono::seconds(1) +
-      std::chrono::nanoseconds(0));
-
-  EXPECT_GT(b.addTransformableRequest(cb, "a", "b", eval_time_time_point), 0U);
-
-  geometry_msgs::msg::TransformStamped t;
-  for (uint32_t i = 10; i > 0; --i)
-  {
-    t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(i));
-    t.header.frame_id = "a";
-    t.child_frame_id = "b";
-    t.transform.rotation.w = 1.0;
-    b.setTransform(t, "me");
-
-    if (i > 1)
-    {
-      ASSERT_FALSE(h.called);
-    }
-    else
-    {
-      ASSERT_TRUE(h.called);
-    }
-  }
-}
-
-/*
-TEST(tf, Exceptions)
-{
-
- tf::Transformer mTR(true);
-
-
- Stamped<btTransform> outpose;
-
- //connectivity when no data
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(10000000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000000) , "me"), outpose);
-   EXPECT_FALSE("ConnectivityException Not Thrown");
- }
- catch ( tf::LookupException &ex)
- {
-   EXPECT_TRUE("Lookupgh Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
- mTR.setTransform( StampedTransform(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(100000), "parent", "me"));
-
- //Extrapolation not valid with one value
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(200000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(200000) , "me"), outpose);
-   EXPECT_TRUE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
- mTR.setTransform( StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(300000), "parent", "me"));
-
- //NO Extration when Interpolating
- //inverse list
- EXPECT_TRUE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(200000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(200000) , "me"), outpose);
-   EXPECT_TRUE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_FALSE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
-
- //forward list
- EXPECT_TRUE(mTR.canTransform("me", "parent", builtin_interfaces::msg::Time().fromNSec(200000)));
- try
- {
-   mTR.transformPose("me",Stamped<Pose>(btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(200000) , "parent"), outpose);
-   EXPECT_TRUE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_FALSE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
- //Extrapolating backwards
- //inverse list
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(1000)));
- try
- {
-   mTR.transformPose("parent",Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000) , "me"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
- //forwards list
- EXPECT_FALSE(mTR.canTransform("me", "parent", builtin_interfaces::msg::Time().fromNSec(1000)));
- try
- {
-   mTR.transformPose("me",Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000) , "parent"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
-
- // Test extrapolation inverse and forward linkages FORWARD
-
- //inverse list
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(350000)));
- try
- {
-   mTR.transformPose("parent", Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(350000) , "me"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
- //forward list
- EXPECT_FALSE(mTR.canTransform("parent", "me", builtin_interfaces::msg::Time().fromNSec(350000)));
- try
- {
-   mTR.transformPose("me", Stamped<Pose> (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(350000) , "parent"), outpose);
-   EXPECT_FALSE("ExtrapolationException Not Thrown");
- }
- catch ( tf::ExtrapolationException &ex)
- {
-   EXPECT_TRUE("Extrapolation Exception Caught");
- }
- catch (tf::TransformException& ex)
- {
-   printf("%s\n",ex.what());
-   EXPECT_FALSE("Other Exception Caught");
- }
-
-
-
-
-}
-
-
-
-TEST(tf, NoExtrapolationExceptionFromParent)
-{
-  tf::Transformer mTR(true, tf2::Duration().fromNSec(1000000));
-
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000), "parent", "a"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent", "a"));
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent", "b"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent", "b"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent's parent", "parent"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent's parent's parent", "parent's parent"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent's parent", "parent"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(10000),  "parent's parent's parent", "parent's parent"));
-
-  Stamped<Point> output;
-
-  try
-  {
-    mTR.transformPoint( "b", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(2000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    EXPECT_FALSE("Shouldn't have gotten this exception");
-  }
-
-
-
-};
-
-
-
-TEST(tf, ExtrapolationFromOneValue)
-{
-  tf::Transformer mTR(true, tf2::Duration().fromNSec(1000000));
-
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent", "a"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent's parent", "parent"));
-
-
-  Stamped<Point> output;
-
-  bool excepted = false;
-  //Past time
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(10), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  excepted = false;
-  //Future one element
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(100000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  //Past multi link
-  excepted = false;
-  try
-  {
-    mTR.transformPoint( "parent's parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(1), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  //Future case multi link
-  excepted = false;
-  try
-  {
-    mTR.transformPoint( "parent's parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(10000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_TRUE(excepted);
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(20000),  "parent", "a"));
-
-  excepted = false;
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time().fromNSec(10000), "a"), output);
-  }
-  catch (ExtrapolationException &ex)
-  {
-    excepted = true;
-  }
-
-  EXPECT_FALSE(excepted);
-
-};
-
-
-
-TEST(tf, getLatestCommonTime)
-{
-  tf::Transformer mTR(true);
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(1000),  "parent", "a"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(2000),  "parent's parent", "parent"));
-
-  //simple case
-  builtin_interfaces::msg::Time t;
-  mTR.getLatestCommonTime("a", "parent's parent", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(1000));
-
-  //no connection
-  EXPECT_EQ(tf::LOOKUP_ERROR, mTR.getLatestCommonTime("a", "not valid", t, NULL));
-  EXPECT_EQ(t, builtin_interfaces::msg::Time());
-
-  //testing with update
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(3000),  "parent", "a"));
-  mTR.getLatestCommonTime("a", "parent's parent",t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(2000));
-
-  //longer chain
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "parent", "b"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(3000),  "b", "c"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(9000),  "c", "d"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(5000),  "f", "e"));
-
-  //shared parent
-  mTR.getLatestCommonTime("a", "b",t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-
-  //two degrees
-  mTR.getLatestCommonTime("a", "c", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-  //reversed
-  mTR.getLatestCommonTime("c", "a", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-
-  //three degrees
-  mTR.getLatestCommonTime("a", "d", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-  //reversed
-  mTR.getLatestCommonTime("d", "a", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(3000));
-
-  //disconnected tree
-  mTR.getLatestCommonTime("e", "f", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(5000));
-  //reversed order
-  mTR.getLatestCommonTime("f", "e", t, NULL);
-  EXPECT_EQ(t, builtin_interfaces::msg::Time().fromNSec(5000));
-
-
-  mTR.setExtrapolationLimit(tf2::Duration().fromNSec(20000));
-
-  //check timestamps resulting
-  tf::Stamped<tf::Point> output, output2;
-  try
-  {
-    mTR.transformPoint( "parent", Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time(), "b"), output);
-    mTR.transformPoint( "a", builtin_interfaces::msg::Time(),Stamped<Point>(Point(1,1,1), builtin_interfaces::msg::Time(), "b"), "c",  output2);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("%s\n", ex.what());
-    EXPECT_FALSE("Shouldn't get this Exception");
-  }
-
-  EXPECT_EQ(output.stamp_, builtin_interfaces::msg::Time().fromNSec(4000));
-  EXPECT_EQ(output2.stamp_, builtin_interfaces::msg::Time().fromNSec(3000));
-
-
-  //zero length lookup zero time
-  builtin_interfaces::msg::Time now1 = builtin_interfaces::msg::Time::now();
-  builtin_interfaces::msg::Time time_output;
-  mTR.getLatestCommonTime("a", "a", time_output, NULL);
-  EXPECT_LE(now1.toSec(), time_output.toSec());
-  EXPECT_LE(time_output.toSec(), builtin_interfaces::msg::Time::now().toSec());
-
-
-}
-
-TEST(tf, RepeatedTimes)
-{
-  Transformer mTR;
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "parent", "b"));
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,1,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "parent", "b"));
-
-  tf::StampedTransform  output;
-  try{
-    mTR.lookupTransform("parent", "b" , builtin_interfaces::msg::Time().fromNSec(4000), output);
-    EXPECT_TRUE(!std::isnan(output.getOrigin().x()));
-    EXPECT_TRUE(!std::isnan(output.getOrigin().y()));
-    EXPECT_TRUE(!std::isnan(output.getOrigin().z()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().x()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().y()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().z()));
-    EXPECT_TRUE(!std::isnan(output.getRotation().w()));
-  }
-  catch (...)
-  {
-    EXPECT_FALSE("Excetion improperly thrown");
-  }
-
-
-}
-
-TEST(tf, frameExists)
-{
-  Transformer mTR;
-
-  // test with fully qualified name
-  EXPECT_FALSE(mTR.frameExists("/b"));;
-  EXPECT_FALSE(mTR.frameExists("/parent"));
-  EXPECT_FALSE(mTR.frameExists("/other"));
-  EXPECT_FALSE(mTR.frameExists("/frame"));
-
-  //test with resolveping
-  EXPECT_FALSE(mTR.frameExists("b"));;
-  EXPECT_FALSE(mTR.frameExists("parent"));
-  EXPECT_FALSE(mTR.frameExists("other"));
-  EXPECT_FALSE(mTR.frameExists("frame"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/parent", "/b"));
-
-  // test with fully qualified name
-  EXPECT_TRUE(mTR.frameExists("/b"));
-  EXPECT_TRUE(mTR.frameExists("/parent"));
-  EXPECT_FALSE(mTR.frameExists("/other"));
-  EXPECT_FALSE(mTR.frameExists("/frame"));
-
-  //Test with resolveping
-  EXPECT_TRUE(mTR.frameExists("b"));
-  EXPECT_TRUE(mTR.frameExists("parent"));
-  EXPECT_FALSE(mTR.frameExists("other"));
-  EXPECT_FALSE(mTR.frameExists("frame"));
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,1,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/frame", "/other"));
-
-  // test with fully qualified name
-  EXPECT_TRUE(mTR.frameExists("/b"));
-  EXPECT_TRUE(mTR.frameExists("/parent"));
-  EXPECT_TRUE(mTR.frameExists("/other"));
-  EXPECT_TRUE(mTR.frameExists("/frame"));
-
-  //Test with resolveping
-  EXPECT_TRUE(mTR.frameExists("b"));
-  EXPECT_TRUE(mTR.frameExists("parent"));
-  EXPECT_TRUE(mTR.frameExists("other"));
-  EXPECT_TRUE(mTR.frameExists("frame"));
-
-}
-
-TEST(tf, resolve)
-{
-  //no prefix
-  EXPECT_STREQ("/id", tf::resolve("","id").c_str());
-  //prefix w/o /
-  EXPECT_STREQ("/asdf/id", tf::resolve("asdf","id").c_str());
-  //prefix w /
-  EXPECT_STREQ("/asdf/id", tf::resolve("/asdf","id").c_str());
-  // frame_id w / -> no prefix
-  EXPECT_STREQ("/id", tf::resolve("asdf","/id").c_str());
-  // frame_id w / -> no prefix
-  EXPECT_STREQ("/id", tf::resolve("/asdf","/id").c_str());
-
-}
-
-TEST(tf, canTransform)
-{
-  Transformer mTR;
-
-  //confirm zero length list disconnected will return true
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", builtin_interfaces::msg::Time()));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", builtin_interfaces::msg::Time::now()));
-
-  //Create a two link tree between times 10 and 20
-  for (int i = 10; i < 20; i++)
-  {
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "child"));
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "other_child"));
-  }
-
-  // four different timestamps related to tf state
-  builtin_interfaces::msg::Time zero_time = builtin_interfaces::msg::Time().fromSec(0);
-  builtin_interfaces::msg::Time old_time = builtin_interfaces::msg::Time().fromSec(5);
-  builtin_interfaces::msg::Time valid_time = builtin_interfaces::msg::Time().fromSec(15);
-  builtin_interfaces::msg::Time future_time = builtin_interfaces::msg::Time().fromSec(25);
-
-
-  //confirm zero length list disconnected will return true
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", zero_time));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", old_time));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", valid_time));
-  EXPECT_TRUE(mTR.canTransform("some_frame","some_frame", future_time));
-
-  // Basic API Tests
-
-  //Valid data should pass
-  EXPECT_TRUE(mTR.canTransform("child", "parent", valid_time));
-  EXPECT_TRUE(mTR.canTransform("child", "other_child", valid_time));
-
-  //zero data should pass
-  EXPECT_TRUE(mTR.canTransform("child", "parent", zero_time));
-  EXPECT_TRUE(mTR.canTransform("child", "other_child", zero_time));
-
-  //Old data should fail
-  EXPECT_FALSE(mTR.canTransform("child", "parent", old_time));
-  EXPECT_FALSE(mTR.canTransform("child", "other_child", old_time));
-
-  //Future data should fail
-  EXPECT_FALSE(mTR.canTransform("child", "parent", future_time));
-  EXPECT_FALSE(mTR.canTransform("child", "other_child", future_time));
-
-  //Same Frame should pass for all times
-  EXPECT_TRUE(mTR.canTransform("child", "child", zero_time));
-  EXPECT_TRUE(mTR.canTransform("child", "child", old_time));
-  EXPECT_TRUE(mTR.canTransform("child", "child", valid_time));
-  EXPECT_TRUE(mTR.canTransform("child", "child", future_time));
-
-  // Advanced API Tests
-
-  // Source = Fixed
-  //zero data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", zero_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", zero_time, "other_child", valid_time, "child"));
-  //Old data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", old_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", old_time, "other_child", valid_time, "child"));
-  //valid data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "other_child", valid_time, "child"));
-  //future data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", future_time, "parent", valid_time, "child"));
-  EXPECT_TRUE(mTR.canTransform("child", future_time, "other_child", valid_time, "child"));
-
-  //transforming through fixed into the past
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "parent", old_time, "child"));
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "other_child", old_time, "child"));
-  //transforming through fixed into the future
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "parent", future_time, "child"));
-  EXPECT_FALSE(mTR.canTransform("child", valid_time, "other_child", future_time, "child"));
-
-  // Target = Fixed
-  //zero data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", zero_time, "parent", valid_time, "parent"));
-  //Old data in fixed frame should pass
-  EXPECT_FALSE(mTR.canTransform("child", old_time, "parent", valid_time, "parent"));
-  //valid data in fixed frame should pass
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", valid_time, "parent"));
-  //future data in fixed frame should pass
-  EXPECT_FALSE(mTR.canTransform("child", future_time, "parent", valid_time, "parent"));
-
-  //transforming through fixed into the zero
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", zero_time, "parent"));
-  //transforming through fixed into the past
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", old_time, "parent"));
-  //transforming through fixed into the valid
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", valid_time, "parent"));
-  //transforming through fixed into the future
-  EXPECT_TRUE(mTR.canTransform("child", valid_time, "parent", future_time, "parent"));
-
-}
-
-TEST(tf, lookupTransform)
-{
-  Transformer mTR;
-  //Create a two link tree between times 10 and 20
-  for (int i = 10; i < 20; i++)
-  {
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "child"));
-    mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(1,0,0), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromSec(i),  "parent", "other_child"));
-  }
-
-  // four different timestamps related to tf state
-  builtin_interfaces::msg::Time zero_time = builtin_interfaces::msg::Time().fromSec(0);
-  builtin_interfaces::msg::Time old_time = builtin_interfaces::msg::Time().fromSec(5);
-  builtin_interfaces::msg::Time valid_time = builtin_interfaces::msg::Time().fromSec(15);
-  builtin_interfaces::msg::Time future_time = builtin_interfaces::msg::Time().fromSec(25);
-
-  //output
-  tf::StampedTransform output;
-
-  // Basic API Tests
-
-  try
-  {
-    //confirm zero length list disconnected will return true
-    mTR.lookupTransform("some_frame","some_frame", zero_time, output);
-    mTR.lookupTransform("some_frame","some_frame", old_time, output);
-    mTR.lookupTransform("some_frame","some_frame", valid_time, output);
-    mTR.lookupTransform("some_frame","some_frame", future_time, output);
-    mTR.lookupTransform("child","child", future_time, output);
-    mTR.lookupTransform("other_child","other_child", future_time, output);
-
-    //Valid data should pass
-    mTR.lookupTransform("child", "parent", valid_time, output);
-    mTR.lookupTransform("child", "other_child", valid_time, output);
-
-    //zero data should pass
-    mTR.lookupTransform("child", "parent", zero_time, output);
-    mTR.lookupTransform("child", "other_child", zero_time, output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception thrown");
-  }
-  try
-  {
-    //Old data should fail
-    mTR.lookupTransform("child", "parent", old_time, output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-  try {
-    //Future data should fail
-    mTR.lookupTransform("child", "parent", future_time, output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    //Same Frame should pass for all times
-    mTR.lookupTransform("child", "child", zero_time, output);
-    mTR.lookupTransform("child", "child", old_time, output);
-    mTR.lookupTransform("child", "child", valid_time, output);
-    mTR.lookupTransform("child", "child", future_time, output);
-
-    // Advanced API Tests
-
-    // Source = Fixed
-    //zero data in fixed frame should pass
-    mTR.lookupTransform("child", zero_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", zero_time, "other_child", valid_time, "child", output);
-    //Old data in fixed frame should pass
-    mTR.lookupTransform("child", old_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", old_time, "other_child", valid_time, "child", output);
-    //valid data in fixed frame should pass
-    mTR.lookupTransform("child", valid_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", valid_time, "other_child", valid_time, "child", output);
-    //future data in fixed frame should pass
-    mTR.lookupTransform("child", future_time, "parent", valid_time, "child", output);
-    mTR.lookupTransform("child", future_time, "other_child", valid_time, "child", output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception incorrectly thrown");
-  }
-
-  try {
-    //transforming through fixed into the past
-    mTR.lookupTransform("child", valid_time, "parent", old_time, "child", output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    //transforming through fixed into the future
-    mTR.lookupTransform("child", valid_time, "parent", future_time, "child", output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    // Target = Fixed
-    //zero data in fixed frame should pass
-    mTR.lookupTransform("child", zero_time, "parent", valid_time, "parent", output);
-    //valid data in fixed frame should pass
-    mTR.lookupTransform("child", valid_time, "parent", valid_time, "parent", output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception incorrectly thrown");
-  }
-
-  try {
-  //Old data in fixed frame should pass
-  mTR.lookupTransform("child", old_time, "parent", valid_time, "parent", output);
-      EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-  try {
-    //future data in fixed frame should pass
-    mTR.lookupTransform("child", future_time, "parent", valid_time, "parent", output);
-    EXPECT_FALSE("Exception should have been thrown");
-  }
-  catch (tf::TransformException)
-  {
-    EXPECT_TRUE("Exception Thrown Correctly");
-  }
-
-  try {
-    //transforming through fixed into the zero
-    mTR.lookupTransform("child", valid_time, "parent", zero_time, "parent", output);
-    //transforming through fixed into the past
-    mTR.lookupTransform("child", valid_time, "parent", old_time, "parent", output);
-    //transforming through fixed into the valid
-    mTR.lookupTransform("child", valid_time, "parent", valid_time, "parent", output);
-    //transforming through fixed into the future
-    mTR.lookupTransform("child", valid_time, "parent", future_time, "parent", output);
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception improperly thrown");
-  }
-
-
-  //make sure zero goes to now for zero length
-  try
-  {
-    builtin_interfaces::msg::Time now1 = builtin_interfaces::msg::Time::now();
-
-    mTR.lookupTransform("a", "a", builtin_interfaces::msg::Time(),output);
-    EXPECT_LE(now1.toSec(), output.stamp_.toSec());
-    EXPECT_LE(output.stamp_.toSec(), builtin_interfaces::msg::Time::now().toSec());
-  }
-  catch (tf::TransformException &ex)
-  {
-    printf("Exception improperly thrown: %s", ex.what());
-    EXPECT_FALSE("Exception improperly thrown");
-  }
-
-}
-
-
-TEST(tf, getFrameStrings)
-{
-  Transformer mTR;
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/parent", "/b"));
-  std::vector <std::string> frames_string;
-  mTR.getFrameStrings(frames_string);
-  ASSERT_EQ(frames_string.size(), (unsigned)2);
-  EXPECT_STREQ(frames_string[0].c_str(), std::string("/b").c_str());
-  EXPECT_STREQ(frames_string[1].c_str(), std::string("/parent").c_str());
-
-
-  mTR.setTransform(  StampedTransform (btTransform(tf2::Quaternion(0,0,0,1), btVector3(0,0,0)), builtin_interfaces::msg::Time().fromNSec(4000),  "/frame", "/other"));
-
-  mTR.getFrameStrings(frames_string);
-  ASSERT_EQ(frames_string.size(), (unsigned)4);
-  EXPECT_STREQ(frames_string[0].c_str(), std::string("/b").c_str());
-  EXPECT_STREQ(frames_string[1].c_str(), std::string("/parent").c_str());
-  EXPECT_STREQ(frames_string[2].c_str(), std::string("/other").c_str());
-  EXPECT_STREQ(frames_string[3].c_str(), std::string("/frame").c_str());
-
-}
-
-bool expectInvalidQuaternion(tf::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-    printf("this should have thrown\n");
-    return false;
-  }
-  catch (tf::InvalidArgument &ex)
-  {
-    return true;
-  }
-  catch  (...)
-  {
-    printf("A different type of exception was expected\n");
-    return false;
-  }
-  return false;
-}
-
-bool expectValidQuaternion(tf::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-  }
-  catch (tf::TransformException &ex)
-  {
-    return false;
-  }
-  return true;
-}
-
-bool expectInvalidQuaternion(geometry_msgs::msg::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-    printf("this should have thrown\n");
-    return false;
-  }
-  catch (tf::InvalidArgument &ex)
-  {
-    return true;
-  }
-  catch  (...)
-  {
-    printf("A different type of exception was expected\n");
-    return false;
-  }
-  return false;
-}
-
-bool expectValidQuaternion(geometry_msgs::msg::Quaternion q)
-{
-  try
-  {
-    tf::assertQuaternionValid(q);
-  }
-  catch (tf::TransformException &ex)
-  {
-    return false;
-  }
-  return true;
-}
-
-
-TEST(tf, assertQuaternionValid)
-{
-  tf::Quaternion q(1,0,0,0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setX(0);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setY(1);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setZ(1);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setY(0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setW(1);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setZ(0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.setZ(sqrt(2.0)/2.0);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.setW(sqrt(2.0)/2.0);
-  EXPECT_TRUE(expectValidQuaternion(q));
-
-  q.setZ(sqrt(2.0)/2.0 + 0.01);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-  q.setZ(sqrt(2.0)/2.0 - 0.01);
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-  EXPECT_THROW(tf::assertQuaternionValid(q), tf::InvalidArgument);
-  //    Waiting for gtest 1.1 or later
-  //  EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-  //q.setX(0);
-  //EXPECT_THROW(tf::assertQuaternionValid(q), tf::InvalidArgument);
-  //q.setY(1);
-  //EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-
-}
-TEST(tf, assertQuaternionMsgValid)
-{
-  geometry_msgs::msg::Quaternion q;
-  q.x = 1;//others zeroed to start
-
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.x = 0;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.y = 1;
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.z = 1;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.y = 0;
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.w = 1;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.z = 0;
-  EXPECT_TRUE(expectValidQuaternion(q));
-  q.z = sqrt(2.0)/2.0;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-  q.w = sqrt(2.0)/2.0;
-  EXPECT_TRUE(expectValidQuaternion(q));
-
-  q.z = sqrt(2.0)/2.0 + 0.01;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-  q.z = sqrt(2.0)/2.0 - 0.01;
-  EXPECT_TRUE(expectInvalidQuaternion(q));
-
-
-  //    Waiting for gtest 1.1 or later
-  //  EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-  //q.x = 0);
-  //EXPECT_THROW(tf::assertQuaternionValid(q), tf::InvalidArgument);
-  //q.y = 1);
-  //EXPECT_NO_THROW(tf::assertQuaternionValid(q));
-
-}
-
-
-TEST(tf2_stamped, OperatorEqualEqual)
-{
-  btTransform transform0, transform1, transform0a;
-  transform0.setIdentity();
-  transform0a.setIdentity();
-  transform1.setIdentity();
-  transform1.setOrigin(btVector3(1, 0, 0));
-  tf2::StampedTransform stamped_transform_reference(transform0a, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id");
-  tf2::StampedTransform stamped_transform0A(transform0, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id");
-  EXPECT_TRUE(stamped_transform0A == stamped_transform_reference); // Equal
-  tf2::StampedTransform stamped_transform0B(transform0, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0B == stamped_transform_reference); // Different Frame id
-  tf2::StampedTransform stamped_transform0C(transform0, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0C == stamped_transform_reference); // Different Time
-  tf2::StampedTransform stamped_transform0D(transform0, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0D == stamped_transform_reference); // Different frame id and time
-  tf2::StampedTransform stamped_transform0E(transform1, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0E == stamped_transform_reference); // Different transform, frame id
-  tf2::StampedTransform stamped_transform0F(transform1, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0F == stamped_transform_reference); // Different transform, time
-  tf2::StampedTransform stamped_transform0G(transform1, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0G == stamped_transform_reference); // Different transform, frame id and time
-  tf2::StampedTransform stamped_transform0H(transform1, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id");
-  EXPECT_FALSE(stamped_transform0H == stamped_transform_reference); // Different transform
-
-
-  //Different child_frame_id
-  tf2::StampedTransform stamped_transform1A(transform0, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1A == stamped_transform_reference); // Equal
-  tf2::StampedTransform stamped_transform1B(transform0, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1B == stamped_transform_reference); // Different Frame id
-  tf2::StampedTransform stamped_transform1C(transform0, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1C == stamped_transform_reference); // Different Time
-  tf2::StampedTransform stamped_transform1D(transform0, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1D == stamped_transform_reference); // Different frame id and time
-  tf2::StampedTransform stamped_transform1E(transform1, builtin_interfaces::msg::Time(), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1E == stamped_transform_reference); // Different transform, frame id
-  tf2::StampedTransform stamped_transform1F(transform1, builtin_interfaces::msg::Time(1.0), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1F == stamped_transform_reference); // Different transform, time
-  tf2::StampedTransform stamped_transform1G(transform1, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1G == stamped_transform_reference); // Different transform, frame id and time
-  tf2::StampedTransform stamped_transform1H(transform1, builtin_interfaces::msg::Time(), "frame_id", "child_frame_id2");
-  EXPECT_FALSE(stamped_transform1H == stamped_transform_reference); // Different transform
-
-}
-
-TEST(tf2_stamped, OperatorEqual)
-{
-  btTransform pose0, pose1, pose0a;
-  pose0.setIdentity();
-  pose1.setIdentity();
-  pose1.setOrigin(btVector3(1, 0, 0));
-  tf2::Stamped<btTransform> stamped_pose0(pose0, builtin_interfaces::msg::Time(), "frame_id");
-  tf2::Stamped<btTransform> stamped_pose1(pose1, builtin_interfaces::msg::Time(1.0), "frame_id_not_equal");
-  EXPECT_FALSE(stamped_pose1 == stamped_pose0);
-  stamped_pose1 = stamped_pose0;
-  EXPECT_TRUE(stamped_pose1 == stamped_pose0);
-
-}
-  */
-int main(int argc, char **argv){
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/permuter.hpp b/test_tf2/test/permuter.hpp
deleted file mode 100644
index bd8d29d8..00000000
--- a/test_tf2/test/permuter.hpp
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (c) 2009, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/** \author Tully Foote */
-
-#ifndef ROSTEST_PERMUTER_HPP
-#define ROSTEST_PERMUTER_HPP
-
-#include <memory>
-#include <mutex>
-#include <vector>
-
-namespace rostest
-{
-/** \brief A base class for storing pointers to generic data types
- */
-class PermuteOptionBase
-{
-public:
-  virtual void reset() = 0;
-  virtual bool step() = 0;
-  virtual ~PermuteOptionBase() {};
-};
-
-
-/**\brief A class to hold a set of option values and currently used state
- *  This class holds
- */
-template<class T>
-class PermuteOption : public PermuteOptionBase
-{
-public:
-  PermuteOption(const std::vector<T>& options, T* output)
-  {
-    options_ = options;
-    output_ = output;
-    reset();
-  }
-
-  virtual ~PermuteOption(){};
-
-  void reset()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    current_element_ = options_.begin();
-    *output_ = *current_element_;
-  }
-
-  bool step()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    current_element_++;
-    if (current_element_ == options_.end())
-      return false;
-    *output_ = *current_element_;
-    return true;
-  }
-
-private:
-  /// Local storage of the possible values
-  std::vector<T> options_;
-  /// The output variable
-  T* output_;
-  typedef typename std::vector<T>::iterator V_T_iterator;
-  /// The last updated element
-  V_T_iterator current_element_;
-
-  std::mutex access_mutex_;
-
-};
-
-/** \brief A class to provide easy permutation of options
- * This class provides a way to collapse independent
- * permutations of options into a single loop.
- */
-class Permuter
-{
-public:
-  /** \brief Destructor to clean up allocated data */
-  virtual ~Permuter(){ clearAll();};
-
-
-  /** \brief Add a set of values and an output to the iteration
-   * @param values The set of possible values for this output
-   * @param output The value to set at each iteration
-   */
-  template<class T>
-  void addOptionSet(const std::vector<T>& values, T* output)
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    options_.emplace_back(std::make_unique<PermuteOption<T>>(values, output));
-    reset();
-  }
-
-
-  /** \brief Reset the internal counters */
-  void reset()
-  {
-    for (unsigned int level= 0; level < options_.size(); level++)
-    {
-      options_[level]->reset();
-    }
-  }
-
-  /** \brief Iterate to the next value in the iteration
-   * Returns true unless done iterating.
-   */
-  bool step()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    // base case just iterating
-    for (size_t level = 0; level < options_.size(); level++)
-    {
-      if(options_[level]->step())
-      {
-        //printf("stepping level %d returning true \n", level);
-        return true;
-      }
-      else
-      {
-        //printf("reseting level %d\n", level);
-        options_[level]->reset();
-      }
-    }
-    return false;
-  }
-
-  /** \brief Clear all stored data */
-  void clearAll()
-  {
-    std::lock_guard<std::mutex> lock(access_mutex_);
-    options_.clear();
-  }
-
-private:
-  std::vector<std::unique_ptr<PermuteOptionBase>> options_; ///< Store all the option objects
-  std::mutex access_mutex_;
-};
-
-
-}
-
-#endif //ROSTEST_PERMUTER_HPP
diff --git a/test_tf2/test/static_publisher.launch.py b/test_tf2/test/static_publisher.launch.py
deleted file mode 100644
index a995fa0c..00000000
--- a/test_tf2/test/static_publisher.launch.py
+++ /dev/null
@@ -1,54 +0,0 @@
-# generated from buildfarm_perf_tests/test/test_performance.py.in
-# generated code does not contain a copyright notice
-
-import unittest
-
-from launch import LaunchDescription
-import launch
-from launch_ros.actions import Node
-from launch.substitutions import LaunchConfiguration
-import launch_testing
-import launch_testing.actions
-
-def generate_test_description():
-    node_under_test = Node(
-        package='test_tf2',
-        executable='test_static_publisher',
-        output='screen',
-        arguments=[],
-    )
-    node_static_transform_publisher_1 = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "1", "--y", "0", "--z", "0", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "a", "--child-frame-id", "b"]
-    )
-    node_static_transform_publisher_2 = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "0", "--y", "1", "--z", "0", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "b", "--child-frame-id", "c"]
-    )
-
-    return LaunchDescription([
-        node_static_transform_publisher_1,
-        node_static_transform_publisher_2,
-        node_under_test,
-        launch_testing.util.KeepAliveProc(),
-        launch_testing.actions.ReadyToTest(),
-        ]), locals()
-
-
-class TestBufferClient(unittest.TestCase):
-
-    def test_termination(self, node_under_test, proc_info):
-        proc_info.assertWaitForShutdown(process=node_under_test, timeout=(60))
-
-
-@launch_testing.post_shutdown_test()
-class BufferClientTestAfterShutdown(unittest.TestCase):
-
-    def test_exit_code(self, proc_info):
-        # Check that all processes in the launch (in this case, there's just one) exit
-        # with code 0
-        launch_testing.asserts.assertExitCodes(proc_info)
diff --git a/test_tf2/test/test_buffer_client.cpp b/test_tf2/test/test_buffer_client.cpp
deleted file mode 100644
index 8b06a7d3..00000000
--- a/test_tf2/test/test_buffer_client.cpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/*********************************************************************
-*
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of Willow Garage, Inc. nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-* Author: Eitan Marder-Eppstein
-*********************************************************************/
-#include <gtest/gtest.h>
-
-#include <rclcpp/rclcpp.hpp>
-#include <tf2_bullet/tf2_bullet.hpp>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-#include <tf2_kdl/tf2_kdl.hpp>
-#include <tf2_ros/buffer_client.h>
-
-#include <chrono>
-#include <functional>
-#include <memory>
-#include <thread>
-
-static const double EPS = 1e-3;
-
-TEST(tf2_ros, buffer_client)
-{
-  rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>("tf_action_node");
-  std::unique_ptr<tf2_ros::BufferClient> client = std::make_unique<tf2_ros::BufferClient>(node, "tf_action");
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-
-  executor.add_node(node);
-
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  //make sure that things are set up
-  ASSERT_TRUE(client->waitForServer(std::chrono::seconds(4)));
-
-  geometry_msgs::msg::PointStamped p1;
-  p1.header.frame_id = "a";
-  p1.header.stamp = builtin_interfaces::msg::Time();
-  p1.point.x = 0.0;
-  p1.point.y = 0.0;
-  p1.point.z = 0.0;
-
-  try
-  {
-    geometry_msgs::msg::PointStamped p2 = client->transform(p1, "b");
-    RCLCPP_INFO(node->get_logger(),
-                "p1: (%.2f, %.2f, %.2f), p2: (%.2f, %.2f, %.2f)", p1.point.x,
-                p1.point.y, p1.point.z, p2.point.x, p2.point.y, p2.point.z);
-
-    EXPECT_NEAR(p2.point.x, -5.0, EPS);
-    EXPECT_NEAR(p2.point.y, -6.0, EPS);
-    EXPECT_NEAR(p2.point.z, -7.0, EPS);
-  }
-  catch(tf2::TransformException& ex)
-  {
-    RCLCPP_ERROR(node->get_logger(), "Failed to transform: %s", ex.what());
-    ASSERT_FALSE("Should not get here");
-  }
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(tf2_ros, buffer_client_different_types)
-{
-  rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>("tf_action_node");
-  std::unique_ptr<tf2_ros::BufferClient> client = std::make_unique<tf2_ros::BufferClient>(node, "tf_action");
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-
-  executor.add_node(node);
-
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  //make sure that things are set up
-  ASSERT_TRUE(client->waitForServer(std::chrono::seconds(4)));
-
-  tf2::Stamped<KDL::Vector> k1(KDL::Vector(0, 0, 0), tf2::TimePoint(), "a");
-
-  try
-  {
-    tf2::Stamped<btVector3> b1;
-    client->transform(k1, b1, "b");
-    RCLCPP_ERROR(node->get_logger(), "Bullet: (%.4f, %.4f, %.4f)", b1[0], b1[1], b1[2]);
-    RCLCPP_ERROR(node->get_logger(), "KDL: (%.4f, %.4f, %.4f)", k1[0], k1[1], k1[2]);
-    EXPECT_NEAR(b1[0], -5.0, EPS);
-    EXPECT_NEAR(b1[1], -6.0, EPS);
-    EXPECT_NEAR(b1[2], -7.0, EPS);
-    EXPECT_EQ(b1.frame_id_, "b");
-    EXPECT_EQ(k1.frame_id_, "a");
-  }
-  catch(tf2::TransformException& ex)
-  {
-    RCLCPP_ERROR(node->get_logger(), "Failed to transform: %s", ex.what());
-    ASSERT_FALSE("Should not get here");
-  }
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-
-}
-
-int main(int argc, char** argv)
-{
-  // This is needed because we need to wait a little bit for the other nodes
-  std::this_thread::sleep_for(std::chrono::milliseconds(1000));
-
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/test_buffer_client.launch.py b/test_tf2/test/test_buffer_client.launch.py
deleted file mode 100644
index edfa968a..00000000
--- a/test_tf2/test/test_buffer_client.launch.py
+++ /dev/null
@@ -1,55 +0,0 @@
-# generated from buildfarm_perf_tests/test/test_performance.py.in
-# generated code does not contain a copyright notice
-
-import unittest
-
-from launch import LaunchDescription
-import launch
-from launch_ros.actions import Node
-from launch.substitutions import LaunchConfiguration
-import launch_testing
-import launch_testing.actions
-
-
-def generate_test_description():
-    node_under_test = Node(
-        package='test_tf2',
-        executable='test_buffer_client.py',
-        output='screen',
-    )
-    node_static_transform_publisher = Node(
-        package='tf2_ros',
-        executable='static_transform_publisher',
-        output='screen',
-        arguments=["--x", "5", "--y", "6", "--z", "7", "--qx", "0", "--qy", "0", "--qz", "0", "--qw", "1", "--frame-id", "a", "--child-frame-id", "b"]
-    )
-
-    node_buffer_server = Node(
-        package='test_tf2',
-        executable='test_buffer_server',
-        output='screen',
-        arguments=[],
-        sigterm_timeout=LaunchConfiguration('sigterm_timeout', default=2)
-    )
-    return LaunchDescription([
-        node_static_transform_publisher,
-        node_buffer_server,
-        node_under_test,
-        launch_testing.util.KeepAliveProc(),
-        launch_testing.actions.ReadyToTest(),
-        ]), locals()
-
-
-class TestBufferClient(unittest.TestCase):
-
-    def test_termination(self, node_under_test, proc_info):
-        proc_info.assertWaitForShutdown(process=node_under_test, timeout=(10))
-
-
-@launch_testing.post_shutdown_test()
-class BufferClientTestAfterShutdown(unittest.TestCase):
-
-    def test_exit_code(self, proc_info):
-        # Check that all processes in the launch (in this case, there's just one) exit
-        # with code 0
-        launch_testing.asserts.assertExitCodes(proc_info)
diff --git a/test_tf2/test/test_buffer_client.py b/test_tf2/test/test_buffer_client.py
deleted file mode 100755
index 97570c01..00000000
--- a/test_tf2/test/test_buffer_client.py
+++ /dev/null
@@ -1,127 +0,0 @@
-#!/usr/bin/python3
-#***********************************************************
-#* Software License Agreement (BSD License)
-#*
-#*  Copyright (c) 2009, Willow Garage, Inc.
-#*  All rights reserved.
-#*
-#*  Redistribution and use in source and binary forms, with or without
-#*  modification, are permitted provided that the following conditions
-#*  are met:
-#*
-#*   * Redistributions of source code must retain the above copyright
-#*     notice, this list of conditions and the following disclaimer.
-#*   * Redistributions in binary form must reproduce the above
-#*     copyright notice, this list of conditions and the following
-#*     disclaimer in the documentation and/or other materials provided
-#*     with the distribution.
-#*   * Neither the name of Willow Garage, Inc. nor the names of its
-#*     contributors may be used to endorse or promote products derived
-#*     from this software without specific prior written permission.
-#*
-#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-#*  POSSIBILITY OF SUCH DAMAGE.
-#*
-#* Author: Eitan Marder-Eppstein
-#***********************************************************
-import sys
-import unittest
-
-import tf2_py as tf2
-import tf2_ros
-from geometry_msgs.msg import PointStamped
-import rclpy
-import tf2_geometry_msgs
-# TODO (ahcorde): Enable once python_orocos_kdl is ported
-# import tf2_kdl
-# import PyKDL
-from rclpy.executors import SingleThreadedExecutor
-import threading
-
-class TestBufferClient(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls):
-        cls.context = rclpy.context.Context()
-        rclpy.init(context=cls.context)
-        cls.executor = SingleThreadedExecutor(context=cls.context)
-        cls.node = rclpy.create_node('TestBufferClient', context=cls.context)
-        cls.executor.add_node(cls.node)
-
-    @classmethod
-    def tearDownClass(cls):
-        rclpy.shutdown(context=cls.context)
-
-    def setUp(self):
-        self.spinning = threading.Event()
-        self.spin_thread = threading.Thread(target=self.spin)
-        self.spin_thread.start()
-        return
-
-    def tearDown(self):
-        self.spinning.set()
-        self.spin_thread.join()
-        return
-
-    def spin(self):
-        try:
-            while self.context.ok() and not self.spinning.is_set():
-                self.executor.spin_once(timeout_sec=0.05)
-        finally:
-            return
-
-    def test_buffer_client(self):
-        buffer_client = tf2_ros.BufferClient(
-            self.node, '/tf_action', check_frequency=10.0, timeout_padding=0.0)
-
-        p1 = PointStamped()
-        p1.header.frame_id = "a"
-        p1.header.stamp = rclpy.time.Time(seconds=1.0).to_msg()
-        p1.point.x = 0.0
-        p1.point.y = 0.0
-        p1.point.z = 0.0
-
-        buffer_client.action_client.wait_for_server()
-
-        try:
-            p2 = buffer_client.transform(p1, "b", timeout=rclpy.time.Duration(seconds=1))
-            self.node.get_logger().info("p1: %s, p2: %s" % (p1, p2))
-        except tf2.TransformException as e:
-            self.node.get_logger().error("%s" % e)
-            self.assertEqual(0, 4)
-
-    # TODO (ahcorde): Enable once python_orocos_kdl is ported
-    # def test_transform_type(self):
-    #     buffer_client = tf2_ros.BufferClient(
-    #         self.node, '/tf_action', check_frequency=10.0, timeout_padding=0.0)
-    #
-    #     p1 = PointStamped()
-    #     p1.header.frame_id = "a"
-    #     p1.header.stamp = rclpy.time.Time(seconds=1.0).to_msg()
-    #     p1.point.x = 0.0
-    #     p1.point.y = 0.0
-    #     p1.point.z = 0.0
-    #
-    #     buffer_client.action_client.wait_for_server()
-    #
-    #     try:
-    #         p2 = buffer_client.transform(p1, "b", timeout=rclpy.time.Duration(seconds=1),
-    #                                      new_type = PyKDL.Vector)
-    #         self.node.get_logger().info("p1: %s, p2: %s" % (str(p1), str(p2)))
-    #     except tf2.TransformException as e:
-    #         self.node.get_logger().error("%s" % e)
-
-
-if __name__ == '__main__':
-    rclpy.init(args=sys.argv)
-    sys.argv = [sys.argv[0]]
-    unittest.main()
diff --git a/test_tf2/test/test_buffer_server.cpp b/test_tf2/test/test_buffer_server.cpp
deleted file mode 100644
index c9361cf4..00000000
--- a/test_tf2/test/test_buffer_server.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/*********************************************************************
-*
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of Willow Garage, Inc. nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-* Author: Eitan Marder-Eppstein
-*********************************************************************/
-#include <tf2_ros/buffer.h>
-#include <tf2_ros/buffer_server.h>
-#include <tf2_ros/transform_listener.h>
-#include <rclcpp/rclcpp.hpp>
-#include <memory>
-
-int main(int argc, char** argv)
-{
-  rclcpp::init(argc, argv);
-
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  tf2_ros::TransformListener tfl(buffer, node, false);
-  std::unique_ptr<tf2_ros::BufferServer> server = std::make_unique<tf2_ros::BufferServer>(buffer, node, "tf_action");
-
-  rclcpp::spin(node);
-}
diff --git a/test_tf2/test/test_convert.cpp b/test_tf2/test/test_convert.cpp
deleted file mode 100644
index 432bbfe5..00000000
--- a/test_tf2/test/test_convert.cpp
+++ /dev/null
@@ -1,195 +0,0 @@
-/*********************************************************************
-*
-* Software License Agreement (BSD License)
-*
-*  Copyright (c) 2009, Willow Garage, Inc.
-*  All rights reserved.
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions
-*  are met:
-*
-*   * Redistributions of source code must retain the above copyright
-*     notice, this list of conditions and the following disclaimer.
-*   * Redistributions in binary form must reproduce the above
-*     copyright notice, this list of conditions and the following
-*     disclaimer in the documentation and/or other materials provided
-*     with the distribution.
-*   * Neither the name of Willow Garage, Inc. nor the names of its
-*     contributors may be used to endorse or promote products derived
-*     from this software without specific prior written permission.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-*  POSSIBILITY OF SUCH DAMAGE.
-*
-* Author: Eitan Marder-Eppstein
-*********************************************************************/
-#include <gtest/gtest.h>
-#include <geometry_msgs/msg/point_stamped.hpp>
-#include <geometry_msgs/msg/point.hpp>
-#include <geometry_msgs/msg/vector3.hpp>
-#include <tf2/convert.h>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2_kdl/tf2_kdl.hpp>
-#include <tf2_bullet/tf2_bullet.hpp>
-#include <tf2_eigen/tf2_eigen.hpp>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-
-#include <Eigen/Geometry>
-
-TEST(tf2Convert, kdlToBullet)
-{
-  double epsilon = 1e-9;
-
-  tf2::Stamped<btVector3> b(btVector3(1, 2, 3), tf2::timeFromSec(0), "my_frame");
-
-  tf2::Stamped<btVector3> b1 = b;
-  tf2::Stamped<KDL::Vector> k1;
-  tf2::convert(b1, k1);
-
-  tf2::Stamped<btVector3> b2;
-  tf2::convert(k1, b2);
-
-  EXPECT_EQ(b.frame_id_, b2.frame_id_);
-  EXPECT_NEAR(tf2::timeToSec(b.stamp_), tf2::timeToSec(b2.stamp_), epsilon);
-  EXPECT_NEAR(b.x(), b2.x(), epsilon);
-  EXPECT_NEAR(b.y(), b2.y(), epsilon);
-  EXPECT_NEAR(b.z(), b2.z(), epsilon);
-
-
-  EXPECT_EQ(b1.frame_id_, b2.frame_id_);
-  EXPECT_NEAR(tf2::timeToSec(b1.stamp_), tf2::timeToSec(b2.stamp_), epsilon);
-  EXPECT_NEAR(b1.x(), b2.x(), epsilon);
-  EXPECT_NEAR(b1.y(), b2.y(), epsilon);
-  EXPECT_NEAR(b1.z(), b2.z(), epsilon);
-}
-
-TEST(tf2Convert, kdlBulletROSConversions)
-{
-  double epsilon = 1e-9;
-
-  tf2::Stamped<btVector3> b1(btVector3(1, 2, 3), tf2::timeFromSec(0), "my_frame"), b2, b3, b4;
-  geometry_msgs::msg::PointStamped r1, r2, r3;
-  tf2::Stamped<KDL::Vector> k1, k2, k3;
-
-  // Do bullet -> self -> bullet -> KDL -> self -> KDL -> ROS -> self
-  //   -> ROS -> KDL -> bullet -> ROS -> bullet
-  tf2::convert(b1, b1);
-  tf2::convert(b1, b2);
-  tf2::convert(b2, k1);
-  tf2::convert(k1, k1);
-  tf2::convert(k1, k2);
-  tf2::convert(k2, r1);
-  tf2::convert(r1, r1);
-  tf2::convert(r1, r2);
-  tf2::convert(r2, k3);
-  tf2::convert(k3, b3);
-  tf2::convert(b3, r3);
-  tf2::convert(r3, b4);
-
-  EXPECT_EQ(b1.frame_id_, b4.frame_id_);
-  EXPECT_NEAR(tf2::timeToSec(b1.stamp_), tf2::timeToSec(b4.stamp_), epsilon);
-  EXPECT_NEAR(b1.x(), b4.x(), epsilon);
-  EXPECT_NEAR(b1.y(), b4.y(), epsilon);
-  EXPECT_NEAR(b1.z(), b4.z(), epsilon);
-}
-
-TEST(tf2Convert, ConvertTf2Quaternion)
-{
-  const tf2::Quaternion tq(1, 2, 3, 4);
-  Eigen::Quaterniond eq;
-  // TODO(gleichdick): switch to tf2::convert() when it's working
-  tf2::fromMsg(tf2::toMsg(tq), eq);
-
-  EXPECT_EQ(tq.w(), eq.w());
-  EXPECT_EQ(tq.x(), eq.x());
-  EXPECT_EQ(tq.y(), eq.y());
-  EXPECT_EQ(tq.z(), eq.z());
-}
-
-TEST(tf2Convert, PointVectorDefaultMessagetype)
-{
-  // Verify the return type of `toMsg()`
-  // as it can return a Vector3 or a Point for certain datatypes
-  {
-    // Bullet
-    const tf2::Stamped<btVector3> b1{btVector3{1.0, 3.0, 4.0}, tf2::TimePoint(), "my_frame"};
-    const geometry_msgs::msg::PointStamped msg = tf2::toMsg(b1);
-
-    EXPECT_EQ(msg.point.x, 1.0);
-    EXPECT_EQ(msg.point.y, 3.0);
-    EXPECT_EQ(msg.point.z, 4.0);
-    EXPECT_EQ(msg.header.frame_id, b1.frame_id_);
-  }
-  {
-    // Eigen
-    const Eigen::Vector3d e1{2.0, 4.0, 5.0};
-    const geometry_msgs::msg::Point msg = tf2::toMsg(e1);
-
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-  {
-    // tf2
-    const tf2::Vector3 t1{2.0, 4.0, 5.0};
-    const geometry_msgs::msg::Vector3 msg = tf2::toMsg(t1);
-
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-  {
-    // KDL
-    const tf2::Stamped<KDL::Vector> k1{KDL::Vector{1.0, 3.0, 4.0}, tf2::TimePoint(), "my_frame"};
-    const geometry_msgs::msg::PointStamped msg = tf2::toMsg(k1);
-
-    EXPECT_EQ(msg.point.x, 1.0);
-    EXPECT_EQ(msg.point.y, 3.0);
-    EXPECT_EQ(msg.point.z, 4.0);
-    EXPECT_EQ(msg.header.frame_id, k1.frame_id_);
-  }
-}
-
-TEST(tf2Convert, PointVectorOtherMessagetype)
-{
-  {
-    const tf2::Vector3 t1{2.0, 4.0, 5.0};
-    geometry_msgs::msg::Point msg;
-    const geometry_msgs::msg::Point & msg2 = tf2::toMsg(t1, msg);
-
-    // returned reference is second argument
-    EXPECT_EQ(&msg2, &msg);
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-  {
-    // Eigen
-    const Eigen::Vector3d e1{2.0, 4.0, 5.0};
-    geometry_msgs::msg::Vector3 msg;
-    const geometry_msgs::msg::Vector3 & msg2 = tf2::toMsg(e1, msg);
-
-    // returned reference is second argument
-    EXPECT_EQ(&msg2, &msg);
-    EXPECT_EQ(msg.x, 2.0);
-    EXPECT_EQ(msg.y, 4.0);
-    EXPECT_EQ(msg.z, 5.0);
-  }
-}
-
-int main(int argc, char ** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/test_convert.py b/test_tf2/test/test_convert.py
deleted file mode 100755
index 988c9baa..00000000
--- a/test_tf2/test/test_convert.py
+++ /dev/null
@@ -1,63 +0,0 @@
-#! /usr/bin/python
-#***********************************************************
-#* Software License Agreement (BSD License)
-#*
-#*  Copyright (c) 2009, Willow Garage, Inc.
-#*  All rights reserved.
-#*
-#*  Redistribution and use in source and binary forms, with or without
-#*  modification, are permitted provided that the following conditions
-#*  are met:
-#*
-#*   * Redistributions of source code must retain the above copyright
-#*     notice, this list of conditions and the following disclaimer.
-#*   * Redistributions in binary form must reproduce the above
-#*     copyright notice, this list of conditions and the following
-#*     disclaimer in the documentation and/or other materials provided
-#*     with the distribution.
-#*   * Neither the name of Willow Garage, Inc. nor the names of its
-#*     contributors may be used to endorse or promote products derived
-#*     from this software without specific prior written permission.
-#*
-#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-#*  POSSIBILITY OF SUCH DAMAGE.
-#*
-#* Author: Eitan Marder-Eppstein
-#***********************************************************
-import sys
-import unittest
-
-import tf2_py as tf2
-import tf2_ros
-import tf2_geometry_msgs
-from geometry_msgs.msg import PointStamped
-import builtin_interfaces
-import rclpy
-import tf2_kdl
-import PyKDL
-
-
-class TestConvert(unittest.TestCase):
-    def test_convert(self):
-        p = tf2_ros.Stamped(PyKDL.Vector(1, 2, 3), builtin_interfaces.msg.Time(sec=0), 'my_frame')
-        msg = tf2_ros.convert(p, PointStamped)
-        p2 = tf2_ros.convert(msg, PyKDL.Vector)
-
-        self.assertEqual(p2[0], p[0])
-        self.assertEqual(p2[1], p[1])
-        self.assertEqual(p2[2], p[2])
-        self.assertEqual(p2.header, p.header)
-
-
-if __name__ == '__main__':
-    unittest.main()
diff --git a/test_tf2/test/test_message_filter.cpp b/test_tf2/test/test_message_filter.cpp
deleted file mode 100644
index fddca0ba..00000000
--- a/test_tf2/test/test_message_filter.cpp
+++ /dev/null
@@ -1,490 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** \author Josh Faust */
-
-#include <functional>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include <gtest/gtest.h>
-
-#include <builtin_interfaces/msg/time.hpp>
-#include <geometry_msgs/msg/point_stamped.hpp>
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rclcpp/rclcpp.hpp>
-#include <tf2/buffer_core.h>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2/LinearMath/Vector3.h>
-#include <tf2/time.h>
-#include <tf2_ros/buffer_interface.h>
-#include <tf2_ros/create_timer_ros.h>
-#include <tf2_ros/message_filter.h>
-
-class Notification
-{
-public:
-  Notification(int expected_count) :
-    count_(0), expected_count_(expected_count), failure_count_(0)
-  {
-  }
-
-  void notify(const geometry_msgs::msg::PointStamped::ConstSharedPtr& message)
-  {
-    (void)message;
-    ++count_;
-  }
-
-  void failure(const geometry_msgs::msg::PointStamped::ConstSharedPtr& message, tf2_ros::filter_failure_reasons::FilterFailureReason reason)
-  {
-    (void)message;
-    (void)reason;
-    ++failure_count_;
-  }
-
-  int count_;
-  int expected_count_;
-  int failure_count_;
-};
-
-TEST(MessageFilter, noTransforms)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  msg->header.frame_id = "frame2";
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_);
-}
-
-TEST(MessageFilter, noTransformsSameFrame)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  msg->header.frame_id = "frame1";
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-geometry_msgs::msg::TransformStamped createTransform(tf2::Quaternion q, tf2::Vector3 v, builtin_interfaces::msg::Time stamp, const std::string& frame1, const std::string& frame2)
-{
-  geometry_msgs::msg::TransformStamped t;
-  t.header.frame_id = frame1;
-  t.child_frame_id = frame2;
-  t.header.stamp = stamp;
-  t.transform.translation.x = v.x();
-  t.transform.translation.y = v.y();
-  t.transform.translation.z = v.z();
-  t.transform.rotation.x = q.x();
-  t.transform.rotation.y = q.y();
-  t.transform.rotation.z = q.z();
-  t.transform.rotation.w = q.w();
-  return t;
-}
-
-TEST(MessageFilter, preexistingTransforms)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-TEST(MessageFilter, postTransforms)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_);
-
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  EXPECT_EQ(1, n.count_);
-}
-
-TEST(MessageFilter, concurrentTransforms)
-{
-  const int messages = 30;
-  const int buffer_size = messages;
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  tf2_ros::Buffer buffer(clock);
-  for (int i = 0; i < 50; i++) {
-    buffer.setCreateTimerInterface(create_timer_interface);
-    tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", buffer_size, node);
-    Notification n(1);
-    filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-    std::thread t([&](){
-      std::this_thread::sleep_for(std::chrono::milliseconds(1));
-      buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-    });
-    for (int j = 0; j < messages; j++) {
-      filter.add(msg);
-    }
-    t.join();
-
-    EXPECT_EQ(messages, n.count_);
-
-    buffer.clear();
-  }
-}
-
-// TODO (ahcorde): For some unknown reason message_filters::Connection registerFailureCallback is disable
-// with #if 0 https://github.com/ros2/geometry2/blob/ros2/tf2_ros/include/tf2_ros/message_filter.h#L463
-// rework this part when this is available
-// TEST(MessageFilter, queueSize)
-// {
-//   auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-//   auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-//     node->get_node_base_interface(),
-//     node->get_node_timers_interface());
-//
-//   rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-//   tf2_ros::Buffer buffer(clock);
-//   buffer.setCreateTimerInterface(create_timer_interface);
-//   tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-//   Notification n(10);
-//
-//   filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-//   // filter.registerFailureCallback(std::bind(&Notification::failure, &n,  std::placeholders::_1,  std::placeholders::_2));
-//
-//   builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-//
-//   for (int i = 0; i < 20; ++i)
-//   {
-//     std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-//     msg->header.stamp = stamp;
-//     msg->header.frame_id = "frame2";
-//
-//     filter.add(msg);
-//   }
-//
-//   EXPECT_EQ(0, n.count_);
-//   EXPECT_EQ(10, n.failure_count_);
-//
-//   buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-//
-//   EXPECT_EQ(10, n.count_);
-//
-//
-// }
-
-TEST(MessageFilter, setTargetFrame)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-  filter.setTargetFrame("frame1000");
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1000", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-TEST(MessageFilter, multipleTargetFrames)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  std::vector<std::string> target_frames;
-  target_frames.push_back("frame1");
-  target_frames.push_back("frame2");
-  filter.setTargetFrames(target_frames);
-
-  builtin_interfaces::msg::Time stamp = tf2_ros::toMsg(tf2::timeFromSec(1));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame3"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame3";
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_); // frame1->frame3 exists, frame2->frame3 does not (yet)
-
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  EXPECT_EQ(1, n.count_); // frame2->frame3 now exists
-}
-
-TEST(MessageFilter, tolerance)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-
-  tf2::Duration offset = tf2::durationFromSec(0.2);
-  filter.setTolerance(offset);
-
-  builtin_interfaces::msg::Time stamp = rclcpp::Time(1, 0);
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-  filter.add(msg);
-
-  EXPECT_EQ(0, n.count_); //No return due to lack of space for offset
-
-  double time_stamp = (stamp.sec + stamp.nanosec/1e9) + tf2::durationToSec(offset)*1.1;
-  builtin_interfaces::msg::Time stamp_transform = rclcpp::Time(static_cast<int32_t>((int)time_stamp), static_cast<uint32_t>((time_stamp - (int)time_stamp)*1e9));
-
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp_transform, "frame1", "frame2"), "me");
-
-  EXPECT_EQ(1, n.count_); // Now have data for the message published earlier
-
-  time_stamp = (stamp.sec + stamp.nanosec/1e9) + tf2::durationToSec(offset);
-
-  msg->header.stamp = rclcpp::Time(static_cast<int64_t>(time_stamp));
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_); // Latest message is off the end of the offset
-}
-
-// TODO(ahcorde): For some unknown reason message_filters::Connection registerFailureCallback is disable
-// with #if 0 https://github.com/ros2/geometry2/blob/ros2/tf2_ros/include/tf2_ros/message_filter.h#L463
-// rework this part when this is available
-
-// TEST(MessageFilter, outTheBackFailure)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, 0);
-//   filter.registerFailureCallback(boost::bind(&Notification::failure, &n, _1, _2));
-//
-//   builtin_interfaces::msg::Time stamp(1);
-//   bc.setTransform(createTransform(Quaternion(0,0,0,1), Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-//   bc.setTransform(createTransform(Quaternion(0,0,0,1), Vector3(1,2,3), stamp + tf2::durationFromSec(10000), "frame1", "frame2"), "me");
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.stamp = stamp;
-//   msg->header.frame_id = "frame2";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(1, n.failure_count_);
-// }
-//
-// TEST(MessageFilter, outTheBackFailure2)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, 0);
-//   filter.registerFailureCallback(boost::bind(&Notification::failure, &n, _1, _2));
-//
-//   builtin_interfaces::msg::Time stamp(1);
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.stamp = stamp;
-//   msg->header.frame_id = "frame2";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(0, n.count_);
-//   EXPECT_EQ(0, n.failure_count_);
-//
-//   bc.setTransform(createTransform(Quaternion(0,0,0,1), Vector3(1,2,3), stamp + tf2::durationFromSec(10000), "frame1", "frame2"), "me");
-//
-//   EXPECT_EQ(1, n.failure_count_);
-// }
-//
-// TEST(MessageFilter, emptyFrameIDFailure)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, 0);
-//   filter.registerFailureCallback(boost::bind(&Notification::failure, &n, _1, _2));
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.frame_id = "";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(1, n.failure_count_);
-// }
-//
-// TEST(MessageFilter, callbackQueue)
-// {
-//   BufferCore bc;
-//   Notification n(1);
-//   ros::CallbackQueue queue;
-//   MessageFilter<geometry_msgs::msg::PointStamped> filter(bc, "frame1", 1, &queue);
-//   filter.registerCallback(boost::bind(&Notification::notify, &n, _1));
-//
-//   geometry_msgs::msg::PointStampedPtr msg(new geometry_msgs::msg::PointStamped);
-//   msg->header.stamp = builtin_interfaces::msg::Time(1);
-//   msg->header.frame_id = "frame1";
-//   filter.add(msg);
-//
-//   EXPECT_EQ(0, n.count_);
-//
-//   queue.callAvailable();
-//
-//   EXPECT_EQ(1, n.count_);
-// }
-
-// See: https://github.com/ros2/geometry2/pull/511
-TEST(MessageFilter, checkStampPrecisionLoss)
-{
-  auto node = rclcpp::Node::make_shared("tf2_ros_message_filter");
-  auto create_timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(
-    node->get_node_base_interface(),
-    node->get_node_timers_interface());
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer buffer(clock);
-  buffer.setCreateTimerInterface(create_timer_interface);
-  tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped> filter(buffer, "frame1", 10, node);
-  Notification n(1);
-  filter.registerCallback(std::bind(&Notification::notify, &n, std::placeholders::_1));
-  filter.setTargetFrame("frame1");
-
-  // Use a large timestamp to trigger potential precision loss if converted to a double somewhere
-  builtin_interfaces::msg::Time stamp(rclcpp::Time(1000000000, 000000001));
-  buffer.setTransform(createTransform(tf2::Quaternion(0,0,0,1), tf2::Vector3(1,2,3), stamp, "frame1", "frame2"), "me");
-
-  std::shared_ptr<geometry_msgs::msg::PointStamped> msg = std::make_shared<geometry_msgs::msg::PointStamped>();
-  msg->header.stamp = stamp;
-  msg->header.frame_id = "frame2";
-
-  filter.add(msg);
-
-  EXPECT_EQ(1, n.count_);
-}
-
-int main(int argc, char** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  int ret = RUN_ALL_TESTS();
-  return ret;
-}
diff --git a/test_tf2/test/test_static_publisher.cpp b/test_tf2/test/test_static_publisher.cpp
deleted file mode 100644
index 731a9e04..00000000
--- a/test_tf2/test/test_static_publisher.cpp
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <chrono>
-#include <functional>
-#include <memory>
-#include <thread>
-
-#include <gtest/gtest.h>
-
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rclcpp/rclcpp.hpp>
-#include <tf2/buffer_core.h>
-#include <tf2/exceptions.h>
-#include <tf2/time.h>
-#include <tf2_ros/buffer.h>
-#include <tf2_ros/buffer_interface.h>
-#include <tf2_ros/static_transform_broadcaster.h>
-#include <tf2_ros/transform_listener.h>
-
-#include "permuter.hpp"
-
-const int MAX_ATTEMPTS = 400;
-
-TEST(StaticTransformPublisher, a_b_different_times)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_b_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-
-  while (!mB.canTransform("a", "b", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  EXPECT_TRUE(mB.canTransform("a", "b", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "b", tf2::timeFromSec(100)));
-  EXPECT_TRUE(mB.canTransform("a", "b", tf2::timeFromSec(1000)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(StaticTransformPublisher, a_c_different_times)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_c_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-  while (!mB.canTransform("a", "c", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(10)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(1000)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(StaticTransformPublisher, a_d_different_times)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_d_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-
-  while (!mB.canTransform("a", "c", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  geometry_msgs::msg::TransformStamped ts;
-  ts.transform.rotation.w = 1;
-  ts.header.frame_id = "c";
-  ts.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10));
-  ts.child_frame_id = "d";
-
-  // make sure listener has populated
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(100)));
-  EXPECT_TRUE(mB.canTransform("a", "c", tf2::timeFromSec(1000)));
-
-  mB.setTransform(ts, "authority");
-  //printf("%s\n", mB.allFramesAsString().c_str());
-  EXPECT_TRUE(mB.canTransform("c", "d", tf2::timeFromSec(10)));
-
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(0)));
-  EXPECT_FALSE(mB.canTransform("a", "d", tf2::timeFromSec(1)));
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(10)));
-  EXPECT_FALSE(mB.canTransform("a", "d", tf2::timeFromSec(1000)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-TEST(StaticTransformPublisher, multiple_parent_test)
-{
-  auto node = rclcpp::Node::make_shared("StaticTransformPublisher_a_d_different_times_test");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf2_ros::Buffer mB(clock);
-  tf2_ros::TransformListener tfl(mB, node, false);
-
-  rclcpp::executors::SingleThreadedExecutor executor;
-  executor.add_node(node);
-  // Start spinning in a thread
-  std::thread spin_thread = std::thread(
-    std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-
-  int attempts = 0;
-
-  while (!mB.canTransform("a", "b", tf2::timeFromSec(0))) {
-    std::this_thread::sleep_for(std::chrono::milliseconds(50));
-    attempts++;
-    if (attempts > MAX_ATTEMPTS) {
-      FAIL();
-    }
-  }
-
-  tf2_ros::StaticTransformBroadcaster stb(node);
-  geometry_msgs::msg::TransformStamped ts;
-  ts.transform.rotation.w = 1;
-  ts.header.frame_id = "c";
-  ts.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(10));
-  ts.child_frame_id = "d";
-
-  stb.sendTransform(ts);
-
-  std::this_thread::sleep_for(std::chrono::milliseconds(200));
-
-  // make sure listener has populated
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(100)));
-  EXPECT_TRUE(mB.canTransform("a", "d", tf2::timeFromSec(1000)));
-
-  // Publish new transform with child 'd', should replace old one in static tf
-  ts.header.frame_id = "new_parent";
-  stb.sendTransform(ts);
-  ts.child_frame_id = "other_child";
-  stb.sendTransform(ts);
-  ts.child_frame_id = "other_child2";
-  stb.sendTransform(ts);
-
-  std::this_thread::sleep_for(std::chrono::milliseconds(200));
-
-  EXPECT_TRUE(mB.canTransform("new_parent", "d", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("new_parent", "other_child", tf2::timeFromSec(0)));
-  EXPECT_TRUE(mB.canTransform("new_parent", "other_child2", tf2::timeFromSec(0)));
-  EXPECT_FALSE(mB.canTransform("a", "d", tf2::timeFromSec(0)));
-
-  executor.cancel();
-  spin_thread.join();
-  node.reset();
-}
-
-// TODO (ahcorde) static_transform_publisher allows to load transforma from yaml files
-// Revisit this test when "Load transform from yaml" is available
-// TEST(StaticTransformPublisher, tf_from_param_server_valid)
-// {
-//   // This TF is loaded from the parameter server; ensure it is valid.
-//   auto node = rclcpp::Node::make_shared("StaticTransformPublisher_tf_from_param_server_valid_test");
-//
-//   rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-//   tf2_ros::Buffer mB(clock);
-//   tf2_ros::TransformListener tfl(mB, node, false);
-//
-//   rclcpp::executors::SingleThreadedExecutor executor;
-//   executor.add_node(node);
-//   // Start spinning in a thread
-//   std::thread spin_thread = std::thread(
-//     std::bind(&rclcpp::executors::SingleThreadedExecutor::spin, &executor));
-//
-//   std::this_thread::sleep_for(std::chrono::milliseconds(200));
-//
-//   EXPECT_TRUE(mB.canTransform("robot_calibration", "world", tf2::timeFromSec(0)));
-//   EXPECT_TRUE(mB.canTransform("robot_calibration", "world", tf2::timeFromSec(100)));
-//   EXPECT_TRUE(mB.canTransform("robot_calibration", "world", tf2::timeFromSec(1000)));
-//
-//   executor.cancel();
-//   spin_thread.join();
-//   node.reset();
-// }
-
-int main(int argc, char **argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/test_tf2/test/test_static_publisher.py b/test_tf2/test/test_static_publisher.py
deleted file mode 100755
index 0869ee06..00000000
--- a/test_tf2/test/test_static_publisher.py
+++ /dev/null
@@ -1,93 +0,0 @@
-#! /usr/bin/python
-#***********************************************************
-#* Software License Agreement (BSD License)
-#*
-#*  Copyright (c) 2016, Felix Duvallet
-#*  All rights reserved.
-#*
-#*  Redistribution and use in source and binary forms, with or without
-#*  modification, are permitted provided that the following conditions
-#*  are met:
-#*
-#*   * Redistributions of source code must retain the above copyright
-#*     notice, this list of conditions and the following disclaimer.
-#*   * Redistributions in binary form must reproduce the above
-#*     copyright notice, this list of conditions and the following
-#*     disclaimer in the documentation and/or other materials provided
-#*     with the distribution.
-#*   * Neither the name of Willow Garage, Inc. nor the names of its
-#*     contributors may be used to endorse or promote products derived
-#*     from this software without specific prior written permission.
-#*
-#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-#*  POSSIBILITY OF SUCH DAMAGE.
-#*
-#* Author: Felix Duvallet
-#***********************************************************
-
-import subprocess
-import unittest
-
-import rclpy
-
-class TestStaticPublisher(unittest.TestCase):
-    """
-    These tests ensure the static transform publisher dies gracefully when
-    provided with an invalid (or non-existent) transform parameter.
-
-    These tests are started by the static_publisher.launch, which loads
-    parameters into the param server.
-
-    We check the output to make sure the correct error is occurring, since the
-    return code is always -1 (255).
-
-    Note that this *could* cause a problem if a valid TF is stored in the param
-    server for one of the names; in this case the subprocess would never return
-    and the test would run forever.
-    """
-
-    def test_publisher_no_args(self):
-        # Start the publisher with no argument.
-        cmd = 'ros2 run tf2_ros static_transform_publisher'
-        with self.assertRaises(subprocess.CalledProcessError) as cm:
-            ret = subprocess.check_output(
-                cmd.split(' '), stderr=subprocess.STDOUT)
-        self.assertEqual(255, cm.exception.returncode)
-        self.assertIn('not having the right number of arguments',
-                      str(cm.exception.output))
-
-    def test_publisher_nonexistent_param(self):
-        # Here there is no paramater by that name.
-        cmd = 'ros2 run tf2_ros static_transform_publisher /test_tf2/tf_null'
-        with self.assertRaises(subprocess.CalledProcessError) as cm:
-            ret = subprocess.check_output(
-                cmd.split(' '), stderr=subprocess.STDOUT)
-
-        self.assertEqual(255, cm.exception.returncode)
-        self.assertIn('not having the right number of arguments',
-                      str(cm.exception.output))
-
-    def test_publisher_invalid_param(self):
-        # Here there is an invalid parameter stored in the parameter server.
-        cmd = 'ros2 run tf2_ros static_transform_publisher /test_tf2/tf_invalid'
-        with self.assertRaises(subprocess.CalledProcessError) as cm:
-            ret = subprocess.check_output(
-                cmd.split(' '), stderr=subprocess.STDOUT)
-
-        self.assertEqual(255, cm.exception.returncode)
-        self.assertIn('exited due to not having the right number', str(cm.exception.output))
-
-
-if __name__ == '__main__':
-    rclpy.init(args=None)
-    unittest.main()
diff --git a/test_tf2/test/test_tf2_bullet.cpp b/test_tf2/test/test_tf2_bullet.cpp
deleted file mode 100644
index 1b71d13b..00000000
--- a/test_tf2/test/test_tf2_bullet.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** \author Wim Meeussen */
-
-#include <tf2_bullet/tf2_bullet.hpp>
-#include <tf2_ros/buffer.h>
-#include <rclcpp/rclcpp.hpp>
-#include <gtest/gtest.h>
-#include <tf2/convert.h>
-
-std::unique_ptr<tf2_ros::Buffer> tf_buffer = nullptr;
-static const double EPS = 1e-3;
-
-TEST(TfBullet, Transform)
-{
-  tf2::Stamped<btTransform> v1(btTransform(btQuaternion(1,0,0,0), btVector3(1,2,3)), tf2::timeFromSec(2.0), "A");
-
-  // simple api
-  btTransform v_simple = tf_buffer->transform(v1, "B", tf2::durationFromSec(2.0));
-  EXPECT_NEAR(v_simple.getOrigin().getX(), -9, EPS);
-  EXPECT_NEAR(v_simple.getOrigin().getY(), 18, EPS);
-  EXPECT_NEAR(v_simple.getOrigin().getZ(), 27, EPS);
-
-  // advanced api
-  btTransform v_advanced = tf_buffer->transform(v1, "B", tf2::timeFromSec(2.0),
-					       "B", tf2::durationFromSec(3.0));
-  EXPECT_NEAR(v_advanced.getOrigin().getX(), -9, EPS);
-  EXPECT_NEAR(v_advanced.getOrigin().getY(), 18, EPS);
-  EXPECT_NEAR(v_advanced.getOrigin().getZ(), 27, EPS);
-}
-
-TEST(TfBullet, Vector)
-{
-  tf2::Stamped<btVector3>  v1(btVector3(1,2,3), tf2::timeFromSec(2.0), "A");
-
-  // simple api
-  btVector3 v_simple = tf_buffer->transform(v1, "B", tf2::durationFromSec(2.0));
-  EXPECT_NEAR(v_simple.getX(), -9, EPS);
-  EXPECT_NEAR(v_simple.getY(), 18, EPS);
-  EXPECT_NEAR(v_simple.getZ(), 27, EPS);
-
-  // advanced api
-  btVector3 v_advanced = tf_buffer->transform(v1, "B", tf2::timeFromSec(2.0),
-  					     "B", tf2::durationFromSec(3.0));
-  EXPECT_NEAR(v_advanced.getX(), -9, EPS);
-  EXPECT_NEAR(v_advanced.getY(), 18, EPS);
-  EXPECT_NEAR(v_advanced.getZ(), 27, EPS);
-}
-
-int main(int argc, char **argv){
-  testing::InitGoogleTest(&argc, argv);
-  rclcpp::init(argc, argv);
-
-  auto node = rclcpp::Node::make_shared("test_tf2_bullet");
-
-  rclcpp::Clock::SharedPtr clock = std::make_shared<rclcpp::Clock>(RCL_SYSTEM_TIME);
-  tf_buffer = std::make_unique<tf2_ros::Buffer>(clock);
-
-  // populate buffer
-  geometry_msgs::msg::TransformStamped t;
-  t.transform.translation.x = 10;
-  t.transform.translation.y = 20;
-  t.transform.translation.z = 30;
-  t.transform.rotation.w = 0;
-  t.transform.rotation.x = 1;
-  t.transform.rotation.y = 0;
-  t.transform.rotation.z = 0;
-  t.header.stamp = tf2_ros::toMsg(tf2::timeFromSec(2));
-  t.header.frame_id = "A";
-  t.child_frame_id = "B";
-  tf_buffer->setTransform(t, "test");
-
-  int ret = RUN_ALL_TESTS();
-  rclcpp::shutdown();
-  return ret;
-}
diff --git a/test_tf2/test/test_tf2_bullet.launch b/test_tf2/test/test_tf2_bullet.launch
deleted file mode 100644
index 3ab2701c..00000000
--- a/test_tf2/test/test_tf2_bullet.launch
+++ /dev/null
@@ -1,3 +0,0 @@
-<launch>
-  <test test-name="test_tf_bullet" pkg="tf2_bullet" type="test_bullet" time-limit="120" />
-</launch>
\ No newline at end of file
diff --git a/test_tf2/test/test_tf_invalid.yaml b/test_tf2/test/test_tf_invalid.yaml
deleted file mode 100644
index 0cb8bb6d..00000000
--- a/test_tf2/test/test_tf_invalid.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
-# This is not a valid TF.
-
-child_frame_id: calibration
-some_data:
-    - 1
-    - 2
-    - 3
diff --git a/test_tf2/test/test_tf_valid.yaml b/test_tf2/test/test_tf_valid.yaml
deleted file mode 100644
index 33a8b2d0..00000000
--- a/test_tf2/test/test_tf_valid.yaml
+++ /dev/null
@@ -1,17 +0,0 @@
-header:
-  seq: 0
-  stamp:
-    secs: 1619
-    nsecs: 601000000
-  frame_id: world
-child_frame_id: robot_calibration
-transform:
-  translation:
-    x: 0.75
-    y: 0.5
-    z: 1.0
-  rotation:
-    x: -0.62908825919
-    y: 0.210952809338
-    z: 0.640171445021
-    w: 0.38720459109
diff --git a/test_tf2/test/test_utils.cpp b/test_tf2/test/test_utils.cpp
deleted file mode 100644
index 6aa2394c..00000000
--- a/test_tf2/test/test_utils.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-// Copyright 2014 Open Source Robotics Foundation, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <gtest/gtest.h>
-
-#include <geometry_msgs/msg/quaternion.hpp>
-#include <geometry_msgs/msg/quaternion_stamped.hpp>
-#include <geometry_msgs/msg/transform.hpp>
-#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
-#include <tf2/LinearMath/Quaternion.h>
-#include <tf2/utils.h>
-#include <tf2_kdl/tf2_kdl.hpp>
-
-double epsilon = 1e-9;
-
-template<typename T>
-void yprTest(const T& t, double yaw1, double pitch1, double roll1) {
-  double yaw2, pitch2, roll2;
-
-  tf2::getEulerYPR(t, yaw2, pitch2, roll2);
-
-  EXPECT_NEAR(yaw1, yaw2, epsilon);
-  EXPECT_NEAR(pitch1, pitch2, epsilon);
-  EXPECT_NEAR(roll1, roll2, epsilon);
-  EXPECT_NEAR(tf2::getYaw(t), yaw1, epsilon);
-}
-
-TEST(tf2Utils, yaw)
-{
-  double x, y, z, w;
-  x = 0.4;
-  y = 0.5;
-  z = 0.6;
-  w = 0.7;
-
-  double yaw1, pitch1, roll1;
-  // Compute results one way with KDL
-  KDL::Rotation::Quaternion(x, y, z, w).GetRPY(roll1, pitch1, yaw1);
-  {
-    // geometry_msgs::msg::Quaternion
-    geometry_msgs::msg::Quaternion q;
-    q.x = x; q.y =y; q.z = z; q.w = w;
-    yprTest(q, yaw1, pitch1, roll1);
-
-    // geometry_msgs::msg::QuaternionStamped
-    geometry_msgs::msg::QuaternionStamped qst;
-    qst.quaternion = q;
-    yprTest(qst, yaw1, pitch1, roll1);
-  }
-
-
-  {
-    // tf2::Quaternion
-    tf2::Quaternion q(x, y, z, w);
-    yprTest(q, yaw1, pitch1, roll1);
-
-    // TODO (ahcorde): This PR fix this issue https://github.com/ros/geometry2/pull/357
-    // // tf2::Stamped<tf2::Quaternion>
-    // tf2::Stamped<tf2::Quaternion> sq;
-    // sq.setData(q);
-    // yprTest(sq, yaw1, pitch1, roll1);
-  }
-}
-
-TEST(tf2Utils, identity)
-{
-  geometry_msgs::msg::Transform t;
-  t.translation.x = 0.1;
-  t.translation.y = 0.2;
-  t.translation.z = 0.3;
-  t.rotation.x = 0.4;
-  t.rotation.y = 0.5;
-  t.rotation.z = 0.6;
-  t.rotation.w = 0.7;
-
-  // Test identity
-  t = tf2::getTransformIdentity<geometry_msgs::msg::Transform>();
-
-  EXPECT_EQ(t.translation.x, 0);
-  EXPECT_EQ(t.translation.y, 0);
-  EXPECT_EQ(t.translation.z, 0);
-  EXPECT_EQ(t.rotation.x, 0);
-  EXPECT_EQ(t.rotation.y, 0);
-  EXPECT_EQ(t.rotation.z, 0);
-  EXPECT_EQ(t.rotation.w, 1);
-}
-
-int main(int argc, char** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  return RUN_ALL_TESTS();
-}
diff --git a/tf2/CMakeLists.txt b/tf2/CMakeLists.txt
index afb90fb6..d386533b 100644
--- a/tf2/CMakeLists.txt
+++ b/tf2/CMakeLists.txt
@@ -21,7 +21,7 @@ find_package(rosidl_runtime_cpp REQUIRED)
 # export user definitions
 
 #CPP Libraries
-add_library(tf2 SHARED src/cache.cpp src/buffer_core.cpp src/static_cache.cpp src/time.cpp)
+add_library(tf2 SHARED src/cache.cpp src/static_cache.cpp src/time.cpp)
 target_include_directories(tf2 PUBLIC
   "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
   "$<INSTALL_INTERFACE:include/${PROJECT_NAME}>")
diff --git a/tf2/include/tf2/buffer_core.h b/tf2/include/tf2/buffer_core.h
index b8eb7fe4..724c38b0 100644
--- a/tf2/include/tf2/buffer_core.h
+++ b/tf2/include/tf2/buffer_core.h
@@ -33,7 +33,6 @@
 #define TF2__BUFFER_CORE_H_
 
 #include <algorithm>
-#include <chrono>
 #include <cmath>
 #include <functional>
 #include <map>
@@ -51,6 +50,65 @@
 #include "tf2/transform_storage.h"
 #include "tf2/visibility_control.h"
 
+#include <cassert>
+#include <chrono>
+#ifdef _WIN32
+#include <xmemory>
+#endif
+
+#include "tf2/time_cache.h"
+#include "tf2/exceptions.h"
+
+// #include "console_bridge/console.h"
+#include "tf2/LinearMath/Quaternion.h"
+#include "tf2/LinearMath/Transform.h"
+#include "tf2/LinearMath/Vector3.h"
+
+#include "builtin_interfaces/msg/time.hpp"
+#include "geometry_msgs/msg/transform.hpp"
+#include "geometry_msgs/msg/transform_stamped.hpp"
+
+namespace
+{
+  // Tolerance for acceptable quaternion normalization
+  constexpr static double QUATERNION_NORMALIZATION_TOLERANCE = 10e-3;
+
+  bool startsWithSlash(const std::string & frame_id)
+  {
+    if (frame_id.size() > 0) {
+      if (frame_id[0] == '/') {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  std::string stripSlash(const std::string & in)
+  {
+    std::string out = in;
+    if (startsWithSlash(in)) {
+      out.erase(0, 1);
+    }
+    return out;
+  }
+
+  void fillOrWarnMessageForInvalidFrame(
+    const char * function_name_arg,
+    const std::string & frame_id,
+    std::string * error_msg,
+    const char * rationale)
+  {
+    std::string s = "Invalid frame ID \"" + frame_id +
+      "\" passed to " + function_name_arg + " - " + rationale;
+    if (error_msg != nullptr) {
+      *error_msg = s;
+    } else {
+      // CONSOLE_BRIDGE_logWarn("%s", s.c_str());
+    }
+  }
+
+}  // anonymous namespace
+
 namespace tf2
 {
 
@@ -65,10 +123,128 @@ enum TransformableResult
   TransformAvailable,
   TransformFailure,
 };
+  
+enum WalkEnding
+{
+  Identity,
+  TargetParentOfSource,
+  SourceParentOfTarget,
+  FullPath,
+};
 
+  
 //!< The default amount of time to cache data in seconds
 static constexpr Duration BUFFER_CORE_DEFAULT_CACHE_TIME = std::chrono::seconds(10);
 
+struct TransformAccum
+{
+  TransformAccum()
+  : source_to_top_quat(0.0, 0.0, 0.0, 1.0),
+    source_to_top_vec(0.0, 0.0, 0.0),
+    target_to_top_quat(0.0, 0.0, 0.0, 1.0),
+    target_to_top_vec(0.0, 0.0, 0.0),
+    result_quat(0.0, 0.0, 0.0, 1.0),
+    result_vec(0.0, 0.0, 0.0)
+  {
+  }
+
+  CompactFrameID gather(TimeCacheInterfacePtr cache, TimePoint _time, std::string * error_string)
+  {
+    if (!cache->getData(_time, st, error_string)) {
+      return 0;
+    }
+
+    return st.frame_id_;
+  }
+
+  void accum(bool source)
+  {
+    if (source) {
+      source_to_top_vec = quatRotate(st.rotation_, source_to_top_vec) + st.translation_;
+      source_to_top_quat = st.rotation_ * source_to_top_quat;
+    } else {
+      target_to_top_vec = quatRotate(st.rotation_, target_to_top_vec) + st.translation_;
+      target_to_top_quat = st.rotation_ * target_to_top_quat;
+    }
+  }
+
+  void finalize(WalkEnding end, TimePoint _time)
+  {
+    switch (end) {
+      case Identity:
+        break;
+      case TargetParentOfSource:
+        result_vec = source_to_top_vec;
+        result_quat = source_to_top_quat;
+        break;
+      case SourceParentOfTarget:
+        {
+          tf2::Quaternion inv_target_quat = target_to_top_quat.inverse();
+          tf2::Vector3 inv_target_vec = quatRotate(inv_target_quat, -target_to_top_vec);
+          result_vec = inv_target_vec;
+          result_quat = inv_target_quat;
+          break;
+        }
+      case FullPath:
+        {
+          tf2::Quaternion inv_target_quat = target_to_top_quat.inverse();
+          tf2::Vector3 inv_target_vec = quatRotate(inv_target_quat, -target_to_top_vec);
+
+          result_vec = quatRotate(inv_target_quat, source_to_top_vec) + inv_target_vec;
+          result_quat = inv_target_quat * source_to_top_quat;
+        }
+        break;
+    }
+
+    time = _time;
+  }
+
+  TransformStorage st;
+  TimePoint time;
+  tf2::Quaternion source_to_top_quat;
+  tf2::Vector3 source_to_top_vec;
+  tf2::Quaternion target_to_top_quat;
+  tf2::Vector3 target_to_top_vec;
+
+  tf2::Quaternion result_quat;
+  tf2::Vector3 result_vec;
+};
+
+struct CanTransformAccum
+{
+  CompactFrameID gather(TimeCacheInterfacePtr cache, TimePoint time, std::string * error_string)
+  {
+    return cache->getParent(time, error_string);
+  }
+
+  void accum(bool source)
+  {
+    (void)source;
+  }
+
+  void finalize(WalkEnding end, TimePoint _time)
+  {
+    (void)end;
+    (void)_time;
+  }
+
+  TransformStorage st;
+};
+
+struct TimeAndFrameIDFrameComparator
+{
+  explicit TimeAndFrameIDFrameComparator(CompactFrameID id)
+  : id(id)
+  {}
+
+  bool operator()(const P_TimeAndFrameID & rhs) const
+  {
+    return rhs.second == id;
+  }
+
+  CompactFrameID id;
+};
+  
 /** \brief A Class which provides coordinate transforms between any two frames in a system.
  *
  * This class provides a simple interface to allow recording and lookup of
@@ -87,7 +263,8 @@ static constexpr Duration BUFFER_CORE_DEFAULT_CACHE_TIME = std::chrono::seconds(
  *
  * All function calls which pass frame ids can potentially throw the exception tf::LookupException
  */
-class BufferCore : public BufferCoreInterface
+template <typename AllocatorT = std::allocator<void>>
+class BufferCore : public BufferCoreInterface<AllocatorT>
 {
 public:
   /************* Constants ***********************/
@@ -100,15 +277,33 @@ public:
    * \param cache_time How long to keep a history of transforms in nanoseconds
    *
    */
-  TF2_PUBLIC
-  explicit BufferCore(tf2::Duration cache_time_ = BUFFER_CORE_DEFAULT_CACHE_TIME);
+  explicit BufferCore(tf2::Duration cache_time = BUFFER_CORE_DEFAULT_CACHE_TIME)
+	: cache_time_(cache_time),
+	  transformable_callbacks_counter_(0),
+	  transformable_requests_counter_(0),
+	  using_dedicated_thread_(false)
+  {
+  	frameIDs_["NO_PARENT"] = 0;
+  	frames_.push_back(TimeCacheInterfacePtr());
+  	frameIDs_reverse_.push_back("NO_PARENT");
+  }
 
-  TF2_PUBLIC
-  virtual ~BufferCore(void);
+  virtual ~BufferCore(void) {}
 
   /** \brief Clear all data */
-  TF2_PUBLIC
-  void clear() override;
+  void clear() override
+  {
+  	std::unique_lock<std::mutex> lock(frame_mutex_);
+  	if (frames_.size() > 1) {
+  		for (std::vector<TimeCacheInterfacePtr>::iterator cache_it = frames_.begin() + 1;
+			cache_it != frames_.end(); ++cache_it)
+  		{
+  			if (*cache_it) {
+  				(*cache_it)->clearList();
+  			}
+  		}
+  	}
+  }
 
   /** \brief Add transform information to the tf data structure
    * \param transform The transform to store
@@ -116,13 +311,29 @@ public:
    * \param is_static Record this transform as a static transform.  It will be good across all time.  (This cannot be changed after the first call.)
    * \return True unless an error occured
    */
-  TF2_PUBLIC
   bool setTransform(
-    const geometry_msgs::msg::TransformStamped & transform,
-    const std::string & authority, bool is_static = false);
+    const geometry_msgs::msg::TransformStamped_<AllocatorT> & transform,
+    const std::string & authority, bool is_static = false)
+  {
+  	tf2::Transform tf2_transform(tf2::Quaternion(
+		  transform.transform.rotation.x,
+		  transform.transform.rotation.y,
+		  transform.transform.rotation.z,
+		  transform.transform.rotation.w),
+		tf2::Vector3(
+		  transform.transform.translation.x,
+		  transform.transform.translation.y,
+		  transform.transform.translation.z));
+  	TimePoint time_point(std::chrono::nanoseconds(transform.header.stamp.nanosec) +
+		std::chrono::duration_cast<std::chrono::nanoseconds>(
+		  std::chrono::seconds(
+			transform.header.stamp.sec)));
+  	return setTransformImpl(
+		tf2_transform, transform.header.frame_id, transform.child_frame_id,
+		time_point, authority, is_static);
+  }
 
   /*********** Accessors *************/
-
   /** \brief Get the transform between two frames by frame ID.
    * \param target_frame The frame to which data should be transformed
    * \param source_frame The frame where the data originated
@@ -132,11 +343,33 @@ public:
    * Possible exceptions tf2::LookupException, tf2::ConnectivityException,
    * tf2::ExtrapolationException, tf2::InvalidArgumentException
    */
-  TF2_PUBLIC
-  geometry_msgs::msg::TransformStamped
+  geometry_msgs::msg::TransformStamped_<AllocatorT>
   lookupTransform(
     const std::string & target_frame, const std::string & source_frame,
-    const TimePoint & time) const override;
+    const TimePoint & time) const override
+  {
+    tf2::Transform transform;
+    TimePoint time_out;
+    lookupTransformImpl(target_frame, source_frame, time, transform, time_out);
+    geometry_msgs::msg::TransformStamped_<AllocatorT> msg;
+    msg.transform.translation.x = transform.getOrigin().x();
+    msg.transform.translation.y = transform.getOrigin().y();
+    msg.transform.translation.z = transform.getOrigin().z();
+    msg.transform.rotation.x = transform.getRotation().x();
+    msg.transform.rotation.y = transform.getRotation().y();
+    msg.transform.rotation.z = transform.getRotation().z();
+    msg.transform.rotation.w = transform.getRotation().w();
+    std::chrono::nanoseconds ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
+      time_out.time_since_epoch());
+    std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(
+      time_out.time_since_epoch());
+    msg.header.stamp.sec = static_cast<int32_t>(s.count());
+    msg.header.stamp.nanosec = static_cast<uint32_t>(ns.count() % 1000000000ull);
+    msg.header.frame_id = target_frame;
+    msg.child_frame_id = source_frame;
+
+    return msg;
+  }
 
   /** \brief Get the transform between two frames by frame ID assuming fixed frame.
    * \param target_frame The frame to which data should be transformed
@@ -150,12 +383,36 @@ public:
    * tf2::ExtrapolationException, tf2::InvalidArgumentException
    */
 
-  TF2_PUBLIC
-  geometry_msgs::msg::TransformStamped
+  geometry_msgs::msg::TransformStamped_<AllocatorT>
   lookupTransform(
     const std::string & target_frame, const TimePoint & target_time,
     const std::string & source_frame, const TimePoint & source_time,
-    const std::string & fixed_frame) const override;
+    const std::string & fixed_frame) const override
+  {
+    tf2::Transform transform;
+    TimePoint time_out;
+    lookupTransformImpl(
+      target_frame, target_time, source_frame, source_time,
+      fixed_frame, transform, time_out);
+    geometry_msgs::msg::TransformStamped_<AllocatorT> msg;
+    msg.transform.translation.x = transform.getOrigin().x();
+    msg.transform.translation.y = transform.getOrigin().y();
+    msg.transform.translation.z = transform.getOrigin().z();
+    msg.transform.rotation.x = transform.getRotation().x();
+    msg.transform.rotation.y = transform.getRotation().y();
+    msg.transform.rotation.z = transform.getRotation().z();
+    msg.transform.rotation.w = transform.getRotation().w();
+    std::chrono::nanoseconds ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
+      time_out.time_since_epoch());
+    std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(
+      time_out.time_since_epoch());
+    msg.header.stamp.sec = static_cast<int32_t>(s.count());
+    msg.header.stamp.nanosec = static_cast<uint32_t>(ns.count() % 1000000000ull);
+    msg.header.frame_id = target_frame;
+    msg.child_frame_id = source_frame;
+
+    return msg;
+  }
 
   /** \brief Test if a transform is possible
    * \param target_frame The frame into which to transform
@@ -164,10 +421,28 @@ public:
    * \param error_msg A pointer to a string which will be filled with why the transform failed, if not nullptr
    * \return True if the transform is possible, false otherwise
    */
-  TF2_PUBLIC
   bool canTransform(
     const std::string & target_frame, const std::string & source_frame,
-    const TimePoint & time, std::string * error_msg = nullptr) const override;
+    const TimePoint & time, std::string * error_msg = nullptr) const override
+  {
+    // Short circuit if target_frame == source_frame
+    if (target_frame == source_frame) {
+      return true;
+    }
+
+    CompactFrameID target_id = validateFrameId(
+      "canTransform argument target_frame", target_frame, error_msg);
+    if (target_id == 0) {
+      return false;
+    }
+    CompactFrameID source_id = validateFrameId(
+      "canTransform argument source_frame", source_frame, error_msg);
+    if (source_id == 0) {
+      return false;
+    }
+
+    return canTransformInternal(target_id, source_id, time, error_msg);
+  }
 
   /** \brief Test if a transform is possible
    * \param target_frame The frame into which to transform
@@ -178,33 +453,127 @@ public:
    * \param error_msg A pointer to a string which will be filled with why the transform failed, if not nullptr
    * \return True if the transform is possible, false otherwise
    */
-  TF2_PUBLIC
   bool canTransform(
     const std::string & target_frame, const TimePoint & target_time,
     const std::string & source_frame, const TimePoint & source_time,
-    const std::string & fixed_frame, std::string * error_msg = nullptr) const override;
+    const std::string & fixed_frame, std::string * error_msg = nullptr) const override
+  {
+    CompactFrameID target_id = validateFrameId(
+  "canTransform argument target_frame", target_frame, error_msg);
+    if (target_id == 0) {
+      return false;
+    }
+    CompactFrameID source_id = validateFrameId(
+      "canTransform argument source_frame", source_frame, error_msg);
+    if (source_id == 0) {
+      return false;
+    }
+    CompactFrameID fixed_id = validateFrameId(
+      "canTransform argument fixed_frame", fixed_frame, error_msg);
+    if (fixed_id == 0) {
+      return false;
+    }
+
+    return
+      canTransformInternal(target_id, fixed_id, target_time, error_msg) &&
+      canTransformInternal(fixed_id, source_id, source_time, error_msg);
+  }
 
   /** \brief Get all frames that exist in the system.
    */
-  TF2_PUBLIC
-  std::vector<std::string> getAllFrameNames() const override;
+  std::vector<std::string> getAllFrameNames() const override
+  {
+    std::vector<std::string> frames;
+    _getFrameStrings(frames);
+    return frames;
+  }
 
   /** \brief A way to see what frames have been cached in yaml format
    * Useful for debugging tools
    */
-  TF2_PUBLIC
-  std::string allFramesAsYAML(TimePoint current_time) const;
+  std::string allFramesAsYAML(TimePoint current_time) const
+  {
+    std::stringstream mstream;
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+  
+    TransformStorage temp;
+  
+    if (frames_.size() == 1) {
+      mstream << "[]";
+    }
+  
+    mstream.precision(3);
+    mstream.setf(std::ios::fixed, std::ios::floatfield);
+  
+    // one referenced for 0 is no frame
+    for (size_t counter = 1; counter < frames_.size(); counter++) {
+      CompactFrameID cfid = static_cast<CompactFrameID>(counter);
+      CompactFrameID frame_id_num;
+      TimeCacheInterfacePtr cache = getFrame(cfid);
+      if (!cache) {
+        continue;
+      }
+  
+      if (!cache->getData(TimePointZero, temp)) {
+        continue;
+      }
+  
+      frame_id_num = temp.frame_id_;
+  
+      std::string authority = "no recorded authority";
+      std::map<CompactFrameID, std::string>::const_iterator it = frame_authority_.find(cfid);
+      if (it != frame_authority_.end()) {
+        authority = it->second;
+      }
+  
+      tf2::Duration dur1 = cache->getLatestTimestamp() - cache->getOldestTimestamp();
+      tf2::Duration dur2 = tf2::Duration(std::chrono::microseconds(100));
+  
+      double rate;
+      if (dur1 > dur2) {
+        rate = (cache->getListLength() * 1e9) / std::chrono::duration_cast<std::chrono::nanoseconds>(
+          dur1).count();
+      } else {
+        rate = (cache->getListLength() * 1e9) / std::chrono::duration_cast<std::chrono::nanoseconds>(
+          dur2).count();
+      }
+  
+      mstream << std::fixed;  // fixed point notation
+      mstream.precision(3);  // 3 decimal places
+      mstream << frameIDs_reverse_[cfid] << ": " << std::endl;
+      mstream << "  parent: '" << frameIDs_reverse_[frame_id_num] << "'" << std::endl;
+      mstream << "  broadcaster: '" << authority << "'" << std::endl;
+      mstream << "  rate: " << rate << std::endl;
+      mstream << "  most_recent_transform: " << displayTimePoint(cache->getLatestTimestamp()) <<
+        std::endl;
+      mstream << "  oldest_transform: " << displayTimePoint(cache->getOldestTimestamp()) << std::endl;
+      if (current_time != TimePointZero) {
+        mstream << "  transform_delay: " <<
+          durationToSec(current_time - cache->getLatestTimestamp()) << std::endl;
+      }
+      mstream << "  buffer_length: " << durationToSec(
+        cache->getLatestTimestamp() - cache->getOldestTimestamp()) << std::endl;
+    }
+  
+    return mstream.str();
+  }
+
 
   /** Backwards compatibility for #84
   */
-  TF2_PUBLIC
-  std::string allFramesAsYAML() const;
+  std::string allFramesAsYAML() const
+  {
+    return this->allFramesAsYAML(TimePointZero);
+  }
 
   /** \brief A way to see what frames have been cached
    * Useful for debugging
    */
-  TF2_PUBLIC
-  std::string allFramesAsString() const;
+  std::string allFramesAsString() const
+  {
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+    return this->allFramesAsStringNoLock();
+  }
 
   using TransformableCallback = std::function<
     void (TransformableRequestHandle request_handle, const std::string & target_frame,
@@ -212,23 +581,121 @@ public:
     TimePoint time, TransformableResult result)>;
 
   /// \brief Internal use only
-  TF2_PUBLIC
   TransformableRequestHandle addTransformableRequest(
     const TransformableCallback & cb,
     const std::string & target_frame,
     const std::string & source_frame,
-    TimePoint time);
+    TimePoint time)
+  {
+    // shortcut if target == source
+    if (target_frame == source_frame) {
+      return 0;
+    }
+  
+    // Even though we only modify transformable_requests_ at the end of the
+    // method, we still need to take the lock near the beginning.  This is to
+    // ensure that we don't have a TOCTTOU race between this method and
+    // testTransformableRequests.  If the lock were only at the end of this
+    // method, the race occurs like this:
+    //
+    // T1: addTransformableRequest, determines that needs to add to transformable_requests_
+    // T2: in testTransformableRequests already, holding the lock
+    // T1: blocked getting lock
+    // T2: calls all callbacks for outstanding transforms (doesn't include the current one)
+    // T2: unlocks
+    // T1: gets lock, adds to list
+    //
+    // If nothing ever calls setTransform() again, then the callback for the
+    // current request will never get called.  We fix this by holding the mutex
+    // across most of this method.
+    std::unique_lock<std::mutex> lock(transformable_requests_mutex_);
+  
+    TransformableRequest req;
+    req.target_id = lookupFrameNumber(target_frame);
+    req.source_id = lookupFrameNumber(source_frame);
+  
+    // First check if the request is already transformable.  If it is, return immediately
+    if (canTransformInternal(req.target_id, req.source_id, time, 0)) {
+      return 0;
+    }
+  
+    // Might not be transformable at all, ever (if it's too far in the past)
+    if (req.target_id && req.source_id) {
+      TimePoint latest_time;
+      // TODO(anyone): This is incorrect, but better than nothing.  Really we want the latest time for
+      // any of the frames
+      getLatestCommonTime(req.target_id, req.source_id, latest_time, 0);
+      if ((latest_time != TimePointZero) && (time + cache_time_ < latest_time)) {
+        return 0xffffffffffffffffULL;
+      }
+    }
+  
+    {
+      std::unique_lock<std::mutex> lock(transformable_callbacks_mutex_);
+      TransformableCallbackHandle handle = ++transformable_callbacks_counter_;
+      while (!transformable_callbacks_.insert(std::make_pair(handle, cb)).second) {
+        handle = ++transformable_callbacks_counter_;
+      }
+  
+      req.cb_handle = handle;
+    }
+  
+    req.time = time;
+    req.request_handle = ++transformable_requests_counter_;
+    if (req.request_handle == 0 || req.request_handle == 0xffffffffffffffffULL) {
+      req.request_handle = 1;
+    }
+  
+    if (req.target_id == 0) {
+      req.target_string = target_frame;
+    }
+  
+    if (req.source_id == 0) {
+      req.source_string = source_frame;
+    }
+  
+    transformable_requests_.push_back(req);
+  
+    return req.request_handle;
+  }
+
+  typedef uint32_t TransformableCallbackHandle;
+
+  typedef std::unordered_map<TransformableCallbackHandle,
+      TransformableCallback> M_TransformableCallback;
+  
+  struct TransformableRequest
+  {
+    TimePoint time;
+    TransformableRequestHandle request_handle;
+    TransformableCallbackHandle cb_handle;
+    CompactFrameID target_id;
+    CompactFrameID source_id;
+    std::string target_string;
+    std::string source_string;
+  };
+
   /// \brief Internal use only
-  TF2_PUBLIC
-  void cancelTransformableRequest(TransformableRequestHandle handle);
+  void cancelTransformableRequest(TransformableRequestHandle handle)
+  {
+    std::unique_lock<std::mutex> tr_lock(transformable_requests_mutex_);
+    std::unique_lock<std::mutex> tc_lock(transformable_callbacks_mutex_);
+
+    typename std::vector<TransformableRequest>::iterator remove_it = std::remove_if(
+      transformable_requests_.begin(), transformable_requests_.end(),
+      [handle](TransformableRequest req) {return handle == req.request_handle;});
+    for (typename std::vector<TransformableRequest>::iterator it = remove_it; it != transformable_requests_.end(); ++it) {
+      transformable_callbacks_.erase(it->cb_handle);
+    }
+
+    transformable_requests_.erase(remove_it, transformable_requests_.end());
+  }
 
 
   // Tell the buffer that there are multiple threads servicing it.
   // This is useful for derived classes to know if they can block or not.
-  TF2_PUBLIC
   void setUsingDedicatedThread(bool value) {using_dedicated_thread_ = value;}
   // Get the state of using_dedicated_thread_
-  TF2_PUBLIC
   bool isUsingDedicatedThread() const {return using_dedicated_thread_;}
 
 
@@ -237,33 +704,59 @@ public:
 
   /**@brief Check if a frame exists in the tree
    * @param frame_id_str The frame id in question  */
-  TF2_PUBLIC
-  bool _frameExists(const std::string & frame_id_str) const;
+  bool _frameExists(const std::string & frame_id_str) const
+  {
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+    return frameIDs_.count(frame_id_str) != 0;
+  }
 
   /**@brief Fill the parent of a frame.
    * @param frame_id The frame id of the frame in question
    * @param parent The reference to the string to fill the parent
    * Returns true unless "NO_PARENT" */
-  TF2_PUBLIC
-  bool _getParent(const std::string & frame_id, TimePoint time, std::string & parent) const;
+  bool _getParent(const std::string & frame_id, TimePoint time, std::string & parent) const
+  {
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+    CompactFrameID frame_number = lookupFrameNumber(frame_id);
+    TimeCacheInterfacePtr frame = getFrame(frame_number);
+  
+    if (!frame) {
+      return false;
+    }
+  
+    CompactFrameID parent_id = frame->getParent(time, nullptr);
+    if (parent_id == 0) {
+      return false;
+    }
+  
+    parent = lookupFrameString(parent_id);
+    return true;
+  }
 
   /** \brief A way to get a std::vector of available frame ids */
-  TF2_PUBLIC
-  void _getFrameStrings(std::vector<std::string> & ids) const;
+  void _getFrameStrings(std::vector<std::string> & vec) const
+  {
+    vec.clear();
 
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+
+    TransformStorage temp;
+
+    for (size_t counter = 1; counter < frameIDs_reverse_.size(); counter++) {
+      vec.push_back(frameIDs_reverse_[counter]);
+    }
+  }
 
-  TF2_PUBLIC
   CompactFrameID _lookupFrameNumber(const std::string & frameid_str) const
   {
     return lookupFrameNumber(frameid_str);
   }
-  TF2_PUBLIC
+
   CompactFrameID _lookupOrInsertFrameNumber(const std::string & frameid_str)
   {
     return lookupOrInsertFrameNumber(frameid_str);
   }
-
-  TF2_PUBLIC
+  
   tf2::TF2Error _getLatestCommonTime(
     CompactFrameID target_frame, CompactFrameID source_frame,
     TimePoint & time, std::string * error_string) const
@@ -271,8 +764,7 @@ public:
     std::unique_lock<std::mutex> lock(frame_mutex_);
     return getLatestCommonTime(target_frame, source_frame, time, error_string);
   }
-
-  TF2_PUBLIC
+  
   CompactFrameID _validateFrameId(
     const char * function_name_arg,
     const std::string & frame_id) const
@@ -281,26 +773,201 @@ public:
   }
 
   /**@brief Get the duration over which this transformer will cache */
-  TF2_PUBLIC
   tf2::Duration getCacheLength() {return cache_time_;}
 
   /** \brief Backwards compatabilityA way to see what frames have been cached
    * Useful for debugging
    */
-  TF2_PUBLIC
-  std::string _allFramesAsDot(TimePoint current_time) const;
-  TF2_PUBLIC
-  std::string _allFramesAsDot() const;
+  std::string _allFramesAsDot(TimePoint current_time) const
+  {
+    std::stringstream mstream;
+    mstream << "digraph G {" << std::endl;
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+  
+    TransformStorage temp;
+  
+    if (frames_.size() == 1) {
+      mstream << "\"no tf data recieved\"";
+    }
+    mstream.precision(3);
+    mstream.setf(std::ios::fixed, std::ios::floatfield);
+    // one referenced for 0 is no frame
+    for (size_t counter = 1; counter < frames_.size(); counter++) {
+      CompactFrameID frame_id_num;
+      TimeCacheInterfacePtr counter_frame = getFrame(static_cast<CompactFrameID>(counter));
+      if (!counter_frame) {
+        continue;
+      }
+      if (!counter_frame->getData(TimePointZero, temp)) {
+        continue;
+      } else {
+        frame_id_num = temp.frame_id_;
+      }
+      std::string authority = "no recorded authority";
+      std::map<CompactFrameID,
+        std::string>::const_iterator it =
+        frame_authority_.find(static_cast<CompactFrameID>(counter));
+      if (it != frame_authority_.end()) {
+        authority = it->second;
+      }
+  
+      tf2::Duration dur1 = counter_frame->getLatestTimestamp() - counter_frame->getOldestTimestamp();
+      tf2::Duration dur2 = std::chrono::microseconds(100);
+  
+      double rate;
+      if (dur1 > dur2) {
+        rate = (counter_frame->getListLength() * 1e9) /
+          std::chrono::duration_cast<std::chrono::nanoseconds>(dur1).count();
+      } else {
+        rate = (counter_frame->getListLength() * 1e9) /
+          std::chrono::duration_cast<std::chrono::nanoseconds>(dur2).count();
+      }
+  
+      mstream << std::fixed;  // fixed point notation
+      mstream.precision(3);  // 3 decimal places
+      mstream << "\"" << frameIDs_reverse_[frame_id_num] << "\"" << " -> " <<
+        "\"" << frameIDs_reverse_[counter] << "\"" << "[label=\"" <<
+        "Broadcaster: " << authority << "\\n" <<
+        "Average rate: " << rate << " Hz\\n" <<
+        "Most recent transform: " << displayTimePoint(counter_frame->getLatestTimestamp()) << " ";
+      if (current_time != TimePointZero) {
+        mstream << "( " << durationToSec(current_time - counter_frame->getLatestTimestamp()) <<
+          " sec old)";
+      }
+      mstream << "\\n" <<
+        "Buffer length: " << durationToSec(
+        counter_frame->getLatestTimestamp() - counter_frame->getOldestTimestamp()) << " sec\\n" <<
+        "\"];" << std::endl;
+    }
+  
+    // one referenced for 0 is no frame
+    for (size_t counter = 1; counter < frames_.size(); counter++) {
+      CompactFrameID frame_id_num;
+      TimeCacheInterfacePtr counter_frame = getFrame(static_cast<CompactFrameID>(counter));
+      if (!counter_frame) {
+        if (current_time != TimePointZero) {
+          mstream << "edge [style=invis];" << std::endl;
+          mstream <<
+            " subgraph cluster_legend { style=bold; color=black; label =\"view_frames Result\";\n"
+                  <<
+            "\"Recorded at time: " << displayTimePoint(current_time) <<
+            "\"[ shape=plaintext ] ;\n " <<
+            "}" << "->" << "\"" << frameIDs_reverse_[counter] << "\";" << std::endl;
+        }
+        continue;
+      }
+      if (counter_frame->getData(TimePointZero, temp)) {
+        frame_id_num = temp.frame_id_;
+      } else {
+        frame_id_num = 0;
+      }
+  
+      if (frameIDs_reverse_[frame_id_num] == "NO_PARENT") {
+        mstream << "edge [style=invis];" << std::endl;
+        mstream <<
+          " subgraph cluster_legend { style=bold; color=black; label =\"view_frames Result\";\n";
+        if (current_time != TimePointZero) {
+          mstream << "\"Recorded at time: " << displayTimePoint(current_time) <<
+            "\"[ shape=plaintext ] ;\n ";
+        }
+        mstream << "}" << "->" << "\"" << frameIDs_reverse_[counter] << "\";" << std::endl;
+      }
+    }
+    mstream << "}";
+    return mstream.str();
+  }
+
+  std::string _allFramesAsDot() const
+  {
+    return _allFramesAsDot(TimePointZero);
+  }
 
   /** \brief Backwards compatabilityA way to see what frames are in a chain
    * Useful for debugging
    */
-  TF2_PUBLIC
   void _chainAsVector(
     const std::string & target_frame, TimePoint target_time,
     const std::string & source_frame, TimePoint source_time,
     const std::string & fixed_frame,
-    std::vector<std::string> & output) const;
+    std::vector<std::string> & output) const
+  {
+    std::string error_string;
+  
+    output.clear();  // empty vector
+  
+    std::stringstream mstream;
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+  
+    TransformAccum accum;
+  
+    // Get source frame/time using getFrame
+    CompactFrameID source_id = lookupFrameNumber(source_frame);
+    CompactFrameID fixed_id = lookupFrameNumber(fixed_frame);
+    CompactFrameID target_id = lookupFrameNumber(target_frame);
+  
+    std::vector<CompactFrameID> source_frame_chain;
+    tf2::TF2Error retval = walkToTopParent(
+      accum, source_time, fixed_id, source_id, &error_string,
+      &source_frame_chain);
+    if (retval != tf2::TF2Error::TF2_NO_ERROR) {
+      switch (retval) {
+        case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:
+          throw ConnectivityException(error_string);
+        case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:
+          throw ExtrapolationException(error_string);
+        case tf2::TF2Error::TF2_LOOKUP_ERROR:
+          throw LookupException(error_string);
+        default:
+          // CONSOLE_BRIDGE_logError("Unknown error code: %d", retval);
+          assert(0);
+      }
+    }
+  
+    if (source_time != target_time) {
+      std::vector<CompactFrameID> target_frame_chain;
+      retval = walkToTopParent(
+        accum, target_time, target_id, fixed_id, &error_string,
+        &target_frame_chain);
+  
+      if (retval != tf2::TF2Error::TF2_NO_ERROR) {
+        switch (retval) {
+          case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:
+            throw ConnectivityException(error_string);
+          case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:
+            throw ExtrapolationException(error_string);
+          case tf2::TF2Error::TF2_LOOKUP_ERROR:
+            throw LookupException(error_string);
+          default:
+            // CONSOLE_BRIDGE_logError("Unknown error code: %d", retval);
+            assert(0);
+        }
+      }
+      size_t m = target_frame_chain.size();
+      size_t n = source_frame_chain.size();
+      while (m > 0u && n > 0u) {
+        --m;
+        --n;
+        if (source_frame_chain[n] != target_frame_chain[m]) {
+          break;
+        }
+      }
+      // Erase all duplicate items from frame_chain
+      if (n > 0u) {
+        source_frame_chain.erase(source_frame_chain.begin() + (n - 1u), source_frame_chain.end());
+      }
+  
+      if (m < target_frame_chain.size()) {
+        for (size_t i = 0u; i <= m; ++i) {
+          source_frame_chain.push_back(target_frame_chain[i]);
+        }
+      }
+    }
+  
+    // Write each element of source_frame_chain as string
+    for (size_t i = 0u; i < source_frame_chain.size(); ++i) {
+      output.push_back(lookupFrameString(source_frame_chain[i]));
+    }
+  }
 
 private:
   /******************** Internal Storage ****************/
@@ -324,25 +991,11 @@ private:
 
   /// How long to cache transform history
   tf2::Duration cache_time_;
-
-  typedef uint32_t TransformableCallbackHandle;
-
-  typedef std::unordered_map<TransformableCallbackHandle,
-      TransformableCallback> M_TransformableCallback;
+  
   M_TransformableCallback transformable_callbacks_;
   uint32_t transformable_callbacks_counter_;
   std::mutex transformable_callbacks_mutex_;
-
-  struct TransformableRequest
-  {
-    TimePoint time;
-    TransformableRequestHandle request_handle;
-    TransformableCallbackHandle cb_handle;
-    CompactFrameID target_id;
-    CompactFrameID source_id;
-    std::string target_string;
-    std::string source_string;
-  };
+  
   typedef std::vector<TransformableRequest> V_TransformableRequest;
   V_TransformableRequest transformable_requests_;
   std::mutex transformable_requests_mutex_;
@@ -355,27 +1008,224 @@ private:
   /** \brief A way to see what frames have been cached
    * Useful for debugging. Use this call internally.
    */
-  std::string allFramesAsStringNoLock() const;
+  std::string allFramesAsStringNoLock() const
+  {
+    std::stringstream mstream;
+
+    TransformStorage temp;
+
+    // regular transforms
+    for (size_t counter = 1; counter < frames_.size(); counter++) {
+      TimeCacheInterfacePtr frame_ptr = getFrame(static_cast<CompactFrameID>(counter));
+      if (frame_ptr == nullptr) {
+        continue;
+      }
+      CompactFrameID frame_id_num;
+      if (frame_ptr->getData(TimePointZero, temp)) {
+        frame_id_num = temp.frame_id_;
+      } else {
+        frame_id_num = 0;
+      }
+      mstream << "Frame " << frameIDs_reverse_[counter] << " exists with parent " <<
+        frameIDs_reverse_[frame_id_num] << "." << std::endl;
+    }
+
+    return mstream.str();
+  }
 
   bool setTransformImpl(
-    const tf2::Transform & transform_in, const std::string frame_id,
-    const std::string child_frame_id, const TimePoint stamp,
-    const std::string & authority, bool is_static);
+    const tf2::Transform & transform_in, const typename std_msgs::msg::Header_<AllocatorT>::_frame_id_type frame_id,
+    const typename geometry_msgs::msg::TransformStamped_<AllocatorT>::_child_frame_id_type child_frame_id, const TimePoint stamp,
+    const std::string & authority, bool is_static)
+  {
+    std::string stripped_frame_id = stripSlash(std::string(frame_id.c_str()));
+    std::string stripped_child_frame_id = stripSlash(std::string(child_frame_id.c_str()));
+
+    bool error_exists = false;
+    if (stripped_child_frame_id == stripped_frame_id) {
+      // CONSOLE_BRIDGE_logError(
+      //   "TF_SELF_TRANSFORM: Ignoring transform from authority \"%s\" with frame_id and  "
+      //   "child_frame_id \"%s\" because they are the same",
+      //   authority.c_str(), stripped_child_frame_id.c_str());
+      error_exists = true;
+    }
+
+    if (stripped_child_frame_id.empty()) {
+      // CONSOLE_BRIDGE_logError(
+      //   "TF_NO_CHILD_FRAME_ID: Ignoring transform from authority \"%s\" because child_frame_id not"
+      //   " set ", authority.c_str());
+      error_exists = true;
+    }
+
+    if (stripped_frame_id.empty()) {
+      // CONSOLE_BRIDGE_logError(
+      //   "TF_NO_FRAME_ID: Ignoring transform with child_frame_id \"%s\"  from authority \"%s\" "
+      //   "because frame_id not set", stripped_child_frame_id.c_str(), authority.c_str());
+      error_exists = true;
+    }
+
+    if (std::isnan(transform_in.getOrigin().x()) || std::isnan(transform_in.getOrigin().y()) ||
+      std::isnan(transform_in.getOrigin().z()) ||
+      std::isnan(transform_in.getRotation().x()) || std::isnan(transform_in.getRotation().y()) ||
+      std::isnan(transform_in.getRotation().z()) || std::isnan(transform_in.getRotation().w()))
+    {
+      // CONSOLE_BRIDGE_logError(
+      //   "TF_NAN_INPUT: Ignoring transform for child_frame_id \"%s\" from authority \"%s\" because"
+      //   " of a nan value in the transform (%f %f %f) (%f %f %f %f)",
+      //   stripped_child_frame_id.c_str(), authority.c_str(),
+      //   transform_in.getOrigin().x(), transform_in.getOrigin().y(), transform_in.getOrigin().z(),
+      //   transform_in.getRotation().x(), transform_in.getRotation().y(),
+      //   transform_in.getRotation().z(), transform_in.getRotation().w()
+      // );
+      error_exists = true;
+    }
+
+    bool valid = std::abs(
+      (transform_in.getRotation().w() * transform_in.getRotation().w() +
+      transform_in.getRotation().x() * transform_in.getRotation().x() +
+      transform_in.getRotation().y() * transform_in.getRotation().y() +
+      transform_in.getRotation().z() * transform_in.getRotation().z()) - 1.0f) <
+      QUATERNION_NORMALIZATION_TOLERANCE;
+
+    if (!valid) {
+      // CONSOLE_BRIDGE_logError(
+      //   "TF_DENORMALIZED_QUATERNION: Ignoring transform for child_frame_id \"%s\" from authority"
+      //   " \"%s\" because of an invalid quaternion in the transform (%f %f %f %f)",
+      //   stripped_child_frame_id.c_str(), authority.c_str(),
+      //   transform_in.getRotation().x(), transform_in.getRotation().y(),
+      //   transform_in.getRotation().z(), transform_in.getRotation().w());
+      error_exists = true;
+    }
+
+    if (error_exists) {
+      return false;
+    }
+
+    {
+      std::unique_lock<std::mutex> lock(frame_mutex_);
+      CompactFrameID frame_number = lookupOrInsertFrameNumber(stripped_child_frame_id);
+      TimeCacheInterfacePtr frame = getFrame(frame_number);
+      if (frame == nullptr) {
+        frame = allocateFrame(frame_number, is_static);
+      } else {
+        // Overwrite TimeCacheInterface type with a current input
+        bool is_time_cache = frame->isStatic();
+        if (is_time_cache && is_static) {
+          frame = allocateFrame(frame_number, is_static);
+        } else if (!is_time_cache && !is_static) {
+          frame = allocateFrame(frame_number, is_static);
+        }
+      }
+
+      if (frame->insertData(
+          TransformStorage(
+            stamp, transform_in.getRotation(),
+            transform_in.getOrigin(), lookupOrInsertFrameNumber(stripped_frame_id), frame_number)))
+      {
+        frame_authority_[frame_number] = authority;
+      } else {
+        std::string stamp_str = displayTimePoint(stamp);
+        // CONSOLE_BRIDGE_logWarn(
+        //   "TF_OLD_DATA ignoring data from the past for frame %s at time %s according to authority"
+        //   " %s\nPossible reasons are listed at http://wiki.ros.org/tf/Errors%%20explained",
+        //   stripped_child_frame_id.c_str(), stamp_str.c_str(), authority.c_str());
+        return false;
+      }
+    }
+
+    testTransformableRequests();
+
+    return true;
+  }
+  
   void lookupTransformImpl(
     const std::string & target_frame, const std::string & source_frame,
-    const TimePoint & time_in, tf2::Transform & transform, TimePoint & time_out) const;
+    const TimePoint & time_in, tf2::Transform & transform, TimePoint & time_out) const
+  {
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+
+    if (target_frame == source_frame) {
+      transform.setIdentity();
+
+      if (time_in == TimePointZero) {
+        CompactFrameID target_id = lookupFrameNumber(target_frame);
+        TimeCacheInterfacePtr cache = getFrame(target_id);
+        if (cache) {
+          time_out = cache->getLatestTimestamp();
+        } else {
+          time_out = time_in;
+        }
+      } else {
+        time_out = time_in;
+      }
+      return;
+    }
+
+    // Identity case does not need to be validated
+    CompactFrameID target_id = validateFrameId("lookupTransform argument target_frame", target_frame);
+    CompactFrameID source_id = validateFrameId("lookupTransform argument source_frame", source_frame);
+
+    std::string error_string;
+    TransformAccum accum;
+    tf2::TF2Error retval = walkToTopParent(accum, time_in, target_id, source_id, &error_string, nullptr);
+    if (retval != tf2::TF2Error::TF2_NO_ERROR) {
+      switch (retval) {
+      case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:
+        throw ConnectivityException(error_string);
+      case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:
+        throw ExtrapolationException(error_string);
+      case tf2::TF2Error::TF2_LOOKUP_ERROR:
+        throw LookupException(error_string);
+      default:
+        // CONSOLE_BRIDGE_logError("Unknown error code: %d", retval);
+        assert(0);
+      }
+    }
+
+    time_out = accum.time;
+    transform.setOrigin(accum.result_vec);
+    transform.setRotation(accum.result_quat);
+  }
 
   void lookupTransformImpl(
     const std::string & target_frame, const TimePoint & target_time,
     const std::string & source_frame, const TimePoint & source_time,
-    const std::string & fixed_frame, tf2::Transform & transform, TimePoint & time_out) const;
+    const std::string & fixed_frame, tf2::Transform & transform, TimePoint & time_out) const
+  {
+    validateFrameId("lookupTransform argument target_frame", target_frame);
+    validateFrameId("lookupTransform argument source_frame", source_frame);
+    validateFrameId("lookupTransform argument fixed_frame", fixed_frame);
+  
+    tf2::Transform tf1, tf2;
+  
+    lookupTransformImpl(fixed_frame, source_frame, source_time, tf1, time_out);
+    lookupTransformImpl(target_frame, fixed_frame, target_time, tf2, time_out);
+  
+    transform = tf2 * tf1;
+  }
 
   /** \brief An accessor to get a frame.
    * \param frame_number The frameID of the desired Reference Frame
    */
-  TimeCacheInterfacePtr getFrame(CompactFrameID c_frame_id) const;
+  TimeCacheInterfacePtr getFrame(CompactFrameID frame_id) const
+  {
+    if (frame_id >= frames_.size()) {
+      return TimeCacheInterfacePtr();
+    } else {
+      return frames_[frame_id];
+    }
+  }
 
-  TimeCacheInterfacePtr allocateFrame(CompactFrameID cfid, bool is_static);
+  TimeCacheInterfacePtr allocateFrame(CompactFrameID cfid, bool is_static)
+  {
+    if (is_static) {
+      frames_[cfid] = std::make_shared<StaticCache>();
+    } else {
+      frames_[cfid] = std::make_shared<TimeCache>(cache_time_);
+    }
+
+    return frames_[cfid];
+  }
 
   /** \brief Validate a frame ID format and look up its CompactFrameID.
     *   For invalid cases, produce an message.
@@ -389,7 +1239,27 @@ private:
   CompactFrameID validateFrameId(
     const char * function_name_arg,
     const std::string & frame_id,
-    std::string * error_msg) const;
+    std::string * error_msg) const
+  {
+  	if (frame_id.empty()) {
+  		fillOrWarnMessageForInvalidFrame(
+			function_name_arg, frame_id, error_msg, "in tf2 frame_ids cannot be empty");
+  		return 0;
+  	}
+
+  	if (startsWithSlash(frame_id)) {
+  		fillOrWarnMessageForInvalidFrame(
+			function_name_arg, frame_id, error_msg, "in tf2 frame_ids cannot start with a '/'");
+  		return 0;
+  	}
+
+  	CompactFrameID id = lookupFrameNumber(frame_id);
+  	if (id == 0) {
+  		fillOrWarnMessageForInvalidFrame(
+			function_name_arg, frame_id, error_msg, "frame does not exist");
+  	}
+  	return id;
+  }
 
   /** \brief Validate a frame ID format and look it up its compact ID.
     *   Raise an exception for invalid cases.
@@ -402,26 +1272,237 @@ private:
     */
   CompactFrameID validateFrameId(
     const char * function_name_arg,
-    const std::string & frame_id) const;
+    const std::string & frame_id) const
+  {
+  	if (frame_id.empty()) {
+  		std::string error_msg = "Invalid argument \"" + frame_id + "\" passed to " + function_name_arg +
+			" - in tf2 frame_ids cannot be empty";
+  		throw tf2::InvalidArgumentException(error_msg.c_str());
+  	}
+
+  	if (startsWithSlash(frame_id)) {
+  		std::string error_msg = "Invalid argument \"" + frame_id + "\" passed to " + function_name_arg +
+			" - in tf2 frame_ids cannot start with a '/'";
+  		throw tf2::InvalidArgumentException(error_msg.c_str());
+  	}
+
+  	CompactFrameID id = lookupFrameNumber(frame_id);
+  	if (id == 0) {
+  		std::string error_msg = "\"" + frame_id + "\" passed to " + function_name_arg +
+			" does not exist. ";
+  		throw tf2::LookupException(error_msg.c_str());
+  	}
+
+  	return id;
+  }
 
   /// String to number for frame lookup. Returns 0 if the frame was not found.
-  CompactFrameID lookupFrameNumber(const std::string & frameid_str) const;
+  CompactFrameID lookupFrameNumber(const std::string & frameid_str) const
+  {
+    CompactFrameID retval;
+    M_StringToCompactFrameID::const_iterator map_it = frameIDs_.find(frameid_str);
+    if (map_it == frameIDs_.end()) {
+      retval = CompactFrameID(0);
+    } else {
+      retval = map_it->second;
+    }
+    return retval;
+  }
 
   /// String to number for frame lookup with dynamic allocation of new frames
-  CompactFrameID lookupOrInsertFrameNumber(const std::string & frameid_str);
+  CompactFrameID lookupOrInsertFrameNumber(const std::string & frameid_str)
+  {
+    CompactFrameID retval = 0;
+    M_StringToCompactFrameID::iterator map_it = frameIDs_.find(frameid_str);
+    if (map_it == frameIDs_.end()) {
+      retval = CompactFrameID(frames_.size());
+      // Just a place holder for iteration
+      frames_.push_back(TimeCacheInterfacePtr());
+      frameIDs_[frameid_str] = retval;
+      frameIDs_reverse_.push_back(frameid_str);
+    } else {
+      retval = frameIDs_[frameid_str];
+    }
+    return retval;
+  }
 
   /// Number to string frame lookup may throw LookupException if number invalid
-  const std::string & lookupFrameString(CompactFrameID frame_id_num) const;
+  const std::string & lookupFrameString(CompactFrameID frame_id_num) const
+  {
+    if (frame_id_num >= frameIDs_reverse_.size()) {
+      std::stringstream ss;
+      ss << "Reverse lookup of frame id " << frame_id_num << " failed!";
+      throw tf2::LookupException(ss.str());
+    } else {
+      return frameIDs_reverse_[frame_id_num];
+    }
+  }
 
   void createConnectivityErrorString(
     CompactFrameID source_frame, CompactFrameID target_frame,
-    std::string * out) const;
+    std::string * out) const
+  {
+    if (!out) {
+      return;
+    }
+    *out = std::string(
+      "Could not find a connection between '" + lookupFrameString(target_frame) + "' and '" +
+      lookupFrameString(source_frame) + "' because they are not part of the same tree." +
+      "Tf has two or more unconnected trees.");
+  }
 
   /**@brief Return the latest rostime which is common across the spanning set
    * zero if fails to cross */
   tf2::TF2Error getLatestCommonTime(
-    CompactFrameID target_frame, CompactFrameID source_frame,
-    TimePoint & time, std::string * error_string) const;
+    CompactFrameID target_id, CompactFrameID source_id,
+    TimePoint & time, std::string * error_string) const
+  {
+    // Error if one of the frames don't exist.
+    if (source_id == 0 || target_id == 0) {return tf2::TF2Error::TF2_LOOKUP_ERROR;}
+  
+    if (source_id == target_id) {
+      TimeCacheInterfacePtr cache = getFrame(source_id);
+      // Set time to latest timestamp of frameid in case of target and source frame id are the same
+      if (cache) {
+        time = cache->getLatestTimestamp();
+      } else {
+        time = TimePointZero;
+      }
+      return tf2::TF2Error::TF2_NO_ERROR;
+    }
+  
+    std::vector<P_TimeAndFrameID> lct_cache;
+  
+    // Walk the tree to its root from the source frame, accumulating the list of parent/time as
+    //  well as the latest time in the target is a direct parent
+    CompactFrameID frame = source_id;
+    uint32_t depth = 0;
+    TimePoint common_time = TimePoint::max();
+    while (frame != 0) {
+      TimeCacheInterfacePtr cache = getFrame(frame);
+  
+      if (!cache) {
+        // There will be no cache for the very root of the tree
+        break;
+      }
+  
+      P_TimeAndFrameID latest = cache->getLatestTimeAndParent();
+  
+      if (latest.second == 0) {
+        // Just break out here... there may still be a path from source -> target
+        break;
+      }
+  
+      if (latest.first != TimePointZero) {
+        common_time = std::min(latest.first, common_time);
+      }
+  
+      lct_cache.push_back(latest);
+  
+      frame = latest.second;
+  
+      // Early out... target frame is a direct parent of the source frame
+      if (frame == target_id) {
+        time = common_time;
+        if (time == TimePoint::max()) {
+          time = TimePointZero;
+        }
+        return tf2::TF2Error::TF2_NO_ERROR;
+      }
+  
+      ++depth;
+      if (depth > MAX_GRAPH_DEPTH) {
+        if (error_string) {
+          std::stringstream ss;
+          ss << "The tf tree is invalid because it contains a loop." << std::endl <<
+            allFramesAsStringNoLock() << std::endl;
+          *error_string = ss.str();
+        }
+        return tf2::TF2Error::TF2_LOOKUP_ERROR;
+      }
+    }
+  
+    // Now walk to the top parent from the target frame, accumulating the latest time and looking
+    // for a common parent
+    frame = target_id;
+    depth = 0;
+    common_time = TimePoint::max();
+    CompactFrameID common_parent = 0;
+    while (true) {
+      TimeCacheInterfacePtr cache = getFrame(frame);
+  
+      if (!cache) {
+        break;
+      }
+  
+      P_TimeAndFrameID latest = cache->getLatestTimeAndParent();
+  
+      if (latest.second == 0) {
+        break;
+      }
+  
+      if (latest.first != TimePointZero) {
+        common_time = std::min(latest.first, common_time);
+      }
+  
+      std::vector<P_TimeAndFrameID>::iterator it = std::find_if(
+        lct_cache.begin(),
+        lct_cache.end(), TimeAndFrameIDFrameComparator(latest.second));
+      if (it != lct_cache.end()) {  // found a common parent
+        common_parent = it->second;
+        break;
+      }
+  
+      frame = latest.second;
+  
+      // Early out... source frame is a direct parent of the target frame
+      if (frame == source_id) {
+        time = common_time;
+        if (time == TimePoint::max()) {
+          time = TimePointZero;
+        }
+        return tf2::TF2Error::TF2_NO_ERROR;
+      }
+  
+      ++depth;
+      if (depth > MAX_GRAPH_DEPTH) {
+        if (error_string) {
+          std::stringstream ss;
+          ss << "The tf tree is invalid because it contains a loop." << std::endl <<
+            allFramesAsStringNoLock() << std::endl;
+          *error_string = ss.str();
+        }
+        return tf2::TF2Error::TF2_LOOKUP_ERROR;
+      }
+    }
+  
+    if (common_parent == 0) {
+      createConnectivityErrorString(source_id, target_id, error_string);
+      return tf2::TF2Error::TF2_CONNECTIVITY_ERROR;
+    }
+  
+    // Loop through the source -> root list until we hit the common parent
+    {
+      std::vector<P_TimeAndFrameID>::iterator it = lct_cache.begin();
+      std::vector<P_TimeAndFrameID>::iterator end = lct_cache.end();
+      for (; it != end; ++it) {
+        if (it->first != TimePointZero) {
+          common_time = std::min(common_time, it->first);
+        }
+  
+        if (it->second == common_parent) {
+          break;
+        }
+      }
+    }
+  
+    if (common_time == TimePoint::max()) {
+      common_time = TimePointZero;
+    }
+  
+    time = common_time;
+    return tf2::TF2Error::TF2_NO_ERROR;
+  }
 
   /**@brief Traverse the transform tree. If frame_chain is not nullptr, store the traversed frame tree in vector frame_chain.
    * */
@@ -429,14 +1510,259 @@ private:
   tf2::TF2Error walkToTopParent(
     F & f, TimePoint time, CompactFrameID target_id,
     CompactFrameID source_id, std::string * error_string,
-    std::vector<CompactFrameID> * frame_chain) const;
+    std::vector<CompactFrameID> * frame_chain) const
+  {
+    if (frame_chain) {
+      frame_chain->clear();
+    }
+  
+    // Short circuit if zero length transform to allow lookups on non existant links
+    if (source_id == target_id) {
+      f.finalize(Identity, time);
+      return tf2::TF2Error::TF2_NO_ERROR;
+    }
+  
+    // If getting the latest get the latest common time
+    if (time == TimePointZero) {
+      tf2::TF2Error retval = getLatestCommonTime(target_id, source_id, time, error_string);
+      if (retval != tf2::TF2Error::TF2_NO_ERROR) {
+        return retval;
+      }
+    }
+  
+    // Walk the tree to its root from the source frame, accumulating the transform
+    CompactFrameID frame = source_id;
+    CompactFrameID top_parent = frame;
+    uint32_t depth = 0;
+  
+    std::string extrapolation_error_string;
+    bool extrapolation_might_have_occurred = false;
+  
+    while (frame != 0) {
+      TimeCacheInterfacePtr cache = getFrame(frame);
+      if (frame_chain) {
+        frame_chain->push_back(frame);
+      }
+  
+      if (!cache) {
+        // There will be no cache for the very root of the tree
+        top_parent = frame;
+        break;
+      }
+  
+      CompactFrameID parent = f.gather(cache, time, &extrapolation_error_string);
+      if (parent == 0) {
+        // Just break out here... there may still be a path from source -> target
+        top_parent = frame;
+        extrapolation_might_have_occurred = true;
+        break;
+      }
+  
+      // Early out... target frame is a direct parent of the source frame
+      if (frame == target_id) {
+        f.finalize(TargetParentOfSource, time);
+        return tf2::TF2Error::TF2_NO_ERROR;
+      }
+  
+      f.accum(true);
+  
+      top_parent = frame;
+      frame = parent;
+  
+      ++depth;
+      if (depth > MAX_GRAPH_DEPTH) {
+        if (error_string) {
+          std::stringstream ss;
+          ss << "The tf tree is invalid because it contains a loop." << std::endl <<
+            allFramesAsStringNoLock() << std::endl;
+          *error_string = ss.str();
+        }
+        return tf2::TF2Error::TF2_LOOKUP_ERROR;
+      }
+    }
+  
+    // Now walk to the top parent from the target frame, accumulating its transform
+    frame = target_id;
+    depth = 0;
+    std::vector<CompactFrameID> reverse_frame_chain;
+  
+    while (frame != top_parent) {
+      TimeCacheInterfacePtr cache = getFrame(frame);
+      if (frame_chain) {
+        reverse_frame_chain.push_back(frame);
+      }
+  
+      if (!cache) {
+        break;
+      }
+  
+      CompactFrameID parent = f.gather(cache, time, error_string);
+      if (parent == 0) {
+        if (error_string) {
+          std::stringstream ss;
+          ss << *error_string << ", when looking up transform from frame [" << lookupFrameString(
+            source_id) << "] to frame [" << lookupFrameString(target_id) << "]";
+          *error_string = ss.str();
+        }
+  
+        return tf2::TF2Error::TF2_EXTRAPOLATION_ERROR;
+      }
+  
+      // Early out... source frame is a direct parent of the target frame
+      if (frame == source_id) {
+        f.finalize(SourceParentOfTarget, time);
+        if (frame_chain) {
+          frame_chain->swap(reverse_frame_chain);
+        }
+        return tf2::TF2Error::TF2_NO_ERROR;
+      }
+  
+      f.accum(false);
+  
+      frame = parent;
+  
+      ++depth;
+      if (depth > MAX_GRAPH_DEPTH) {
+        if (error_string) {
+          std::stringstream ss;
+          ss << "The tf tree is invalid because it contains a loop." << std::endl <<
+            allFramesAsStringNoLock() << std::endl;
+          *error_string = ss.str();
+        }
+        return tf2::TF2Error::TF2_LOOKUP_ERROR;
+      }
+    }
+  
+    if (frame != top_parent) {
+      if (extrapolation_might_have_occurred) {
+        if (error_string) {
+          std::stringstream ss;
+          ss << extrapolation_error_string << ", when looking up transform from frame [" <<
+            lookupFrameString(source_id) << "] to frame [" << lookupFrameString(target_id) << "]";
+          *error_string = ss.str();
+        }
+        return tf2::TF2Error::TF2_EXTRAPOLATION_ERROR;
+      }
+      createConnectivityErrorString(source_id, target_id, error_string);
+      return tf2::TF2Error::TF2_CONNECTIVITY_ERROR;
+    }
+  
+    f.finalize(FullPath, time);
+    if (frame_chain) {
+      // Pruning: Compare the chains starting at the parent (end) until they differ
+      size_t m = reverse_frame_chain.size();
+      size_t n = frame_chain->size();
+      while (m > 0u && n > 0u) {
+        --m;
+        --n;
+        if ((*frame_chain)[n] != reverse_frame_chain[m]) {
+          break;
+        }
+      }
+      // Erase all duplicate items from frame_chain
+      if (n > 0u) {
+        frame_chain->erase(frame_chain->begin() + (n - 1u), frame_chain->end());
+      }
+  
+      if (m < reverse_frame_chain.size()) {
+        size_t i = m + 1uL;
+        while (i > 0u) {
+          --i;
+          frame_chain->push_back(reverse_frame_chain[i]);
+        }
+      }
+    }
+  
+    return tf2::TF2Error::TF2_NO_ERROR;
+  }
 
-  void testTransformableRequests();
+  void testTransformableRequests()
+  {
+    std::unique_lock<std::mutex> lock(transformable_requests_mutex_);
+    typename std::vector<TransformableRequest>::iterator tr_it = transformable_requests_.begin();
+    while (tr_it != transformable_requests_.end()) {
+      TransformableRequest & req = *tr_it;
+  
+      // One or both of the frames may not have existed when the request was originally made.
+      if (req.target_id == 0) {
+        req.target_id = lookupFrameNumber(req.target_string);
+      }
+  
+      if (req.source_id == 0) {
+        req.source_id = lookupFrameNumber(req.source_string);
+      }
+  
+      TimePoint latest_time;
+      bool do_cb = false;
+      TransformableResult result = TransformAvailable;
+      // TODO(anyone): This is incorrect, but better than nothing. Really we want the latest time for
+      // any of the frames
+      getLatestCommonTime(req.target_id, req.source_id, latest_time, 0);
+      if ((latest_time != TimePointZero) && (req.time + cache_time_ < latest_time)) {
+        do_cb = true;
+        result = TransformFailure;
+      } else if (canTransformInternal(req.target_id, req.source_id, req.time, 0)) {
+        do_cb = true;
+        result = TransformAvailable;
+      }
+  
+      if (do_cb) {
+        {
+          std::unique_lock<std::mutex> lock2(transformable_callbacks_mutex_);
+          typename M_TransformableCallback::iterator tc_it = transformable_callbacks_.find(req.cb_handle);
+          if (tc_it != transformable_callbacks_.end()) {
+            const TransformableCallback & cb = tc_it->second;
+            cb(
+              req.request_handle, lookupFrameString(req.target_id), lookupFrameString(
+                req.source_id), req.time, result);
+            transformable_callbacks_.erase(req.cb_handle);
+          }
+        }
+  
+        if (transformable_requests_.size() > 1) {
+          transformable_requests_[tr_it -
+            transformable_requests_.begin()] = transformable_requests_.back();
+        }
+  
+        transformable_requests_.erase(transformable_requests_.end() - 1);
+  
+        // If we've removed the last element, then the iterator is invalid
+        if (0u == transformable_requests_.size()) {
+          tr_it = transformable_requests_.end();
+        }
+      } else {
+        ++tr_it;
+      }
+    }
+  }
 
   // Actual implementation to walk the transform tree and find out if a transform exists.
   bool canTransformInternal(
     CompactFrameID target_id, CompactFrameID source_id,
-    const TimePoint & time, std::string * error_msg) const;
+    const TimePoint & time, std::string * error_msg) const
+  {
+    std::unique_lock<std::mutex> lock(frame_mutex_);
+    if (target_id == 0 || source_id == 0) {
+      if (error_msg) {
+        *error_msg = "Source or target frame is not yet defined";
+      }
+      return false;
+    }
+
+    if (target_id == source_id) {
+      return true;
+    }
+
+    CanTransformAccum accum;
+    if (walkToTopParent(
+        accum, time, target_id, source_id,
+        error_msg, nullptr) == tf2::TF2Error::TF2_NO_ERROR)
+    {
+      return true;
+    }
+
+    return false;
+  }
 };
 }  // namespace tf2
 
diff --git a/tf2/include/tf2/buffer_core_interface.h b/tf2/include/tf2/buffer_core_interface.h
index f68512a6..24a20147 100644
--- a/tf2/include/tf2/buffer_core_interface.h
+++ b/tf2/include/tf2/buffer_core_interface.h
@@ -45,17 +45,16 @@ namespace tf2
  * This class provides a simple abstract interface for looking up relationships between arbitrary
  * frames of a system.
  */
+template <typename AllocatorT = std::allocator<void>>
 class BufferCoreInterface
 {
 public:
-  TF2_PUBLIC
   virtual
   ~BufferCoreInterface() = default;
 
   /**
    * \brief Clear internal state data.
    */
-  TF2_PUBLIC
   virtual void
   clear() = 0;
 
@@ -66,8 +65,7 @@ public:
    * \param time The time at which the value of the transform is desired (0 will get the latest).
    * \return The transform between the frames.
    */
-  TF2_PUBLIC
-  virtual geometry_msgs::msg::TransformStamped
+  virtual geometry_msgs::msg::TransformStamped_<AllocatorT>
   lookupTransform(
     const std::string & target_frame,
     const std::string & source_frame,
@@ -83,8 +81,7 @@ public:
    * \param fixed_frame The frame in which to assume the transform is constant in time.
    * \return The transform between the frames.
    */
-  TF2_PUBLIC
-  virtual geometry_msgs::msg::TransformStamped
+  virtual geometry_msgs::msg::TransformStamped_<AllocatorT>
   lookupTransform(
     const std::string & target_frame,
     const tf2::TimePoint & target_time,
@@ -101,7 +98,6 @@ public:
    *   Ignored if nullptr.
    * \return true if the transform is possible, false otherwise.
    */
-  TF2_PUBLIC
   virtual bool
   canTransform(
     const std::string & target_frame,
@@ -120,7 +116,6 @@ public:
    *   Ignored if nullptr.
    * \return true if the transform is possible, false otherwise.
    */
-  TF2_PUBLIC
   virtual bool
   canTransform(
     const std::string & target_frame,
@@ -134,7 +129,6 @@ public:
    * \brief Get all frames that exist in the system.
    * \return all frame names in a vector.
    */
-  TF2_PUBLIC
   virtual std::vector<std::string>
   getAllFrameNames() const = 0;
 };   // class BufferCoreInterface
diff --git a/tf2/include/tf2/time_cache.h b/tf2/include/tf2/time_cache.h
index 39b153be..5d315e87 100644
--- a/tf2/include/tf2/time_cache.h
+++ b/tf2/include/tf2/time_cache.h
@@ -50,6 +50,8 @@ public:
   TF2_PUBLIC
   virtual ~TimeCacheInterface() = default;
 
+  virtual bool isStatic() = 0;
+  
   /** \brief Access data from the cache
    * returns false if data unavailable (should be thrown as lookup exception)
    */
@@ -116,6 +118,8 @@ public:
 
   /// Virtual methods
 
+  virtual bool isStatic() { return false; }
+  
   TF2_PUBLIC
   virtual bool getData(
     tf2::TimePoint time, tf2::TransformStorage & data_out,
@@ -167,6 +171,7 @@ private:
 class StaticCache : public TimeCacheInterface
 {
 public:
+  virtual bool isStatic() { return true; }
   /// Virtual methods
   TF2_PUBLIC
   virtual bool getData(TimePoint time, TransformStorage & data_out, std::string * error_str = 0);
diff --git a/tf2/src/buffer_core.cpp b/tf2/src/buffer_core.cpp
deleted file mode 100644
index c8c994e3..00000000
--- a/tf2/src/buffer_core.cpp
+++ /dev/null
@@ -1,1513 +0,0 @@
-// Copyright 2010, Willow Garage, Inc. All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Tully Foote */
-
-#include <algorithm>
-#include <cassert>
-#include <chrono>
-#include <map>
-#include <memory>
-#include <mutex>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "tf2/buffer_core.h"
-#include "tf2/time_cache.h"
-#include "tf2/exceptions.h"
-
-#include "console_bridge/console.h"
-#include "tf2/LinearMath/Quaternion.h"
-#include "tf2/LinearMath/Transform.h"
-#include "tf2/LinearMath/Vector3.h"
-
-#include "builtin_interfaces/msg/time.hpp"
-#include "geometry_msgs/msg/transform.hpp"
-#include "geometry_msgs/msg/transform_stamped.hpp"
-
-namespace tf2
-{
-
-namespace
-{
-
-// Tolerance for acceptable quaternion normalization
-constexpr static double QUATERNION_NORMALIZATION_TOLERANCE = 10e-3;
-
-bool startsWithSlash(const std::string & frame_id)
-{
-  if (frame_id.size() > 0) {
-    if (frame_id[0] == '/') {
-      return true;
-    }
-  }
-  return false;
-}
-
-std::string stripSlash(const std::string & in)
-{
-  std::string out = in;
-  if (startsWithSlash(in)) {
-    out.erase(0, 1);
-  }
-  return out;
-}
-
-void fillOrWarnMessageForInvalidFrame(
-  const char * function_name_arg,
-  const std::string & frame_id,
-  std::string * error_msg,
-  const char * rationale)
-{
-  std::string s = "Invalid frame ID \"" + frame_id +
-    "\" passed to " + function_name_arg + " - " + rationale;
-  if (error_msg != nullptr) {
-    *error_msg = s;
-  } else {
-    CONSOLE_BRIDGE_logWarn("%s", s.c_str());
-  }
-}
-
-}  // anonymous namespace
-
-CompactFrameID BufferCore::validateFrameId(
-  const char * function_name_arg,
-  const std::string & frame_id,
-  std::string * error_msg) const
-{
-  if (frame_id.empty()) {
-    fillOrWarnMessageForInvalidFrame(
-      function_name_arg, frame_id, error_msg, "in tf2 frame_ids cannot be empty");
-    return 0;
-  }
-
-  if (startsWithSlash(frame_id)) {
-    fillOrWarnMessageForInvalidFrame(
-      function_name_arg, frame_id, error_msg, "in tf2 frame_ids cannot start with a '/'");
-    return 0;
-  }
-
-  CompactFrameID id = lookupFrameNumber(frame_id);
-  if (id == 0) {
-    fillOrWarnMessageForInvalidFrame(
-      function_name_arg, frame_id, error_msg, "frame does not exist");
-  }
-  return id;
-}
-
-CompactFrameID BufferCore::validateFrameId(
-  const char * function_name_arg,
-  const std::string & frame_id) const
-{
-  if (frame_id.empty()) {
-    std::string error_msg = "Invalid argument \"" + frame_id + "\" passed to " + function_name_arg +
-      " - in tf2 frame_ids cannot be empty";
-    throw tf2::InvalidArgumentException(error_msg.c_str());
-  }
-
-  if (startsWithSlash(frame_id)) {
-    std::string error_msg = "Invalid argument \"" + frame_id + "\" passed to " + function_name_arg +
-      " - in tf2 frame_ids cannot start with a '/'";
-    throw tf2::InvalidArgumentException(error_msg.c_str());
-  }
-
-  CompactFrameID id = lookupFrameNumber(frame_id);
-  if (id == 0) {
-    std::string error_msg = "\"" + frame_id + "\" passed to " + function_name_arg +
-      " does not exist. ";
-    throw tf2::LookupException(error_msg.c_str());
-  }
-
-  return id;
-}
-
-BufferCore::BufferCore(tf2::Duration cache_time)
-: cache_time_(cache_time),
-  transformable_callbacks_counter_(0),
-  transformable_requests_counter_(0),
-  using_dedicated_thread_(false)
-{
-  frameIDs_["NO_PARENT"] = 0;
-  frames_.push_back(TimeCacheInterfacePtr());
-  frameIDs_reverse_.push_back("NO_PARENT");
-}
-
-BufferCore::~BufferCore() {}
-
-void BufferCore::clear()
-{
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-  if (frames_.size() > 1) {
-    for (std::vector<TimeCacheInterfacePtr>::iterator cache_it = frames_.begin() + 1;
-      cache_it != frames_.end(); ++cache_it)
-    {
-      if (*cache_it) {
-        (*cache_it)->clearList();
-      }
-    }
-  }
-}
-
-bool BufferCore::setTransform(
-  const geometry_msgs::msg::TransformStamped & transform,
-  const std::string & authority, bool is_static)
-{
-  tf2::Transform tf2_transform(tf2::Quaternion(
-      transform.transform.rotation.x,
-      transform.transform.rotation.y,
-      transform.transform.rotation.z,
-      transform.transform.rotation.w),
-    tf2::Vector3(
-      transform.transform.translation.x,
-      transform.transform.translation.y,
-      transform.transform.translation.z));
-  TimePoint time_point(std::chrono::nanoseconds(transform.header.stamp.nanosec) +
-    std::chrono::duration_cast<std::chrono::nanoseconds>(
-      std::chrono::seconds(
-        transform.header.stamp.sec)));
-  return setTransformImpl(
-    tf2_transform, transform.header.frame_id, transform.child_frame_id,
-    time_point, authority, is_static);
-}
-
-bool BufferCore::setTransformImpl(
-  const tf2::Transform & transform_in, const std::string frame_id,
-  const std::string child_frame_id, const TimePoint stamp,
-  const std::string & authority, bool is_static)
-{
-  std::string stripped_frame_id = stripSlash(frame_id);
-  std::string stripped_child_frame_id = stripSlash(child_frame_id);
-
-  bool error_exists = false;
-  if (stripped_child_frame_id == stripped_frame_id) {
-    CONSOLE_BRIDGE_logError(
-      "TF_SELF_TRANSFORM: Ignoring transform from authority \"%s\" with frame_id and  "
-      "child_frame_id \"%s\" because they are the same",
-      authority.c_str(), stripped_child_frame_id.c_str());
-    error_exists = true;
-  }
-
-  if (stripped_child_frame_id.empty()) {
-    CONSOLE_BRIDGE_logError(
-      "TF_NO_CHILD_FRAME_ID: Ignoring transform from authority \"%s\" because child_frame_id not"
-      " set ", authority.c_str());
-    error_exists = true;
-  }
-
-  if (stripped_frame_id.empty()) {
-    CONSOLE_BRIDGE_logError(
-      "TF_NO_FRAME_ID: Ignoring transform with child_frame_id \"%s\"  from authority \"%s\" "
-      "because frame_id not set", stripped_child_frame_id.c_str(), authority.c_str());
-    error_exists = true;
-  }
-
-  if (std::isnan(transform_in.getOrigin().x()) || std::isnan(transform_in.getOrigin().y()) ||
-    std::isnan(transform_in.getOrigin().z()) ||
-    std::isnan(transform_in.getRotation().x()) || std::isnan(transform_in.getRotation().y()) ||
-    std::isnan(transform_in.getRotation().z()) || std::isnan(transform_in.getRotation().w()))
-  {
-    CONSOLE_BRIDGE_logError(
-      "TF_NAN_INPUT: Ignoring transform for child_frame_id \"%s\" from authority \"%s\" because"
-      " of a nan value in the transform (%f %f %f) (%f %f %f %f)",
-      stripped_child_frame_id.c_str(), authority.c_str(),
-      transform_in.getOrigin().x(), transform_in.getOrigin().y(), transform_in.getOrigin().z(),
-      transform_in.getRotation().x(), transform_in.getRotation().y(),
-      transform_in.getRotation().z(), transform_in.getRotation().w()
-    );
-    error_exists = true;
-  }
-
-  bool valid = std::abs(
-    (transform_in.getRotation().w() * transform_in.getRotation().w() +
-    transform_in.getRotation().x() * transform_in.getRotation().x() +
-    transform_in.getRotation().y() * transform_in.getRotation().y() +
-    transform_in.getRotation().z() * transform_in.getRotation().z()) - 1.0f) <
-    QUATERNION_NORMALIZATION_TOLERANCE;
-
-  if (!valid) {
-    CONSOLE_BRIDGE_logError(
-      "TF_DENORMALIZED_QUATERNION: Ignoring transform for child_frame_id \"%s\" from authority"
-      " \"%s\" because of an invalid quaternion in the transform (%f %f %f %f)",
-      stripped_child_frame_id.c_str(), authority.c_str(),
-      transform_in.getRotation().x(), transform_in.getRotation().y(),
-      transform_in.getRotation().z(), transform_in.getRotation().w());
-    error_exists = true;
-  }
-
-  if (error_exists) {
-    return false;
-  }
-
-  {
-    std::unique_lock<std::mutex> lock(frame_mutex_);
-    CompactFrameID frame_number = lookupOrInsertFrameNumber(stripped_child_frame_id);
-    TimeCacheInterfacePtr frame = getFrame(frame_number);
-    if (frame == nullptr) {
-      frame = allocateFrame(frame_number, is_static);
-    } else {
-      // Overwrite TimeCacheInterface type with a current input
-      const TimeCache * time_cache_ptr = dynamic_cast<TimeCache *>(frame.get());
-      const StaticCache * static_cache_ptr = dynamic_cast<StaticCache *>(frame.get());
-      if (time_cache_ptr && is_static) {
-        frame = allocateFrame(frame_number, is_static);
-      } else if (static_cache_ptr && !is_static) {
-        frame = allocateFrame(frame_number, is_static);
-      }
-    }
-
-    if (frame->insertData(
-        TransformStorage(
-          stamp, transform_in.getRotation(),
-          transform_in.getOrigin(), lookupOrInsertFrameNumber(stripped_frame_id), frame_number)))
-    {
-      frame_authority_[frame_number] = authority;
-    } else {
-      std::string stamp_str = displayTimePoint(stamp);
-      CONSOLE_BRIDGE_logWarn(
-        "TF_OLD_DATA ignoring data from the past for frame %s at time %s according to authority"
-        " %s\nPossible reasons are listed at http://wiki.ros.org/tf/Errors%%20explained",
-        stripped_child_frame_id.c_str(), stamp_str.c_str(), authority.c_str());
-      return false;
-    }
-  }
-
-  testTransformableRequests();
-
-  return true;
-}
-
-// This method expects that the caller is holding frame_mutex_
-TimeCacheInterfacePtr BufferCore::allocateFrame(CompactFrameID cfid, bool is_static)
-{
-  if (is_static) {
-    frames_[cfid] = std::make_shared<StaticCache>();
-  } else {
-    frames_[cfid] = std::make_shared<TimeCache>(cache_time_);
-  }
-
-  return frames_[cfid];
-}
-
-enum WalkEnding
-{
-  Identity,
-  TargetParentOfSource,
-  SourceParentOfTarget,
-  FullPath,
-};
-
-template<typename F>
-tf2::TF2Error BufferCore::walkToTopParent(
-  F & f, TimePoint time, CompactFrameID target_id,
-  CompactFrameID source_id, std::string * error_string, std::vector<CompactFrameID>
-  * frame_chain) const
-{
-  if (frame_chain) {
-    frame_chain->clear();
-  }
-
-  // Short circuit if zero length transform to allow lookups on non existant links
-  if (source_id == target_id) {
-    f.finalize(Identity, time);
-    return tf2::TF2Error::TF2_NO_ERROR;
-  }
-
-  // If getting the latest get the latest common time
-  if (time == TimePointZero) {
-    tf2::TF2Error retval = getLatestCommonTime(target_id, source_id, time, error_string);
-    if (retval != tf2::TF2Error::TF2_NO_ERROR) {
-      return retval;
-    }
-  }
-
-  // Walk the tree to its root from the source frame, accumulating the transform
-  CompactFrameID frame = source_id;
-  CompactFrameID top_parent = frame;
-  uint32_t depth = 0;
-
-  std::string extrapolation_error_string;
-  bool extrapolation_might_have_occurred = false;
-
-  while (frame != 0) {
-    TimeCacheInterfacePtr cache = getFrame(frame);
-    if (frame_chain) {
-      frame_chain->push_back(frame);
-    }
-
-    if (!cache) {
-      // There will be no cache for the very root of the tree
-      top_parent = frame;
-      break;
-    }
-
-    CompactFrameID parent = f.gather(cache, time, &extrapolation_error_string);
-    if (parent == 0) {
-      // Just break out here... there may still be a path from source -> target
-      top_parent = frame;
-      extrapolation_might_have_occurred = true;
-      break;
-    }
-
-    // Early out... target frame is a direct parent of the source frame
-    if (frame == target_id) {
-      f.finalize(TargetParentOfSource, time);
-      return tf2::TF2Error::TF2_NO_ERROR;
-    }
-
-    f.accum(true);
-
-    top_parent = frame;
-    frame = parent;
-
-    ++depth;
-    if (depth > MAX_GRAPH_DEPTH) {
-      if (error_string) {
-        std::stringstream ss;
-        ss << "The tf tree is invalid because it contains a loop." << std::endl <<
-          allFramesAsStringNoLock() << std::endl;
-        *error_string = ss.str();
-      }
-      return tf2::TF2Error::TF2_LOOKUP_ERROR;
-    }
-  }
-
-  // Now walk to the top parent from the target frame, accumulating its transform
-  frame = target_id;
-  depth = 0;
-  std::vector<CompactFrameID> reverse_frame_chain;
-
-  while (frame != top_parent) {
-    TimeCacheInterfacePtr cache = getFrame(frame);
-    if (frame_chain) {
-      reverse_frame_chain.push_back(frame);
-    }
-
-    if (!cache) {
-      break;
-    }
-
-    CompactFrameID parent = f.gather(cache, time, error_string);
-    if (parent == 0) {
-      if (error_string) {
-        std::stringstream ss;
-        ss << *error_string << ", when looking up transform from frame [" << lookupFrameString(
-          source_id) << "] to frame [" << lookupFrameString(target_id) << "]";
-        *error_string = ss.str();
-      }
-
-      return tf2::TF2Error::TF2_EXTRAPOLATION_ERROR;
-    }
-
-    // Early out... source frame is a direct parent of the target frame
-    if (frame == source_id) {
-      f.finalize(SourceParentOfTarget, time);
-      if (frame_chain) {
-        frame_chain->swap(reverse_frame_chain);
-      }
-      return tf2::TF2Error::TF2_NO_ERROR;
-    }
-
-    f.accum(false);
-
-    frame = parent;
-
-    ++depth;
-    if (depth > MAX_GRAPH_DEPTH) {
-      if (error_string) {
-        std::stringstream ss;
-        ss << "The tf tree is invalid because it contains a loop." << std::endl <<
-          allFramesAsStringNoLock() << std::endl;
-        *error_string = ss.str();
-      }
-      return tf2::TF2Error::TF2_LOOKUP_ERROR;
-    }
-  }
-
-  if (frame != top_parent) {
-    if (extrapolation_might_have_occurred) {
-      if (error_string) {
-        std::stringstream ss;
-        ss << extrapolation_error_string << ", when looking up transform from frame [" <<
-          lookupFrameString(source_id) << "] to frame [" << lookupFrameString(target_id) << "]";
-        *error_string = ss.str();
-      }
-      return tf2::TF2Error::TF2_EXTRAPOLATION_ERROR;
-    }
-    createConnectivityErrorString(source_id, target_id, error_string);
-    return tf2::TF2Error::TF2_CONNECTIVITY_ERROR;
-  }
-
-  f.finalize(FullPath, time);
-  if (frame_chain) {
-    // Pruning: Compare the chains starting at the parent (end) until they differ
-    size_t m = reverse_frame_chain.size();
-    size_t n = frame_chain->size();
-    while (m > 0u && n > 0u) {
-      --m;
-      --n;
-      if ((*frame_chain)[n] != reverse_frame_chain[m]) {
-        break;
-      }
-    }
-    // Erase all duplicate items from frame_chain
-    if (n > 0u) {
-      frame_chain->erase(frame_chain->begin() + (n - 1u), frame_chain->end());
-    }
-
-    if (m < reverse_frame_chain.size()) {
-      size_t i = m + 1uL;
-      while (i > 0u) {
-        --i;
-        frame_chain->push_back(reverse_frame_chain[i]);
-      }
-    }
-  }
-
-  return tf2::TF2Error::TF2_NO_ERROR;
-}
-
-struct TransformAccum
-{
-  TransformAccum()
-  : source_to_top_quat(0.0, 0.0, 0.0, 1.0),
-    source_to_top_vec(0.0, 0.0, 0.0),
-    target_to_top_quat(0.0, 0.0, 0.0, 1.0),
-    target_to_top_vec(0.0, 0.0, 0.0),
-    result_quat(0.0, 0.0, 0.0, 1.0),
-    result_vec(0.0, 0.0, 0.0)
-  {
-  }
-
-  CompactFrameID gather(TimeCacheInterfacePtr cache, TimePoint time, std::string * error_string)
-  {
-    if (!cache->getData(time, st, error_string)) {
-      return 0;
-    }
-
-    return st.frame_id_;
-  }
-
-  void accum(bool source)
-  {
-    if (source) {
-      source_to_top_vec = quatRotate(st.rotation_, source_to_top_vec) + st.translation_;
-      source_to_top_quat = st.rotation_ * source_to_top_quat;
-    } else {
-      target_to_top_vec = quatRotate(st.rotation_, target_to_top_vec) + st.translation_;
-      target_to_top_quat = st.rotation_ * target_to_top_quat;
-    }
-  }
-
-  void finalize(WalkEnding end, TimePoint _time)
-  {
-    switch (end) {
-      case Identity:
-        break;
-      case TargetParentOfSource:
-        result_vec = source_to_top_vec;
-        result_quat = source_to_top_quat;
-        break;
-      case SourceParentOfTarget:
-        {
-          tf2::Quaternion inv_target_quat = target_to_top_quat.inverse();
-          tf2::Vector3 inv_target_vec = quatRotate(inv_target_quat, -target_to_top_vec);
-          result_vec = inv_target_vec;
-          result_quat = inv_target_quat;
-          break;
-        }
-      case FullPath:
-        {
-          tf2::Quaternion inv_target_quat = target_to_top_quat.inverse();
-          tf2::Vector3 inv_target_vec = quatRotate(inv_target_quat, -target_to_top_vec);
-
-          result_vec = quatRotate(inv_target_quat, source_to_top_vec) + inv_target_vec;
-          result_quat = inv_target_quat * source_to_top_quat;
-        }
-        break;
-    }
-
-    time = _time;
-  }
-
-  TransformStorage st;
-  TimePoint time;
-  tf2::Quaternion source_to_top_quat;
-  tf2::Vector3 source_to_top_vec;
-  tf2::Quaternion target_to_top_quat;
-  tf2::Vector3 target_to_top_vec;
-
-  tf2::Quaternion result_quat;
-  tf2::Vector3 result_vec;
-};
-
-geometry_msgs::msg::TransformStamped
-BufferCore::lookupTransform(
-  const std::string & target_frame, const std::string & source_frame,
-  const TimePoint & time) const
-{
-  tf2::Transform transform;
-  TimePoint time_out;
-  lookupTransformImpl(target_frame, source_frame, time, transform, time_out);
-  geometry_msgs::msg::TransformStamped msg;
-  msg.transform.translation.x = transform.getOrigin().x();
-  msg.transform.translation.y = transform.getOrigin().y();
-  msg.transform.translation.z = transform.getOrigin().z();
-  msg.transform.rotation.x = transform.getRotation().x();
-  msg.transform.rotation.y = transform.getRotation().y();
-  msg.transform.rotation.z = transform.getRotation().z();
-  msg.transform.rotation.w = transform.getRotation().w();
-  std::chrono::nanoseconds ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
-    time_out.time_since_epoch());
-  std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(
-    time_out.time_since_epoch());
-  msg.header.stamp.sec = static_cast<int32_t>(s.count());
-  msg.header.stamp.nanosec = static_cast<uint32_t>(ns.count() % 1000000000ull);
-  msg.header.frame_id = target_frame;
-  msg.child_frame_id = source_frame;
-
-  return msg;
-}
-
-geometry_msgs::msg::TransformStamped
-BufferCore::lookupTransform(
-  const std::string & target_frame, const TimePoint & target_time,
-  const std::string & source_frame, const TimePoint & source_time,
-  const std::string & fixed_frame) const
-{
-  tf2::Transform transform;
-  TimePoint time_out;
-  lookupTransformImpl(
-    target_frame, target_time, source_frame, source_time,
-    fixed_frame, transform, time_out);
-  geometry_msgs::msg::TransformStamped msg;
-  msg.transform.translation.x = transform.getOrigin().x();
-  msg.transform.translation.y = transform.getOrigin().y();
-  msg.transform.translation.z = transform.getOrigin().z();
-  msg.transform.rotation.x = transform.getRotation().x();
-  msg.transform.rotation.y = transform.getRotation().y();
-  msg.transform.rotation.z = transform.getRotation().z();
-  msg.transform.rotation.w = transform.getRotation().w();
-  std::chrono::nanoseconds ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
-    time_out.time_since_epoch());
-  std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(
-    time_out.time_since_epoch());
-  msg.header.stamp.sec = static_cast<int32_t>(s.count());
-  msg.header.stamp.nanosec = static_cast<uint32_t>(ns.count() % 1000000000ull);
-  msg.header.frame_id = target_frame;
-  msg.child_frame_id = source_frame;
-
-  return msg;
-}
-
-void BufferCore::lookupTransformImpl(
-  const std::string & target_frame,
-  const std::string & source_frame,
-  const TimePoint & time, tf2::Transform & transform,
-  TimePoint & time_out) const
-{
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-
-  if (target_frame == source_frame) {
-    transform.setIdentity();
-
-    if (time == TimePointZero) {
-      CompactFrameID target_id = lookupFrameNumber(target_frame);
-      TimeCacheInterfacePtr cache = getFrame(target_id);
-      if (cache) {
-        time_out = cache->getLatestTimestamp();
-      } else {
-        time_out = time;
-      }
-    } else {
-      time_out = time;
-    }
-    return;
-  }
-
-  // Identity case does not need to be validated
-  CompactFrameID target_id = validateFrameId("lookupTransform argument target_frame", target_frame);
-  CompactFrameID source_id = validateFrameId("lookupTransform argument source_frame", source_frame);
-
-  std::string error_string;
-  TransformAccum accum;
-  tf2::TF2Error retval = walkToTopParent(accum, time, target_id, source_id, &error_string, nullptr);
-  if (retval != tf2::TF2Error::TF2_NO_ERROR) {
-    switch (retval) {
-      case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:
-        throw ConnectivityException(error_string);
-      case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:
-        throw ExtrapolationException(error_string);
-      case tf2::TF2Error::TF2_LOOKUP_ERROR:
-        throw LookupException(error_string);
-      default:
-        CONSOLE_BRIDGE_logError("Unknown error code: %d", retval);
-        assert(0);
-    }
-  }
-
-  time_out = accum.time;
-  transform.setOrigin(accum.result_vec);
-  transform.setRotation(accum.result_quat);
-}
-
-void BufferCore::lookupTransformImpl(
-  const std::string & target_frame,
-  const TimePoint & target_time,
-  const std::string & source_frame,
-  const TimePoint & source_time,
-  const std::string & fixed_frame, tf2::Transform & transform,
-  TimePoint & time_out) const
-{
-  validateFrameId("lookupTransform argument target_frame", target_frame);
-  validateFrameId("lookupTransform argument source_frame", source_frame);
-  validateFrameId("lookupTransform argument fixed_frame", fixed_frame);
-
-  tf2::Transform tf1, tf2;
-
-  lookupTransformImpl(fixed_frame, source_frame, source_time, tf1, time_out);
-  lookupTransformImpl(target_frame, fixed_frame, target_time, tf2, time_out);
-
-  transform = tf2 * tf1;
-}
-
-struct CanTransformAccum
-{
-  CompactFrameID gather(TimeCacheInterfacePtr cache, TimePoint time, std::string * error_string)
-  {
-    return cache->getParent(time, error_string);
-  }
-
-  void accum(bool source)
-  {
-    (void)source;
-  }
-
-  void finalize(WalkEnding end, TimePoint _time)
-  {
-    (void)end;
-    (void)_time;
-  }
-
-  TransformStorage st;
-};
-
-bool BufferCore::canTransformInternal(
-  CompactFrameID target_id, CompactFrameID source_id,
-  const TimePoint & time, std::string * error_msg) const
-{
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-  if (target_id == 0 || source_id == 0) {
-    if (error_msg) {
-      *error_msg = "Source or target frame is not yet defined";
-    }
-    return false;
-  }
-
-  if (target_id == source_id) {
-    return true;
-  }
-
-  CanTransformAccum accum;
-  if (walkToTopParent(
-      accum, time, target_id, source_id,
-      error_msg, nullptr) == tf2::TF2Error::TF2_NO_ERROR)
-  {
-    return true;
-  }
-
-  return false;
-}
-
-bool BufferCore::canTransform(
-  const std::string & target_frame, const std::string & source_frame,
-  const TimePoint & time, std::string * error_msg) const
-{
-  // Short circuit if target_frame == source_frame
-  if (target_frame == source_frame) {
-    return true;
-  }
-
-  CompactFrameID target_id = validateFrameId(
-    "canTransform argument target_frame", target_frame, error_msg);
-  if (target_id == 0) {
-    return false;
-  }
-  CompactFrameID source_id = validateFrameId(
-    "canTransform argument source_frame", source_frame, error_msg);
-  if (source_id == 0) {
-    return false;
-  }
-
-  return canTransformInternal(target_id, source_id, time, error_msg);
-}
-
-bool BufferCore::canTransform(
-  const std::string & target_frame, const TimePoint & target_time,
-  const std::string & source_frame, const TimePoint & source_time,
-  const std::string & fixed_frame, std::string * error_msg) const
-{
-  CompactFrameID target_id = validateFrameId(
-    "canTransform argument target_frame", target_frame, error_msg);
-  if (target_id == 0) {
-    return false;
-  }
-  CompactFrameID source_id = validateFrameId(
-    "canTransform argument source_frame", source_frame, error_msg);
-  if (source_id == 0) {
-    return false;
-  }
-  CompactFrameID fixed_id = validateFrameId(
-    "canTransform argument fixed_frame", fixed_frame, error_msg);
-  if (fixed_id == 0) {
-    return false;
-  }
-
-  return
-    canTransformInternal(target_id, fixed_id, target_time, error_msg) &&
-    canTransformInternal(fixed_id, source_id, source_time, error_msg);
-}
-
-tf2::TimeCacheInterfacePtr BufferCore::getFrame(CompactFrameID frame_id) const
-{
-  if (frame_id >= frames_.size()) {
-    return TimeCacheInterfacePtr();
-  } else {
-    return frames_[frame_id];
-  }
-}
-
-CompactFrameID BufferCore::lookupFrameNumber(const std::string & frameid_str) const
-{
-  CompactFrameID retval;
-  M_StringToCompactFrameID::const_iterator map_it = frameIDs_.find(frameid_str);
-  if (map_it == frameIDs_.end()) {
-    retval = CompactFrameID(0);
-  } else {
-    retval = map_it->second;
-  }
-  return retval;
-}
-
-CompactFrameID BufferCore::lookupOrInsertFrameNumber(const std::string & frameid_str)
-{
-  CompactFrameID retval = 0;
-  M_StringToCompactFrameID::iterator map_it = frameIDs_.find(frameid_str);
-  if (map_it == frameIDs_.end()) {
-    retval = CompactFrameID(frames_.size());
-    // Just a place holder for iteration
-    frames_.push_back(TimeCacheInterfacePtr());
-    frameIDs_[frameid_str] = retval;
-    frameIDs_reverse_.push_back(frameid_str);
-  } else {
-    retval = frameIDs_[frameid_str];
-  }
-  return retval;
-}
-
-const std::string & BufferCore::lookupFrameString(CompactFrameID frame_id_num) const
-{
-  if (frame_id_num >= frameIDs_reverse_.size()) {
-    std::stringstream ss;
-    ss << "Reverse lookup of frame id " << frame_id_num << " failed!";
-    throw tf2::LookupException(ss.str());
-  } else {
-    return frameIDs_reverse_[frame_id_num];
-  }
-}
-
-void BufferCore::createConnectivityErrorString(
-  CompactFrameID source_frame,
-  CompactFrameID target_frame, std::string * out) const
-{
-  if (!out) {
-    return;
-  }
-  *out = std::string(
-    "Could not find a connection between '" + lookupFrameString(target_frame) + "' and '" +
-    lookupFrameString(source_frame) + "' because they are not part of the same tree." +
-    "Tf has two or more unconnected trees.");
-}
-
-std::vector<std::string> BufferCore::getAllFrameNames() const
-{
-  std::vector<std::string> frames;
-  _getFrameStrings(frames);
-  return frames;
-}
-
-std::string BufferCore::allFramesAsString() const
-{
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-  return this->allFramesAsStringNoLock();
-}
-
-std::string BufferCore::allFramesAsStringNoLock() const
-{
-  std::stringstream mstream;
-
-  TransformStorage temp;
-
-  // regular transforms
-  for (size_t counter = 1; counter < frames_.size(); counter++) {
-    TimeCacheInterfacePtr frame_ptr = getFrame(static_cast<CompactFrameID>(counter));
-    if (frame_ptr == nullptr) {
-      continue;
-    }
-    CompactFrameID frame_id_num;
-    if (frame_ptr->getData(TimePointZero, temp)) {
-      frame_id_num = temp.frame_id_;
-    } else {
-      frame_id_num = 0;
-    }
-    mstream << "Frame " << frameIDs_reverse_[counter] << " exists with parent " <<
-      frameIDs_reverse_[frame_id_num] << "." << std::endl;
-  }
-
-  return mstream.str();
-}
-
-struct TimeAndFrameIDFrameComparator
-{
-  explicit TimeAndFrameIDFrameComparator(CompactFrameID id)
-  : id(id)
-  {}
-
-  bool operator()(const P_TimeAndFrameID & rhs) const
-  {
-    return rhs.second == id;
-  }
-
-  CompactFrameID id;
-};
-
-tf2::TF2Error BufferCore::getLatestCommonTime(
-  CompactFrameID target_id, CompactFrameID source_id,
-  TimePoint & time, std::string * error_string) const
-{
-  // Error if one of the frames don't exist.
-  if (source_id == 0 || target_id == 0) {return tf2::TF2Error::TF2_LOOKUP_ERROR;}
-
-  if (source_id == target_id) {
-    TimeCacheInterfacePtr cache = getFrame(source_id);
-    // Set time to latest timestamp of frameid in case of target and source frame id are the same
-    if (cache) {
-      time = cache->getLatestTimestamp();
-    } else {
-      time = TimePointZero;
-    }
-    return tf2::TF2Error::TF2_NO_ERROR;
-  }
-
-  std::vector<P_TimeAndFrameID> lct_cache;
-
-  // Walk the tree to its root from the source frame, accumulating the list of parent/time as
-  //  well as the latest time in the target is a direct parent
-  CompactFrameID frame = source_id;
-  uint32_t depth = 0;
-  TimePoint common_time = TimePoint::max();
-  while (frame != 0) {
-    TimeCacheInterfacePtr cache = getFrame(frame);
-
-    if (!cache) {
-      // There will be no cache for the very root of the tree
-      break;
-    }
-
-    P_TimeAndFrameID latest = cache->getLatestTimeAndParent();
-
-    if (latest.second == 0) {
-      // Just break out here... there may still be a path from source -> target
-      break;
-    }
-
-    if (latest.first != TimePointZero) {
-      common_time = std::min(latest.first, common_time);
-    }
-
-    lct_cache.push_back(latest);
-
-    frame = latest.second;
-
-    // Early out... target frame is a direct parent of the source frame
-    if (frame == target_id) {
-      time = common_time;
-      if (time == TimePoint::max()) {
-        time = TimePointZero;
-      }
-      return tf2::TF2Error::TF2_NO_ERROR;
-    }
-
-    ++depth;
-    if (depth > MAX_GRAPH_DEPTH) {
-      if (error_string) {
-        std::stringstream ss;
-        ss << "The tf tree is invalid because it contains a loop." << std::endl <<
-          allFramesAsStringNoLock() << std::endl;
-        *error_string = ss.str();
-      }
-      return tf2::TF2Error::TF2_LOOKUP_ERROR;
-    }
-  }
-
-  // Now walk to the top parent from the target frame, accumulating the latest time and looking
-  // for a common parent
-  frame = target_id;
-  depth = 0;
-  common_time = TimePoint::max();
-  CompactFrameID common_parent = 0;
-  while (true) {
-    TimeCacheInterfacePtr cache = getFrame(frame);
-
-    if (!cache) {
-      break;
-    }
-
-    P_TimeAndFrameID latest = cache->getLatestTimeAndParent();
-
-    if (latest.second == 0) {
-      break;
-    }
-
-    if (latest.first != TimePointZero) {
-      common_time = std::min(latest.first, common_time);
-    }
-
-    std::vector<P_TimeAndFrameID>::iterator it = std::find_if(
-      lct_cache.begin(),
-      lct_cache.end(), TimeAndFrameIDFrameComparator(latest.second));
-    if (it != lct_cache.end()) {  // found a common parent
-      common_parent = it->second;
-      break;
-    }
-
-    frame = latest.second;
-
-    // Early out... source frame is a direct parent of the target frame
-    if (frame == source_id) {
-      time = common_time;
-      if (time == TimePoint::max()) {
-        time = TimePointZero;
-      }
-      return tf2::TF2Error::TF2_NO_ERROR;
-    }
-
-    ++depth;
-    if (depth > MAX_GRAPH_DEPTH) {
-      if (error_string) {
-        std::stringstream ss;
-        ss << "The tf tree is invalid because it contains a loop." << std::endl <<
-          allFramesAsStringNoLock() << std::endl;
-        *error_string = ss.str();
-      }
-      return tf2::TF2Error::TF2_LOOKUP_ERROR;
-    }
-  }
-
-  if (common_parent == 0) {
-    createConnectivityErrorString(source_id, target_id, error_string);
-    return tf2::TF2Error::TF2_CONNECTIVITY_ERROR;
-  }
-
-  // Loop through the source -> root list until we hit the common parent
-  {
-    std::vector<P_TimeAndFrameID>::iterator it = lct_cache.begin();
-    std::vector<P_TimeAndFrameID>::iterator end = lct_cache.end();
-    for (; it != end; ++it) {
-      if (it->first != TimePointZero) {
-        common_time = std::min(common_time, it->first);
-      }
-
-      if (it->second == common_parent) {
-        break;
-      }
-    }
-  }
-
-  if (common_time == TimePoint::max()) {
-    common_time = TimePointZero;
-  }
-
-  time = common_time;
-  return tf2::TF2Error::TF2_NO_ERROR;
-}
-
-std::string BufferCore::allFramesAsYAML(TimePoint current_time) const
-{
-  std::stringstream mstream;
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-
-  TransformStorage temp;
-
-  if (frames_.size() == 1) {
-    mstream << "[]";
-  }
-
-  mstream.precision(3);
-  mstream.setf(std::ios::fixed, std::ios::floatfield);
-
-  // one referenced for 0 is no frame
-  for (size_t counter = 1; counter < frames_.size(); counter++) {
-    CompactFrameID cfid = static_cast<CompactFrameID>(counter);
-    CompactFrameID frame_id_num;
-    TimeCacheInterfacePtr cache = getFrame(cfid);
-    if (!cache) {
-      continue;
-    }
-
-    if (!cache->getData(TimePointZero, temp)) {
-      continue;
-    }
-
-    frame_id_num = temp.frame_id_;
-
-    std::string authority = "no recorded authority";
-    std::map<CompactFrameID, std::string>::const_iterator it = frame_authority_.find(cfid);
-    if (it != frame_authority_.end()) {
-      authority = it->second;
-    }
-
-    tf2::Duration dur1 = cache->getLatestTimestamp() - cache->getOldestTimestamp();
-    tf2::Duration dur2 = tf2::Duration(std::chrono::microseconds(100));
-
-    double rate;
-    if (dur1 > dur2) {
-      rate = (cache->getListLength() * 1e9) / std::chrono::duration_cast<std::chrono::nanoseconds>(
-        dur1).count();
-    } else {
-      rate = (cache->getListLength() * 1e9) / std::chrono::duration_cast<std::chrono::nanoseconds>(
-        dur2).count();
-    }
-
-    mstream << std::fixed;  // fixed point notation
-    mstream.precision(3);  // 3 decimal places
-    mstream << frameIDs_reverse_[cfid] << ": " << std::endl;
-    mstream << "  parent: '" << frameIDs_reverse_[frame_id_num] << "'" << std::endl;
-    mstream << "  broadcaster: '" << authority << "'" << std::endl;
-    mstream << "  rate: " << rate << std::endl;
-    mstream << "  most_recent_transform: " << displayTimePoint(cache->getLatestTimestamp()) <<
-      std::endl;
-    mstream << "  oldest_transform: " << displayTimePoint(cache->getOldestTimestamp()) << std::endl;
-    if (current_time != TimePointZero) {
-      mstream << "  transform_delay: " <<
-        durationToSec(current_time - cache->getLatestTimestamp()) << std::endl;
-    }
-    mstream << "  buffer_length: " << durationToSec(
-      cache->getLatestTimestamp() - cache->getOldestTimestamp()) << std::endl;
-  }
-
-  return mstream.str();
-}
-
-std::string BufferCore::allFramesAsYAML() const
-{
-  return this->allFramesAsYAML(TimePointZero);
-}
-
-TransformableRequestHandle BufferCore::addTransformableRequest(
-  const TransformableCallback & cb,
-  const std::string & target_frame,
-  const std::string & source_frame,
-  TimePoint time)
-{
-  // shortcut if target == source
-  if (target_frame == source_frame) {
-    return 0;
-  }
-
-  // Even though we only modify transformable_requests_ at the end of the
-  // method, we still need to take the lock near the beginning.  This is to
-  // ensure that we don't have a TOCTTOU race between this method and
-  // testTransformableRequests.  If the lock were only at the end of this
-  // method, the race occurs like this:
-  //
-  // T1: addTransformableRequest, determines that needs to add to transformable_requests_
-  // T2: in testTransformableRequests already, holding the lock
-  // T1: blocked getting lock
-  // T2: calls all callbacks for outstanding transforms (doesn't include the current one)
-  // T2: unlocks
-  // T1: gets lock, adds to list
-  //
-  // If nothing ever calls setTransform() again, then the callback for the
-  // current request will never get called.  We fix this by holding the mutex
-  // across most of this method.
-  std::unique_lock<std::mutex> lock(transformable_requests_mutex_);
-
-  TransformableRequest req;
-  req.target_id = lookupFrameNumber(target_frame);
-  req.source_id = lookupFrameNumber(source_frame);
-
-  // First check if the request is already transformable.  If it is, return immediately
-  if (canTransformInternal(req.target_id, req.source_id, time, 0)) {
-    return 0;
-  }
-
-  // Might not be transformable at all, ever (if it's too far in the past)
-  if (req.target_id && req.source_id) {
-    TimePoint latest_time;
-    // TODO(anyone): This is incorrect, but better than nothing.  Really we want the latest time for
-    // any of the frames
-    getLatestCommonTime(req.target_id, req.source_id, latest_time, 0);
-    if ((latest_time != TimePointZero) && (time + cache_time_ < latest_time)) {
-      return 0xffffffffffffffffULL;
-    }
-  }
-
-  {
-    std::unique_lock<std::mutex> lock(transformable_callbacks_mutex_);
-    TransformableCallbackHandle handle = ++transformable_callbacks_counter_;
-    while (!transformable_callbacks_.insert(std::make_pair(handle, cb)).second) {
-      handle = ++transformable_callbacks_counter_;
-    }
-
-    req.cb_handle = handle;
-  }
-
-  req.time = time;
-  req.request_handle = ++transformable_requests_counter_;
-  if (req.request_handle == 0 || req.request_handle == 0xffffffffffffffffULL) {
-    req.request_handle = 1;
-  }
-
-  if (req.target_id == 0) {
-    req.target_string = target_frame;
-  }
-
-  if (req.source_id == 0) {
-    req.source_string = source_frame;
-  }
-
-  transformable_requests_.push_back(req);
-
-  return req.request_handle;
-}
-
-void BufferCore::cancelTransformableRequest(TransformableRequestHandle handle)
-{
-  std::unique_lock<std::mutex> tr_lock(transformable_requests_mutex_);
-  std::unique_lock<std::mutex> tc_lock(transformable_callbacks_mutex_);
-
-  V_TransformableRequest::iterator remove_it = std::remove_if(
-    transformable_requests_.begin(), transformable_requests_.end(),
-    [handle](TransformableRequest req) {return handle == req.request_handle;});
-  for (V_TransformableRequest::iterator it = remove_it; it != transformable_requests_.end(); ++it) {
-    transformable_callbacks_.erase(it->cb_handle);
-  }
-
-  transformable_requests_.erase(remove_it, transformable_requests_.end());
-}
-
-// backwards compability for tf methods
-bool BufferCore::_frameExists(const std::string & frame_id_str) const
-{
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-  return frameIDs_.count(frame_id_str) != 0;
-}
-
-bool BufferCore::_getParent(
-  const std::string & frame_id, TimePoint time,
-  std::string & parent) const
-{
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-  CompactFrameID frame_number = lookupFrameNumber(frame_id);
-  TimeCacheInterfacePtr frame = getFrame(frame_number);
-
-  if (!frame) {
-    return false;
-  }
-
-  CompactFrameID parent_id = frame->getParent(time, nullptr);
-  if (parent_id == 0) {
-    return false;
-  }
-
-  parent = lookupFrameString(parent_id);
-  return true;
-}
-
-void BufferCore::_getFrameStrings(std::vector<std::string> & vec) const
-{
-  vec.clear();
-
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-
-  TransformStorage temp;
-
-  for (size_t counter = 1; counter < frameIDs_reverse_.size(); counter++) {
-    vec.push_back(frameIDs_reverse_[counter]);
-  }
-}
-
-void BufferCore::testTransformableRequests()
-{
-  std::unique_lock<std::mutex> lock(transformable_requests_mutex_);
-  V_TransformableRequest::iterator it = transformable_requests_.begin();
-  while (it != transformable_requests_.end()) {
-    TransformableRequest & req = *it;
-
-    // One or both of the frames may not have existed when the request was originally made.
-    if (req.target_id == 0) {
-      req.target_id = lookupFrameNumber(req.target_string);
-    }
-
-    if (req.source_id == 0) {
-      req.source_id = lookupFrameNumber(req.source_string);
-    }
-
-    TimePoint latest_time;
-    bool do_cb = false;
-    TransformableResult result = TransformAvailable;
-    // TODO(anyone): This is incorrect, but better than nothing. Really we want the latest time for
-    // any of the frames
-    getLatestCommonTime(req.target_id, req.source_id, latest_time, 0);
-    if ((latest_time != TimePointZero) && (req.time + cache_time_ < latest_time)) {
-      do_cb = true;
-      result = TransformFailure;
-    } else if (canTransformInternal(req.target_id, req.source_id, req.time, 0)) {
-      do_cb = true;
-      result = TransformAvailable;
-    }
-
-    if (do_cb) {
-      {
-        std::unique_lock<std::mutex> lock2(transformable_callbacks_mutex_);
-        M_TransformableCallback::iterator it = transformable_callbacks_.find(req.cb_handle);
-        if (it != transformable_callbacks_.end()) {
-          const TransformableCallback & cb = it->second;
-          cb(
-            req.request_handle, lookupFrameString(req.target_id), lookupFrameString(
-              req.source_id), req.time, result);
-          transformable_callbacks_.erase(req.cb_handle);
-        }
-      }
-
-      if (transformable_requests_.size() > 1) {
-        transformable_requests_[it -
-          transformable_requests_.begin()] = transformable_requests_.back();
-      }
-
-      transformable_requests_.erase(transformable_requests_.end() - 1);
-
-      // If we've removed the last element, then the iterator is invalid
-      if (0u == transformable_requests_.size()) {
-        it = transformable_requests_.end();
-      }
-    } else {
-      ++it;
-    }
-  }
-}
-
-std::string BufferCore::_allFramesAsDot(TimePoint current_time) const
-{
-  std::stringstream mstream;
-  mstream << "digraph G {" << std::endl;
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-
-  TransformStorage temp;
-
-  if (frames_.size() == 1) {
-    mstream << "\"no tf data recieved\"";
-  }
-  mstream.precision(3);
-  mstream.setf(std::ios::fixed, std::ios::floatfield);
-  // one referenced for 0 is no frame
-  for (size_t counter = 1; counter < frames_.size(); counter++) {
-    CompactFrameID frame_id_num;
-    TimeCacheInterfacePtr counter_frame = getFrame(static_cast<CompactFrameID>(counter));
-    if (!counter_frame) {
-      continue;
-    }
-    if (!counter_frame->getData(TimePointZero, temp)) {
-      continue;
-    } else {
-      frame_id_num = temp.frame_id_;
-    }
-    std::string authority = "no recorded authority";
-    std::map<CompactFrameID,
-      std::string>::const_iterator it =
-      frame_authority_.find(static_cast<CompactFrameID>(counter));
-    if (it != frame_authority_.end()) {
-      authority = it->second;
-    }
-
-    tf2::Duration dur1 = counter_frame->getLatestTimestamp() - counter_frame->getOldestTimestamp();
-    tf2::Duration dur2 = std::chrono::microseconds(100);
-
-    double rate;
-    if (dur1 > dur2) {
-      rate = (counter_frame->getListLength() * 1e9) /
-        std::chrono::duration_cast<std::chrono::nanoseconds>(dur1).count();
-    } else {
-      rate = (counter_frame->getListLength() * 1e9) /
-        std::chrono::duration_cast<std::chrono::nanoseconds>(dur2).count();
-    }
-
-    mstream << std::fixed;  // fixed point notation
-    mstream.precision(3);  // 3 decimal places
-    mstream << "\"" << frameIDs_reverse_[frame_id_num] << "\"" << " -> " <<
-      "\"" << frameIDs_reverse_[counter] << "\"" << "[label=\"" <<
-      "Broadcaster: " << authority << "\\n" <<
-      "Average rate: " << rate << " Hz\\n" <<
-      "Most recent transform: " << displayTimePoint(counter_frame->getLatestTimestamp()) << " ";
-    if (current_time != TimePointZero) {
-      mstream << "( " << durationToSec(current_time - counter_frame->getLatestTimestamp()) <<
-        " sec old)";
-    }
-    mstream << "\\n" <<
-      "Buffer length: " << durationToSec(
-      counter_frame->getLatestTimestamp() - counter_frame->getOldestTimestamp()) << " sec\\n" <<
-      "\"];" << std::endl;
-  }
-
-  // one referenced for 0 is no frame
-  for (size_t counter = 1; counter < frames_.size(); counter++) {
-    CompactFrameID frame_id_num;
-    TimeCacheInterfacePtr counter_frame = getFrame(static_cast<CompactFrameID>(counter));
-    if (!counter_frame) {
-      if (current_time != TimePointZero) {
-        mstream << "edge [style=invis];" << std::endl;
-        mstream <<
-          " subgraph cluster_legend { style=bold; color=black; label =\"view_frames Result\";\n"
-                <<
-          "\"Recorded at time: " << displayTimePoint(current_time) <<
-          "\"[ shape=plaintext ] ;\n " <<
-          "}" << "->" << "\"" << frameIDs_reverse_[counter] << "\";" << std::endl;
-      }
-      continue;
-    }
-    if (counter_frame->getData(TimePointZero, temp)) {
-      frame_id_num = temp.frame_id_;
-    } else {
-      frame_id_num = 0;
-    }
-
-    if (frameIDs_reverse_[frame_id_num] == "NO_PARENT") {
-      mstream << "edge [style=invis];" << std::endl;
-      mstream <<
-        " subgraph cluster_legend { style=bold; color=black; label =\"view_frames Result\";\n";
-      if (current_time != TimePointZero) {
-        mstream << "\"Recorded at time: " << displayTimePoint(current_time) <<
-          "\"[ shape=plaintext ] ;\n ";
-      }
-      mstream << "}" << "->" << "\"" << frameIDs_reverse_[counter] << "\";" << std::endl;
-    }
-  }
-  mstream << "}";
-  return mstream.str();
-}
-
-std::string BufferCore::_allFramesAsDot() const
-{
-  return _allFramesAsDot(TimePointZero);
-}
-
-void BufferCore::_chainAsVector(
-  const std::string & target_frame, TimePoint target_time,
-  const std::string & source_frame, TimePoint source_time,
-  const std::string & fixed_frame,
-  std::vector<std::string> & output) const
-{
-  std::string error_string;
-
-  output.clear();  // empty vector
-
-  std::stringstream mstream;
-  std::unique_lock<std::mutex> lock(frame_mutex_);
-
-  TransformAccum accum;
-
-  // Get source frame/time using getFrame
-  CompactFrameID source_id = lookupFrameNumber(source_frame);
-  CompactFrameID fixed_id = lookupFrameNumber(fixed_frame);
-  CompactFrameID target_id = lookupFrameNumber(target_frame);
-
-  std::vector<CompactFrameID> source_frame_chain;
-  tf2::TF2Error retval = walkToTopParent(
-    accum, source_time, fixed_id, source_id, &error_string,
-    &source_frame_chain);
-  if (retval != tf2::TF2Error::TF2_NO_ERROR) {
-    switch (retval) {
-      case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:
-        throw ConnectivityException(error_string);
-      case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:
-        throw ExtrapolationException(error_string);
-      case tf2::TF2Error::TF2_LOOKUP_ERROR:
-        throw LookupException(error_string);
-      default:
-        CONSOLE_BRIDGE_logError("Unknown error code: %d", retval);
-        assert(0);
-    }
-  }
-
-  if (source_time != target_time) {
-    std::vector<CompactFrameID> target_frame_chain;
-    retval = walkToTopParent(
-      accum, target_time, target_id, fixed_id, &error_string,
-      &target_frame_chain);
-
-    if (retval != tf2::TF2Error::TF2_NO_ERROR) {
-      switch (retval) {
-        case tf2::TF2Error::TF2_CONNECTIVITY_ERROR:
-          throw ConnectivityException(error_string);
-        case tf2::TF2Error::TF2_EXTRAPOLATION_ERROR:
-          throw ExtrapolationException(error_string);
-        case tf2::TF2Error::TF2_LOOKUP_ERROR:
-          throw LookupException(error_string);
-        default:
-          CONSOLE_BRIDGE_logError("Unknown error code: %d", retval);
-          assert(0);
-      }
-    }
-    size_t m = target_frame_chain.size();
-    size_t n = source_frame_chain.size();
-    while (m > 0u && n > 0u) {
-      --m;
-      --n;
-      if (source_frame_chain[n] != target_frame_chain[m]) {
-        break;
-      }
-    }
-    // Erase all duplicate items from frame_chain
-    if (n > 0u) {
-      source_frame_chain.erase(source_frame_chain.begin() + (n - 1u), source_frame_chain.end());
-    }
-
-    if (m < target_frame_chain.size()) {
-      for (size_t i = 0u; i <= m; ++i) {
-        source_frame_chain.push_back(target_frame_chain[i]);
-      }
-    }
-  }
-
-  // Write each element of source_frame_chain as string
-  for (size_t i = 0u; i < source_frame_chain.size(); ++i) {
-    output.push_back(lookupFrameString(source_frame_chain[i]));
-  }
-}
-}  // namespace tf2
diff --git a/tf2_bullet/CHANGELOG.rst b/tf2_bullet/CHANGELOG.rst
deleted file mode 100644
index 3baf2675..00000000
--- a/tf2_bullet/CHANGELOG.rst
+++ /dev/null
@@ -1,242 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package tf2_bullet
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-0.25.7 (2024-05-29)
--------------------
-
-0.25.6 (2024-02-16)
--------------------
-
-0.25.5 (2023-11-13)
--------------------
-
-0.25.4 (2023-09-19)
--------------------
-
-0.25.3 (2023-07-17)
--------------------
-
-0.25.2 (2023-01-10)
--------------------
-
-0.25.1 (2022-08-05)
--------------------
-
-0.25.0 (2022-04-05)
--------------------
-* Install includes to include/${PROJECT_NAME} and use modern CMake (`#493 <https://github.com/ros2/geometry2/issues/493>`_)
-* Contributors: Shane Loretz
-
-0.24.0 (2022-03-31)
--------------------
-* Export a tf2_bullet::tf2_bullet target (`#495 <https://github.com/ros2/geometry2/issues/495>`_)
-* Contributors: Shane Loretz
-
-0.23.0 (2022-03-28)
--------------------
-
-0.22.0 (2022-03-01)
--------------------
-
-0.21.0 (2022-01-14)
--------------------
-* Fix cpplint errors (`#497 <https://github.com/ros2/geometry2/issues/497>`_)
-* Contributors: Jacob Perron
-
-0.20.0 (2021-12-17)
--------------------
-
-0.19.0 (2021-10-15)
--------------------
-* Remove some references to the ROS 1 wiki.
-* Contributors: Chris Lalancette
-
-0.18.0 (2021-06-01)
--------------------
-* Fix tf2_bullet dependency export (`#428 <https://github.com/ros2/geometry2/issues/428>`_)
-* Deprecate tf2_bullet.h (`#412 <https://github.com/ros2/geometry2/issues/412>`_)
-* Contributors: Bjar Ne, Chris Lalancette
-
-0.17.1 (2021-04-06)
--------------------
-
-0.17.0 (2021-03-19)
--------------------
-
-0.16.0 (2021-01-25)
--------------------
-
-0.15.1 (2020-12-08)
--------------------
-
-0.15.0 (2020-11-02)
--------------------
-* Update maintainers of the ros2/geometry2 fork. (`#328 <https://github.com/ros2/geometry2/issues/328>`_)
-* Contributors: Chris Lalancette
-
-0.14.1 (2020-09-21)
--------------------
-* Activate usual compiler warnings and fix errors (`#270 <https://github.com/ros2/geometry2/issues/270>`_)
-* Contributors: Ivan Santiago Paunovic
-
-0.14.0 (2020-08-14)
--------------------
-* Suppress compiler warning on Centos (`#290 <https://github.com/ros2/geometry2/issues/290>`_)
-* Contributors: Michael Carroll
-
-0.13.4 (2020-06-03)
--------------------
-
-0.13.3 (2020-05-26)
--------------------
-
-0.13.2 (2020-05-18)
--------------------
-
-0.13.1 (2020-05-08)
--------------------
-
-0.13.0 (2020-04-30)
--------------------
-* Added doxyfiles and sphinx Makefiles (`#257 <https://github.com/ros2/geometry2/issues/257>`_)
-* Porting tf2_bullet to ros2 (`#205 <https://github.com/ros2/geometry2/issues/205>`_)
-* Contributors: Alejandro Hernández Cordero
-
-0.5.15 (2017-01-24)
--------------------
-
-0.5.14 (2017-01-16)
--------------------
-* Improve documentation
-* Contributors: Jackie Kay
-
-0.5.13 (2016-03-04)
--------------------
-* Don't export catkin includes
-  They only point to the temporary include in the build directory.
-* Contributors: Jochen Sprickerhof
-
-0.5.12 (2015-08-05)
--------------------
-
-0.5.11 (2015-04-22)
--------------------
-
-0.5.10 (2015-04-21)
--------------------
-
-0.5.9 (2015-03-25)
-------------------
-
-0.5.8 (2015-03-17)
-------------------
-* remove useless Makefile files
-* fix ODR violations
-* Contributors: Vincent Rabaud
-
-0.5.7 (2014-12-23)
-------------------
-* fixing install rules and adding backwards compatible include with #warning
-* Contributors: Tully Foote
-
-0.5.6 (2014-09-18)
-------------------
-
-0.5.5 (2014-06-23)
-------------------
-
-0.5.4 (2014-05-07)
-------------------
-
-0.5.3 (2014-02-21)
-------------------
-
-0.5.2 (2014-02-20)
-------------------
-
-0.5.1 (2014-02-14)
-------------------
-
-0.5.0 (2014-02-14)
-------------------
-
-0.4.10 (2013-12-26)
--------------------
-
-0.4.9 (2013-11-06)
-------------------
-* adding missing buildtool dependency on pkg-config
-
-0.4.8 (2013-11-06)
-------------------
-
-0.4.7 (2013-08-28)
-------------------
-
-0.4.6 (2013-08-28)
-------------------
-
-0.4.5 (2013-07-11)
-------------------
-
-0.4.4 (2013-07-09)
-------------------
-* making repo use CATKIN_ENABLE_TESTING correctly and switching rostest to be a test_depend with that change.
-
-0.4.3 (2013-07-05)
-------------------
-
-0.4.2 (2013-07-05)
-------------------
-* removing unused dependency on rostest
-
-0.4.1 (2013-07-05)
-------------------
-* stripping tf2_ros dependency from tf2_bullet.  Test was moved to test_tf2
-
-0.4.0 (2013-06-27)
-------------------
-* moving convert methods back into tf2 because it does not have any ros dependencies beyond ros::Time which is already a dependency of tf2
-* Cleaning up unnecessary dependency on roscpp
-* converting contents of tf2_ros to be properly namespaced in the tf2_ros namespace
-* Cleaning up packaging of tf2 including:
-  removing unused nodehandle
-  cleaning up a few dependencies and linking
-  removing old backup of package.xml
-  making diff minimally different from tf version of library
-* Restoring test packages and bullet packages.
-  reverting 3570e8c42f9b394ecbfd9db076b920b41300ad55 to get back more of the packages previously implemented
-  reverting 04cf29d1b58c660fdc999ab83563a5d4b76ab331 to fix `#7 <https://github.com/ros/geometry_experimental/issues/7>`_
-
-0.3.6 (2013-03-03)
-------------------
-
-0.3.5 (2013-02-15 14:46)
-------------------------
-
-0.3.4 (2013-02-15 13:14)
-------------------------
-
-0.3.3 (2013-02-15 11:30)
-------------------------
-
-0.3.2 (2013-02-15 00:42)
-------------------------
-
-0.3.1 (2013-02-14)
-------------------
-
-0.3.0 (2013-02-13)
-------------------
-* fixing groovy-devel
-* removing bullet and kdl related packages
-* catkinizing geometry-experimental
-* catkinizing tf2_bullet
-* merge tf2_cpp and tf2_py into tf2_ros
-* A working first version of transforming and converting between different types
-* Fixing tests now that Buffer creates a NodeHandle
-* add frame unit tests to kdl and bullet
-* add first regression tests for kdl and bullet tf
-* add btTransform transform
-* add bullet transforms, and create tests for bullet and kdl
diff --git a/tf2_bullet/CMakeLists.txt b/tf2_bullet/CMakeLists.txt
deleted file mode 100644
index e83e1abd..00000000
--- a/tf2_bullet/CMakeLists.txt
+++ /dev/null
@@ -1,51 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(tf2_bullet)
-
-# Default to C14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic -Wnon-virtual-dtor -Woverloaded-virtual)
-endif()
-
-
-find_package(ament_cmake REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(tf2 REQUIRED)
-find_package(tf2_ros REQUIRED)
-
-include(bullet-extras.cmake)
-
-add_library(tf2_bullet INTERFACE)
-target_include_directories(tf2_bullet INTERFACE
-  "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
-  "$<INSTALL_INTERFACE:include/${PROJECT_NAME}>")
-target_link_libraries(tf2_bullet INTERFACE
-  tf2_bullet::Bullet
-  tf2::tf2
-  ${geometry_msgs_TARGETS}
-  tf2_ros::tf2_ros)
-
-install(TARGETS tf2_bullet EXPORT export_tf2_bullet)
-
-install(DIRECTORY include/ DESTINATION include/${PROJECT_NAME})
-
-if(BUILD_TESTING)
-  find_package(ament_lint_auto REQUIRED)
-  find_package(ament_cmake_cppcheck REQUIRED)
-  list(APPEND AMENT_LINT_AUTO_EXCLUDE
-    ament_cmake_cppcheck
-  )
-  ament_lint_auto_find_test_dependencies()
-  ament_cppcheck(LANGUAGE c++)
-
-  find_package(ament_cmake_gtest REQUIRED)
-  ament_add_gtest(test_bullet test/test_tf2_bullet.cpp)
-  target_link_libraries(test_bullet tf2_bullet)
-endif()
-
-ament_export_targets(export_tf2_bullet)
-
-ament_package(CONFIG_EXTRAS bullet-extras.cmake)
diff --git a/tf2_bullet/Doxyfile b/tf2_bullet/Doxyfile
deleted file mode 100644
index abada890..00000000
--- a/tf2_bullet/Doxyfile
+++ /dev/null
@@ -1,27 +0,0 @@
-# All settings not listed here will use the Doxygen default values.
-
-PROJECT_NAME           = "tf2_bullet"
-PROJECT_NUMBER         = master
-PROJECT_BRIEF          = "Bullet binding for tf2."
-
-INPUT                  = ./include mainpage.dox
-RECURSIVE              = YES
-OUTPUT_DIRECTORY       = doc_output
-
-EXTRACT_ALL            = YES
-SORT_MEMBER_DOCS       = NO
-
-GENERATE_LATEX         = NO
-
-ENABLE_PREPROCESSING   = YES
-MACRO_EXPANSION        = YES
-EXPAND_ONLY_PREDEF     = YES
-PREDEFINED             += TF2_PUBLIC=
-
-# Tag files that do not exist will produce a warning and cross-project linking will not work.
-TAGFILES += "../../../../doxygen_tag_files/cppreference-doxygen-web.tag.xml=http://en.cppreference.com/w/"
-# Consider changing "latest" to the version you want to reference (e.g. beta1 or 1.0.0)
-TAGFILES += "../../../../doxygen_tag_files/rcutils.tag=http://docs.ros2.org/latest/api/rcutils/"
-TAGFILES += "../../../../doxygen_tag_files/tf2.tag=http://docs.ros2.org/latest/api/tf2/"
-TAGFILES += "../../../../doxygen_tag_files/tf2_ros.tag=http://docs.ros2.org/latest/api/tf2_ros/"
-GENERATE_TAGFILE = "../../../../doxygen_tag_files/tf2_bullet.tag"
diff --git a/tf2_bullet/bullet-extras.cmake b/tf2_bullet/bullet-extras.cmake
deleted file mode 100644
index 03c77e30..00000000
--- a/tf2_bullet/bullet-extras.cmake
+++ /dev/null
@@ -1,40 +0,0 @@
-# Copyright 2021 Open Source Robotics Foundation, Inc.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions are met:
-#
-#    * Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#
-#    * Redistributions in binary form must reproduce the above copyright
-#      notice, this list of conditions and the following disclaimer in the
-#      documentation and/or other materials provided with the distribution.
-#
-#    * Neither the name of the Open Source Robotics Foundation, Inc. nor the names of its
-#      contributors may be used to endorse or promote products derived from
-#      this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-# Bullet CMake only exports old-style CMake variables.
-# This script makes an imported target for them.
-
-if(WIN32)
-  set(BULLET_ROOT $ENV{ChocolateyInstall}/lib/bullet)
-endif()
-find_package(Bullet REQUIRED)
-
-add_library(tf2_bullet::Bullet INTERFACE IMPORTED)
-target_include_directories(tf2_bullet::Bullet INTERFACE ${BULLET_INCLUDE_DIRS})
-target_link_libraries(tf2_bullet::Bullet INTERFACE ${BULLET_LIBRARIES})
-target_compile_definitions(tf2_bullet::Bullet INTERFACE ${BULLET_DEFINITIONS})
diff --git a/tf2_bullet/include/tf2_bullet/tf2_bullet.h b/tf2_bullet/include/tf2_bullet/tf2_bullet.h
deleted file mode 100644
index 99a5f9bd..00000000
--- a/tf2_bullet/include/tf2_bullet/tf2_bullet.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright 2008 Willow Garage, Inc.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage, Inc. nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Wim Meeussen */
-
-#ifndef TF2_BULLET__TF2_BULLET_H_
-#define TF2_BULLET__TF2_BULLET_H_
-
-#warning This header is obsolete, please include tf2_bullet/tf2_bullet.hpp instead
-
-#include <tf2_bullet/tf2_bullet.hpp>
-
-#endif  // TF2_BULLET__TF2_BULLET_H_
diff --git a/tf2_bullet/include/tf2_bullet/tf2_bullet.hpp b/tf2_bullet/include/tf2_bullet/tf2_bullet.hpp
deleted file mode 100644
index 061e076f..00000000
--- a/tf2_bullet/include/tf2_bullet/tf2_bullet.hpp
+++ /dev/null
@@ -1,146 +0,0 @@
-// Copyright 2008 Willow Garage, Inc.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage, Inc. nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Wim Meeussen */
-
-#ifndef TF2_BULLET__TF2_BULLET_HPP_
-#define TF2_BULLET__TF2_BULLET_HPP_
-
-#include <iostream>
-
-#include "tf2/convert.h"
-#include "LinearMath/btQuaternion.h"
-#include "LinearMath/btScalar.h"
-#include "LinearMath/btTransform.h"
-#include "geometry_msgs/msg/point_stamped.hpp"
-#include "tf2_ros/buffer_interface.h"
-
-#if (BT_BULLET_VERSION <= 282)
-// Suppress compilation warning on older versions of Bullet.
-// TODO(mjcarroll): Remove this when all platforms have the fix upstream.
-inline int bullet_btInfinityMask()
-{
-  return btInfinityMask;
-}
-#endif
-
-namespace tf2
-{
-/** \brief Convert a timestamped transform to the equivalent Bullet data type.
- * \param t The transform to convert, as a geometry_msgs TransformedStamped message.
- * \return The transform message converted to a Bullet btTransform.
- */
-inline
-btTransform transformToBullet(const geometry_msgs::msg::TransformStamped & t)
-{
-  return btTransform(
-    btQuaternion(
-      static_cast<float>(t.transform.rotation.x),
-      static_cast<float>(t.transform.rotation.y),
-      static_cast<float>(t.transform.rotation.z),
-      static_cast<float>(t.transform.rotation.w)),
-    btVector3(
-      static_cast<float>(t.transform.translation.x),
-      static_cast<float>(t.transform.translation.y),
-      static_cast<float>(t.transform.translation.z)));
-}
-
-
-/** \brief Apply a geometry_msgs TransformStamped to a Bullet-specific Vector3 type.
- * This function is a specialization of the doTransform template defined in tf2/convert.h
- * \param t_in The vector to transform, as a timestamped Bullet btVector3 data type.
- * \param t_out The transformed vector, as a timestamped Bullet btVector3 data type.
- * \param transform The timestamped transform to apply, as a TransformStamped message.
- */
-template< >
-inline
-void doTransform(
-  const tf2::Stamped<btVector3> & t_in, tf2::Stamped<btVector3> & t_out,
-  const geometry_msgs::msg::TransformStamped & transform)
-{
-  t_out =
-    tf2::Stamped<btVector3>(
-    transformToBullet(transform) * t_in,
-    tf2_ros::fromMsg(transform.header.stamp), transform.header.frame_id);
-}
-
-/** \brief Convert a stamped Bullet Vector3 type to a PointStamped message.
- * This function is a specialization of the toMsg template defined in tf2/convert.h
- * \param in The timestamped Bullet btVector3 to convert.
- * \return The vector converted to a PointStamped message.
- */
-inline
-geometry_msgs::msg::PointStamped toMsg(const tf2::Stamped<btVector3> & in)
-{
-  geometry_msgs::msg::PointStamped msg;
-  msg.header.stamp = tf2_ros::toMsg(in.stamp_);
-  msg.header.frame_id = in.frame_id_;
-  msg.point.x = in[0];
-  msg.point.y = in[1];
-  msg.point.z = in[2];
-  return msg;
-}
-
-/** \brief Convert a PointStamped message type to a stamped Bullet-specific Vector3 type.
- * This function is a specialization of the fromMsg template defined in tf2/convert.h
- * \param msg The PointStamped message to convert.
- * \param out The point converted to a timestamped Bullet Vector3.
- */
-inline
-void fromMsg(const geometry_msgs::msg::PointStamped & msg, tf2::Stamped<btVector3> & out)
-{
-  out.stamp_ = tf2_ros::fromMsg(msg.header.stamp);
-  out.frame_id_ = msg.header.frame_id;
-  out[0] = static_cast<float>(msg.point.x);
-  out[1] = static_cast<float>(msg.point.y);
-  out[2] = static_cast<float>(msg.point.z);
-}
-
-
-/** \brief Apply a geometry_msgs TransformStamped to a Bullet-specific Transform data type.
- * This function is a specialization of the doTransform template defined in tf2/convert.h
- * \param t_in The frame to transform, as a timestamped Bullet btTransform.
- * \param t_out The transformed frame, as a timestamped Bullet btTransform.
- * \param transform The timestamped transform to apply, as a TransformStamped message.
- */
-template< >
-inline
-void doTransform(
-  const tf2::Stamped<btTransform> & t_in, tf2::Stamped<btTransform> & t_out,
-  const geometry_msgs::msg::TransformStamped & transform)
-{
-  t_out =
-    tf2::Stamped<btTransform>(
-    transformToBullet(transform) * t_in,
-    tf2_ros::fromMsg(transform.header.stamp), transform.header.frame_id);
-}
-
-
-}  // namespace tf2
-
-#endif  // TF2_BULLET__TF2_BULLET_HPP_
diff --git a/tf2_bullet/mainpage.dox b/tf2_bullet/mainpage.dox
deleted file mode 100644
index 2438d298..00000000
--- a/tf2_bullet/mainpage.dox
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
-\mainpage
-\htmlinclude manifest.html
-
-\b tf2_bullet contains functions for converting between geometry_msgs and Bullet data types.
-
-This library is an implementation of the templated conversion interface specified in tf/convert.h.
-It enables easy conversion from geometry_msgs Transform and Point types to the types specified
-by the Bullet physics engine API (see http://bulletphysics.org).
-
-\section codeapi Code API
-
-This library consists of one header only, tf2_bullet/tf2_bullet.hpp, which consists mostly of
-specializations of template functions defined in tf2/convert.h.
-
-*/
diff --git a/tf2_bullet/package.xml b/tf2_bullet/package.xml
deleted file mode 100644
index 14dcbbe9..00000000
--- a/tf2_bullet/package.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<package format="2">
-  <name>tf2_bullet</name>
-  <version>0.25.7</version>
-  <description>
-    tf2_bullet
-  </description>
-  <maintainer email="clalancette@openrobotics.org">Chris Lalancette</maintainer>
-  <maintainer email="alejandro@openrobotics.org">Alejandro Hernandez Cordero</maintainer>
-  <license>BSD</license>
-  <url type="website">http://www.ros.org/wiki/tf2_bullet</url>
-  <author email="tfoote@osrfoundation.org">Tully Foote</author>
-  <author>Wim Meeussen</author>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <build_depend>bullet</build_depend>
-  <build_depend>geometry_msgs</build_depend>
-  <build_depend>tf2</build_depend>
-  <build_depend>tf2_ros</build_depend>
-
-  <exec_depend>bullet</exec_depend>
-  <exec_depend>geometry_msgs</exec_depend>
-  <exec_depend>tf2</exec_depend>
-  <exec_depend>tf2_ros</exec_depend>
-
-  <test_depend>ament_cmake_gtest</test_depend>
-  <test_depend>ament_lint_auto</test_depend>
-  <test_depend>ament_lint_common</test_depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-
-</package>
diff --git a/tf2_bullet/test/test_tf2_bullet.cpp b/tf2_bullet/test/test_tf2_bullet.cpp
deleted file mode 100644
index 9678d8b2..00000000
--- a/tf2_bullet/test/test_tf2_bullet.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-// Copyright 2008 Willow Garage, Inc.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//
-//    * Neither the name of the Willow Garage, Inc. nor the names of its
-//      contributors may be used to endorse or promote products derived from
-//      this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-/** \author Wim Meeussen */
-
-#include "tf2_bullet/tf2_bullet.hpp"
-#include "rclcpp/rclcpp.hpp"
-#include "gtest/gtest.h"
-#include "tf2/convert.h"
-
-TEST(TfBullet, ConvertVector)
-{
-  btVector3 v(1, 2, 3);
-
-  btVector3 v1 = v;
-  tf2::convert(v1, v1);
-
-  EXPECT_EQ(v, v1);
-
-  btVector3 v2(3, 4, 5);
-  tf2::convert(v1, v2);
-
-  EXPECT_EQ(v, v2);
-  EXPECT_EQ(v1, v2);
-}
-
-
-int main(int argc, char ** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-
-  int ret = RUN_ALL_TESTS();
-  return ret;
-}
diff --git a/tf2_py/src/tf2_py.cpp b/tf2_py/src/tf2_py.cpp
index 7696f705..6dbb3a54 100644
--- a/tf2_py/src/tf2_py.cpp
+++ b/tf2_py/src/tf2_py.cpp
@@ -105,7 +105,7 @@ static PyObject * tf2_connectivityexception = nullptr, * tf2_lookupexception = n
 struct buffer_core_t
 {
   PyObject_HEAD
-  tf2::BufferCore * bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc;
 };
 
 static PyObject * transform_converter(const geometry_msgs::msg::TransformStamped * transform)
@@ -188,7 +188,7 @@ static PyObject * transform_converter(const geometry_msgs::msg::TransformStamped
     goto cleanup;
   }
 
-  pframe_id = stringToPython(transform->header.frame_id);
+  pframe_id = stringToPython(transform->header.frame_id.c_str());
   if (!pframe_id) {
     goto cleanup;
   }
@@ -209,7 +209,7 @@ static PyObject * transform_converter(const geometry_msgs::msg::TransformStamped
     goto cleanup;
   }
 
-  child_frame_id = stringToPython(transform->child_frame_id);
+  child_frame_id = stringToPython(transform->child_frame_id.c_str());
   if (!child_frame_id) {
     goto cleanup;
   }
@@ -381,7 +381,7 @@ static int BufferCore_init(PyObject * self, PyObject * args, PyObject * kw)
     return -1;
   }
 
-  reinterpret_cast<buffer_core_t *>(self)->bc = new tf2::BufferCore(cache_time);
+  reinterpret_cast<buffer_core_t *>(self)->bc = new tf2::BufferCore<std::pmr::polymorphic_allocator<void>>(cache_time);
 
   return 0;
 }
@@ -404,20 +404,20 @@ static void BufferCore_finalize(PyObject * self)
 static PyObject * allFramesAsYAML(PyObject * self, PyObject * args)
 {
   (void)args;
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   return stringToPython(bc->allFramesAsYAML());
 }
 
 static PyObject * allFramesAsString(PyObject * self, PyObject * args)
 {
   (void)args;
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   return stringToPython(bc->allFramesAsString());
 }
 
 static PyObject * canTransformCore(PyObject * self, PyObject * args, PyObject * kw)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * target_frame, * source_frame;
   tf2::TimePoint time;
   static const char * keywords[] = {"target_frame", "source_frame", "time", nullptr};
@@ -437,7 +437,7 @@ static PyObject * canTransformCore(PyObject * self, PyObject * args, PyObject *
 
 static PyObject * canTransformFullCore(PyObject * self, PyObject * args, PyObject * kw)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * target_frame, * source_frame, * fixed_frame;
   tf2::TimePoint target_time, source_time;
   static const char * keywords[] =
@@ -477,7 +477,7 @@ static PyObject * asListOfStrings(std::vector<std::string> los)
 
 static PyObject * _chain(PyObject * self, PyObject * args, PyObject * kw)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * target_frame, * source_frame, * fixed_frame;
   tf2::TimePoint target_time, source_time;
   std::vector<std::string> output;
@@ -507,7 +507,7 @@ static PyObject * _chain(PyObject * self, PyObject * args, PyObject * kw)
 
 static PyObject * getLatestCommonTime(PyObject * self, PyObject * args)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * target_frame, * source_frame;
   tf2::CompactFrameID target_id, source_id;
   tf2::TimePoint tf2_time;
@@ -578,7 +578,7 @@ cleanup:
 
 static PyObject * lookupTransformCore(PyObject * self, PyObject * args, PyObject * kw)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * target_frame, * source_frame;
   tf2::TimePoint time;
   static const char * keywords[] = {"target_frame", "source_frame", "time", nullptr};
@@ -601,7 +601,7 @@ static PyObject * lookupTransformCore(PyObject * self, PyObject * args, PyObject
 
 static PyObject * lookupTransformFullCore(PyObject * self, PyObject * args, PyObject * kw)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * target_frame, * source_frame, * fixed_frame;
   tf2::TimePoint target_time, source_time;
   static const char * keywords[] =
@@ -630,7 +630,7 @@ static PyObject * lookupTransformFullCore(PyObject * self, PyObject * args, PyOb
 /*
 static PyObject *lookupTwistCore(PyObject *self, PyObject *args, PyObject *kw)
 {
-  tf2::BufferCore *bc = ((buffer_core_t*)self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> *bc = ((buffer_core_t*)self)->bc;
   char *tracking_frame, *observation_frame;
   builtin_interfaces::msg::Time time;
   tf2::Duration averaging_interval;
@@ -648,7 +648,7 @@ static PyObject *lookupTwistCore(PyObject *self, PyObject *args, PyObject *kw)
 
 static PyObject *lookupTwistFullCore(PyObject *self, PyObject *args)
 {
-  tf2::BufferCore *bc = ((buffer_core_t*)self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> *bc = ((buffer_core_t*)self)->bc;
   char *tracking_frame, *observation_frame, *reference_frame, *reference_point_frame;
   builtin_interfaces::msg::Time time;
   tf2::Duration averaging_interval;
@@ -717,7 +717,7 @@ static inline int checkRotationType(PyObject * o)
 static PyObject * setTransform(PyObject * self, PyObject * args)
 {
   PyObject * ret = nullptr;
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   PyObject * py_transform;
   char * authority;
   tf2::TimePoint time;
@@ -862,7 +862,7 @@ cleanup:
 static PyObject * setTransformStatic(PyObject * self, PyObject * args)
 {
   PyObject * ret = nullptr;
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   PyObject * py_transform;
   char * authority;
   tf2::TimePoint time;
@@ -1000,14 +1000,14 @@ cleanup:
 static PyObject * clear(PyObject * self, PyObject * args)
 {
   (void)args;
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   bc->clear();
   Py_RETURN_NONE;
 }
 
 static PyObject * _frameExists(PyObject * self, PyObject * args)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   char * frame_id_str;
   if (!PyArg_ParseTuple(args, "s", &frame_id_str)) {
     return nullptr;
@@ -1018,7 +1018,7 @@ static PyObject * _frameExists(PyObject * self, PyObject * args)
 static PyObject * _getFrameStrings(PyObject * self, PyObject * args)
 {
   (void)args;
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   std::vector<std::string> ids;
   bc->_getFrameStrings(ids);
   return asListOfStrings(ids);
@@ -1026,7 +1026,7 @@ static PyObject * _getFrameStrings(PyObject * self, PyObject * args)
 
 static PyObject * _allFramesAsDot(PyObject * self, PyObject * args, PyObject * kw)
 {
-  tf2::BufferCore * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
+  tf2::BufferCore<std::pmr::polymorphic_allocator<void>> * bc = reinterpret_cast<buffer_core_t *>(self)->bc;
   static const char * keywords[] = {"time", nullptr};
   tf2::TimePoint time;
   if (!PyArg_ParseTupleAndKeywords(
diff --git a/tf2_ros/CMakeLists.txt b/tf2_ros/CMakeLists.txt
index 7f15ed83..fbb49804 100644
--- a/tf2_ros/CMakeLists.txt
+++ b/tf2_ros/CMakeLists.txt
@@ -24,11 +24,8 @@ find_package(tf2_msgs REQUIRED)
 add_library(${PROJECT_NAME} SHARED
   src/buffer.cpp
   src/create_timer_ros.cpp
-  src/transform_listener.cpp
   src/buffer_client.cpp
   src/buffer_server.cpp
-  src/transform_broadcaster.cpp
-  src/static_transform_broadcaster.cpp
 )
 target_include_directories(${PROJECT_NAME} PUBLIC
   "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
diff --git a/tf2_ros/include/tf2_ros/buffer.h b/tf2_ros/include/tf2_ros/buffer.h
index fad6f0f4..fd2a6687 100644
--- a/tf2_ros/include/tf2_ros/buffer.h
+++ b/tf2_ros/include/tf2_ros/buffer.h
@@ -54,15 +54,15 @@ namespace tf2_ros
 
 /** \brief Standard implementation of the tf2_ros::BufferInterface abstract data type.
  *
- * Inherits tf2_ros::BufferInterface and tf2::BufferCore.
+ * Inherits tf2_ros::BufferInterface and tf2::BufferCore<std::pmr::polymorphic_allocator<void>>.
  * Stores known frames and offers a ROS service, "tf_frames", which responds to client requests
  * with a response containing a tf2_msgs::FrameGraph representing the relationship of known frames.
  */
-class Buffer : public BufferInterface, public AsyncBufferInterface, public tf2::BufferCore
+class Buffer : public BufferInterface, public AsyncBufferInterface, public tf2::BufferCore<std::pmr::polymorphic_allocator<void>>
 {
 public:
-  using tf2::BufferCore::lookupTransform;
-  using tf2::BufferCore::canTransform;
+  using tf2::BufferCore<std::pmr::polymorphic_allocator<void>>::lookupTransform;
+  using tf2::BufferCore<std::pmr::polymorphic_allocator<void>>::canTransform;
   using SharedPtr = std::shared_ptr<tf2_ros::Buffer>;
 
   /** \brief  Constructor for a Buffer object
diff --git a/tf2_ros/include/tf2_ros/buffer_server.h b/tf2_ros/include/tf2_ros/buffer_server.h
index 14466691..e3d29cc4 100644
--- a/tf2_ros/include/tf2_ros/buffer_server.h
+++ b/tf2_ros/include/tf2_ros/buffer_server.h
@@ -75,7 +75,7 @@ public:
    */
   template<typename NodePtr>
   BufferServer(
-    const tf2::BufferCoreInterface & buffer,
+    const tf2::BufferCoreInterface<std::pmr::polymorphic_allocator<void>> & buffer,
     NodePtr node,
     const std::string & ns,
     tf2::Duration check_period = tf2::durationFromSec(0.01))
@@ -120,7 +120,7 @@ private:
   TF2_ROS_PUBLIC
   geometry_msgs::msg::TransformStamped lookupTransform(GoalHandle gh);
 
-  const tf2::BufferCoreInterface & buffer_;
+  const tf2::BufferCoreInterface<std::pmr::polymorphic_allocator<void>> & buffer_;
   rclcpp::Logger logger_;
   rclcpp_action::Server<LookupTransformAction>::SharedPtr server_;
   std::list<GoalInfo> active_goals_;
diff --git a/tf2_ros/include/tf2_ros/static_transform_broadcaster.h b/tf2_ros/include/tf2_ros/static_transform_broadcaster.h
index 2637ab70..f136237c 100644
--- a/tf2_ros/include/tf2_ros/static_transform_broadcaster.h
+++ b/tf2_ros/include/tf2_ros/static_transform_broadcaster.h
@@ -43,6 +43,30 @@
 #include "tf2_msgs/msg/tf_message.hpp"
 #include "tf2_ros/qos.hpp"
 
+namespace detail
+{
+  template<class AllocatorT = std::pmr::polymorphic_allocator<void>>
+  rclcpp::PublisherOptionsWithAllocator<AllocatorT>
+  get_default_static_transform_broadcaster_sub_options()
+  {
+    rclcpp::PublisherOptionsWithAllocator<AllocatorT> options;
+    options.qos_overriding_options = rclcpp::QosOverridingOptions{
+      rclcpp::QosPolicyKind::Depth,
+      rclcpp::QosPolicyKind::History,
+      rclcpp::QosPolicyKind::Reliability};
+    /*
+      This flag disables intra-process communication while publishing to
+      /tf_static topic, when the StaticTransformBroadcaster is constructed
+      using an existing node handle which happens to be a component
+      (in rclcpp terminology).
+      Required until rclcpp intra-process communication supports
+      transient_local QoS durability.
+    */
+    options.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;
+    return options;
+  }
+}
+
 namespace tf2_ros
 {
 
@@ -50,50 +74,57 @@ namespace tf2_ros
  * It will handle all the messaging and stuffing of messages.  And the function prototypes lay out all the
  * necessary data needed for each message.  */
 
+template <class AllocatorT = std::pmr::polymorphic_allocator<void>>
 class StaticTransformBroadcaster
 {
 public:
   /** \brief Node interface constructor */
-  template<class NodeT, class AllocatorT = std::allocator<void>>
+  template<class NodeT>
   StaticTransformBroadcaster(
     NodeT && node,
     const rclcpp::QoS & qos = StaticBroadcasterQoS(),
-    const rclcpp::PublisherOptionsWithAllocator<AllocatorT> & options = [] () {
-      rclcpp::PublisherOptionsWithAllocator<AllocatorT> options;
-      options.qos_overriding_options = rclcpp::QosOverridingOptions{
-        rclcpp::QosPolicyKind::Depth,
-        rclcpp::QosPolicyKind::History,
-        rclcpp::QosPolicyKind::Reliability};
-      /*
-        This flag disables intra-process communication while publishing to
-        /tf_static topic, when the StaticTransformBroadcaster is constructed
-        using an existing node handle which happens to be a component
-        (in rclcpp terminology).
-        Required until rclcpp intra-process communication supports
-        transient_local QoS durability.
-      */
-      options.use_intra_process_comm = rclcpp::IntraProcessSetting::Disable;
-      return options;
-    } ())
+    const rclcpp::PublisherOptionsWithAllocator<AllocatorT> & options = detail::get_default_static_transform_broadcaster_sub_options<AllocatorT>())
   {
-    publisher_ = rclcpp::create_publisher<tf2_msgs::msg::TFMessage>(
+    publisher_ = rclcpp::create_publisher<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>(
       node, "/tf_static", qos, options);
   }
 
   /** \brief Send a TransformStamped message
    * The stamped data structure includes frame_id, and time, and parent_id already.  */
-  TF2_ROS_PUBLIC
-  void sendTransform(const geometry_msgs::msg::TransformStamped & transform);
+  void sendTransform(const geometry_msgs::msg::TransformStamped_<AllocatorT> & transform)
+  {
+    std::vector<geometry_msgs::msg::TransformStamped_<AllocatorT>> v1;
+    v1.push_back(transform);
+    sendTransform(v1);
+  }
 
   /** \brief Send a vector of TransformStamped messages
    * The stamped data structure includes frame_id, and time, and parent_id already.  */
-  TF2_ROS_PUBLIC
-  void sendTransform(const std::vector<geometry_msgs::msg::TransformStamped> & transforms);
+  void sendTransform(const std::vector<geometry_msgs::msg::TransformStamped_<AllocatorT>> & transforms)
+  {
+    for (auto it_in = transforms.begin(); it_in != transforms.end(); ++it_in) {
+      bool match_found = false;
+      for (auto it_msg = net_message_.transforms.begin(); it_msg != net_message_.transforms.end();
+        ++it_msg)
+      {
+        if (it_in->child_frame_id == it_msg->child_frame_id) {
+          *it_msg = *it_in;
+          match_found = true;
+          break;
+        }
+      }
+      if (!match_found) {
+        net_message_.transforms.push_back(*it_in);
+      }
+    }
+
+    publisher_->publish(net_message_);
+  }
 
 private:
   /// Internal reference to ros::Node
-  rclcpp::Publisher<tf2_msgs::msg::TFMessage>::SharedPtr publisher_;
-  tf2_msgs::msg::TFMessage net_message_;
+  std::shared_ptr<rclcpp::Publisher<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>> publisher_;
+  tf2_msgs::msg::TFMessage_<AllocatorT> net_message_;
 };
 
 }  // namespace tf2_ros
diff --git a/tf2_ros/include/tf2_ros/static_transform_broadcaster_node.hpp b/tf2_ros/include/tf2_ros/static_transform_broadcaster_node.hpp
index 070d7de6..454d5ab2 100644
--- a/tf2_ros/include/tf2_ros/static_transform_broadcaster_node.hpp
+++ b/tf2_ros/include/tf2_ros/static_transform_broadcaster_node.hpp
@@ -49,7 +49,7 @@ public:
   ~StaticTransformBroadcasterNode() override = default;
 
 private:
-  std::unique_ptr<tf2_ros::StaticTransformBroadcaster> broadcaster_;
+  std::unique_ptr<tf2_ros::StaticTransformBroadcaster<std::pmr::polymorphic_allocator<void>>> broadcaster_;
 };
 
 }  // namespace tf2_ros
diff --git a/tf2_ros/include/tf2_ros/transform_broadcaster.h b/tf2_ros/include/tf2_ros/transform_broadcaster.h
index b84af48e..5aef6ecd 100644
--- a/tf2_ros/include/tf2_ros/transform_broadcaster.h
+++ b/tf2_ros/include/tf2_ros/transform_broadcaster.h
@@ -43,6 +43,22 @@
 #include "tf2_msgs/msg/tf_message.hpp"
 #include "tf2_ros/qos.hpp"
 
+namespace detail
+{
+  template<class AllocatorT = std::pmr::polymorphic_allocator<void>>
+  rclcpp::PublisherOptionsWithAllocator<AllocatorT>
+  get_default_transform_broadcaster_sub_options()
+  {
+    rclcpp::PublisherOptionsWithAllocator<AllocatorT> options;
+    options.qos_overriding_options = rclcpp::QosOverridingOptions{
+      rclcpp::QosPolicyKind::Depth,
+      rclcpp::QosPolicyKind::Durability,
+      rclcpp::QosPolicyKind::History,
+      rclcpp::QosPolicyKind::Reliability};
+    return options;
+  }
+}
+
 namespace tf2_ros
 {
 
@@ -50,25 +66,18 @@ namespace tf2_ros
  * It will handle all the messaging and stuffing of messages.  And the function prototypes lay out all the
  * necessary data needed for each message.  */
 
+template <class AllocatorT = std::pmr::polymorphic_allocator<void>>
 class TransformBroadcaster
 {
 public:
   /** \brief Node interface constructor */
-  template<class NodeT, class AllocatorT = std::allocator<void>>
+  template<class NodeT>
   TransformBroadcaster(
     NodeT && node,
     const rclcpp::QoS & qos = DynamicBroadcasterQoS(),
-    const rclcpp::PublisherOptionsWithAllocator<AllocatorT> & options = [] () {
-      rclcpp::PublisherOptionsWithAllocator<AllocatorT> options;
-      options.qos_overriding_options = rclcpp::QosOverridingOptions{
-        rclcpp::QosPolicyKind::Depth,
-        rclcpp::QosPolicyKind::Durability,
-        rclcpp::QosPolicyKind::History,
-        rclcpp::QosPolicyKind::Reliability};
-      return options;
-    } ())
+    const rclcpp::PublisherOptionsWithAllocator<AllocatorT> & options = detail::get_default_transform_broadcaster_sub_options<AllocatorT>())
   {
-    publisher_ = rclcpp::create_publisher<tf2_msgs::msg::TFMessage>(
+    publisher_ = rclcpp::create_publisher<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>(
       node, "/tf", qos, options);
   }
 
@@ -79,8 +88,12 @@ public:
    * position in `header.frame_id` ʰp such that ʰp = ʰTₐ ᵃp .
    *
    */
-  TF2_ROS_PUBLIC
-  void sendTransform(const geometry_msgs::msg::TransformStamped & transform);
+  void sendTransform(const geometry_msgs::msg::TransformStamped_<AllocatorT> & transform)
+  {
+    std::vector<geometry_msgs::msg::TransformStamped_<AllocatorT>> v1;
+    v1.push_back(transform);
+    sendTransform(v1);
+  }
 
   /** \brief Send a vector of TransformStamped messages
    *
@@ -88,11 +101,19 @@ public:
    * `h`. That is, position in `child_frame_id` ᵃp can be transformed to
    * position in `header.frame_id` ʰp such that ʰp = ʰTₐ ᵃp .
    */
-  TF2_ROS_PUBLIC
-  void sendTransform(const std::vector<geometry_msgs::msg::TransformStamped> & transforms);
+  void sendTransform(const std::vector<geometry_msgs::msg::TransformStamped_<AllocatorT>> & transforms)
+  {
+    tf2_msgs::msg::TFMessage_<AllocatorT> message;
+    for (typename std::vector<geometry_msgs::msg::TransformStamped_<AllocatorT>>::const_iterator it = transforms.begin();
+      it != transforms.end(); ++it)
+    {
+      message.transforms.push_back(*it);
+    }
+    publisher_->publish(message);
+  }
 
 private:
-  rclcpp::Publisher<tf2_msgs::msg::TFMessage>::SharedPtr publisher_;
+  std::shared_ptr<rclcpp::Publisher<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>> publisher_;
 };
 
 }  // namespace tf2_ros
diff --git a/tf2_ros/include/tf2_ros/transform_listener.h b/tf2_ros/include/tf2_ros/transform_listener.h
index 01620a8f..ba59342e 100644
--- a/tf2_ros/include/tf2_ros/transform_listener.h
+++ b/tf2_ros/include/tf2_ros/transform_listener.h
@@ -34,6 +34,8 @@
 
 #include <functional>
 #include <memory>
+#include <sstream>
+#include <string>
 #include <thread>
 #include <utility>
 
@@ -51,7 +53,7 @@ namespace tf2_ros
 
 namespace detail
 {
-template<class AllocatorT = std::allocator<void>>
+template<class AllocatorT = std::pmr::polymorphic_allocator<void>>
 rclcpp::SubscriptionOptionsWithAllocator<AllocatorT>
 get_default_transform_listener_sub_options()
 {
@@ -64,7 +66,7 @@ get_default_transform_listener_sub_options()
   return options;
 }
 
-template<class AllocatorT = std::allocator<void>>
+template<class AllocatorT = std::pmr::polymorphic_allocator<void>>
 rclcpp::SubscriptionOptionsWithAllocator<AllocatorT>
 get_default_transform_listener_static_sub_options()
 {
@@ -79,16 +81,32 @@ get_default_transform_listener_static_sub_options()
 
 /** \brief This class provides an easy way to request and receive coordinate frame transform information.
  */
+template <class AllocatorT = std::pmr::polymorphic_allocator<void>>
 class TransformListener
 {
 public:
   /**@brief Constructor for transform listener */
-  TF2_ROS_PUBLIC
-  explicit TransformListener(tf2::BufferCore & buffer, bool spin_thread = true);
+  explicit TransformListener(tf2::BufferCore<AllocatorT> & buffer, bool spin_thread = true)
+  : buffer_(buffer)
+  {
+    // create a unique name for the node
+    std::stringstream sstream;
+    sstream << "transform_listener_impl_" << std::hex << reinterpret_cast<size_t>(this);
+    rclcpp::NodeOptions options;
+    // but specify its name in .arguments to override any __node passed on the command line
+    options.arguments({"--ros-args", "-r", "__node:=" + std::string(sstream.str())});
+    options.start_parameter_event_publisher(false);
+    options.start_parameter_services(false);
+    optional_default_node_ = rclcpp::Node::make_shared("_", options);
+    init(
+      optional_default_node_, spin_thread, DynamicListenerQoS(), StaticListenerQoS(),
+      detail::get_default_transform_listener_sub_options(),
+      detail::get_default_transform_listener_static_sub_options());
+  }
 
-  template<class NodeT, class AllocatorT = std::allocator<void>>
+  template<class NodeT>
   TransformListener(
-    tf2::BufferCore & buffer,
+    tf2::BufferCore<AllocatorT> & buffer,
     NodeT && node,
     bool spin_thread = true,
     const rclcpp::QoS & qos = DynamicListenerQoS(),
@@ -102,11 +120,16 @@ public:
     init(node, spin_thread, qos, static_qos, options, static_options);
   }
 
-  TF2_ROS_PUBLIC
-  virtual ~TransformListener();
+  virtual ~TransformListener()
+  {
+    if (spin_thread_) {
+      executor_->cancel();
+      dedicated_listener_thread_->join();
+    }
+  }
 
 private:
-  template<class NodeT, class AllocatorT = std::allocator<void>>
+  template<class NodeT>
   void init(
     NodeT && node,
     bool spin_thread,
@@ -119,7 +142,7 @@ private:
     node_base_interface_ = node->get_node_base_interface();
     node_logging_interface_ = node->get_node_logging_interface();
 
-    using callback_t = std::function<void (tf2_msgs::msg::TFMessage::ConstSharedPtr)>;
+    using callback_t = std::function<void (const tf2_msgs::msg::TFMessage_<AllocatorT>&)>;
     callback_t cb = std::bind(
       &TransformListener::subscription_callback, this, std::placeholders::_1, false);
     callback_t static_cb = std::bind(
@@ -135,10 +158,12 @@ private:
       tf_options.callback_group = callback_group_;
       tf_static_options.callback_group = callback_group_;
 
-      message_subscription_tf_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage>(
-        node, "/tf", qos, std::move(cb), tf_options);
-      message_subscription_tf_static_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage>(
-        node, "/tf_static", static_qos, std::move(static_cb), tf_static_options);
+      auto tf_msg_mem_strat = std::make_shared<rclcpp::message_memory_strategy::MessageMemoryStrategy<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>>(tf_options.allocator);
+      message_subscription_tf_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage_<AllocatorT>>(
+        node, "/tf", qos, std::move(cb), tf_options, tf_msg_mem_strat);
+      auto tf_static_msg_mem_strat = std::make_shared<rclcpp::message_memory_strategy::MessageMemoryStrategy<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>>(tf_static_options.allocator);
+      message_subscription_tf_static_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage_<AllocatorT>>(
+        node, "/tf_static", static_qos, std::move(static_cb), tf_static_options, tf_static_msg_mem_strat);
 
       // Create executor with dedicated thread to spin.
       executor_ = std::make_shared<rclcpp::executors::SingleThreadedExecutor>();
@@ -147,15 +172,34 @@ private:
       // Tell the buffer we have a dedicated thread to enable timeouts
       buffer_.setUsingDedicatedThread(true);
     } else {
-      message_subscription_tf_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage>(
-        node, "/tf", qos, std::move(cb), options);
-      message_subscription_tf_static_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage>(
+      auto tf_msg_mem_strat = std::make_shared<rclcpp::message_memory_strategy::MessageMemoryStrategy<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>>(options.allocator);
+      message_subscription_tf_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage_<AllocatorT>>(
+        node, "/tf", qos, std::move(cb), options, tf_msg_mem_strat);
+      auto tf_static_msg_mem_strat = std::make_shared<rclcpp::message_memory_strategy::MessageMemoryStrategy<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>>(static_options.allocator);
+      message_subscription_tf_static_ = rclcpp::create_subscription<tf2_msgs::msg::TFMessage_<AllocatorT>>(
         node, "/tf_static", static_qos, std::move(static_cb), static_options);
     }
   }
-  /// Callback function for ros message subscriptoin
-  TF2_ROS_PUBLIC
-  void subscription_callback(tf2_msgs::msg::TFMessage::ConstSharedPtr msg, bool is_static);
+  /// Callback function for ros message subscription
+  void subscription_callback(const tf2_msgs::msg::TFMessage_<AllocatorT>& msg_in, bool is_static)
+  {
+    // const tf2_msgs::msg::TFMessage_<AllocatorT> & msg_in = *msg;
+    // TODO(tfoote) find a way to get the authority
+    std::string authority = "Authority undetectable";
+    for (size_t i = 0u; i < msg_in.transforms.size(); i++) {
+      try {
+        buffer_.setTransform(msg_in.transforms[i], authority, is_static);
+      } catch (const tf2::TransformException & ex) {
+        // /\todo Use error reporting
+        std::string temp = ex.what();
+        RCLCPP_ERROR(
+          node_logging_interface_->get_logger(),
+          "Failure to set received transform from %s to %s with error: %s\n",
+          msg_in.transforms[i].child_frame_id.c_str(),
+          msg_in.transforms[i].header.frame_id.c_str(), temp.c_str());
+      }
+    }
+  }
 
   // ros::CallbackQueue tf_message_callback_queue_;
   bool spin_thread_{false};
@@ -164,9 +208,9 @@ private:
   rclcpp::executors::SingleThreadedExecutor::SharedPtr executor_;
 
   rclcpp::Node::SharedPtr optional_default_node_ = nullptr;
-  rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr message_subscription_tf_;
-  rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr message_subscription_tf_static_;
-  tf2::BufferCore & buffer_;
+  std::shared_ptr<rclcpp::Subscription<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>> message_subscription_tf_;
+  std::shared_ptr<rclcpp::Subscription<tf2_msgs::msg::TFMessage_<AllocatorT>, AllocatorT>> message_subscription_tf_static_;
+  tf2::BufferCore<AllocatorT> & buffer_;
   tf2::TimePoint last_update_;
   rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr node_logging_interface_;
   rclcpp::node_interfaces::NodeBaseInterface::SharedPtr node_base_interface_;
diff --git a/tf2_ros/src/buffer_client.cpp b/tf2_ros/src/buffer_client.cpp
index 32702ab3..83b9a028 100644
--- a/tf2_ros/src/buffer_client.cpp
+++ b/tf2_ros/src/buffer_client.cpp
@@ -150,26 +150,26 @@ geometry_msgs::msg::TransformStamped BufferClient::processResult(
   if (result->error.error != result->error.NO_ERROR) {
     // otherwise, we'll have to throw the appropriate exception
     if (result->error.error == result->error.LOOKUP_ERROR) {
-      throw tf2::LookupException(result->error.error_string);
+      throw tf2::LookupException(std::string(result->error.error_string.c_str()));
     }
 
     if (result->error.error == result->error.CONNECTIVITY_ERROR) {
-      throw tf2::ConnectivityException(result->error.error_string);
+      throw tf2::ConnectivityException(std::string(result->error.error_string.c_str()));
     }
 
     if (result->error.error == result->error.EXTRAPOLATION_ERROR) {
-      throw tf2::ExtrapolationException(result->error.error_string);
+      throw tf2::ExtrapolationException(std::string(result->error.error_string.c_str()));
     }
 
     if (result->error.error == result->error.INVALID_ARGUMENT_ERROR) {
-      throw tf2::InvalidArgumentException(result->error.error_string);
+      throw tf2::InvalidArgumentException(std::string(result->error.error_string.c_str()));
     }
 
     if (result->error.error == result->error.TIMEOUT_ERROR) {
-      throw tf2::TimeoutException(result->error.error_string);
+      throw tf2::TimeoutException(std::string(result->error.error_string.c_str()));
     }
 
-    throw tf2::TransformException(result->error.error_string);
+    throw tf2::TransformException(std::string(result->error.error_string.c_str()));
   }
 
   return result->transform;
diff --git a/tf2_ros/src/buffer_server.cpp b/tf2_ros/src/buffer_server.cpp
index a91de83a..d01bbc69 100644
--- a/tf2_ros/src/buffer_server.cpp
+++ b/tf2_ros/src/buffer_server.cpp
@@ -207,13 +207,13 @@ bool BufferServer::canTransform(GoalHandle gh)
 
   // check whether we need to used the advanced or simple api
   if (!goal->advanced) {
-    return buffer_.canTransform(goal->target_frame, goal->source_frame, source_time_point, nullptr);
+    return buffer_.canTransform(std::string(goal->target_frame.c_str()), std::string(goal->source_frame.c_str()), source_time_point, nullptr);
   }
 
   tf2::TimePoint target_time_point = tf2_ros::fromMsg(goal->target_time);
   return buffer_.canTransform(
-    goal->target_frame, target_time_point,
-    goal->source_frame, source_time_point, goal->fixed_frame, nullptr);
+    std::string(goal->target_frame.c_str()), target_time_point,
+    std::string(goal->source_frame.c_str()), source_time_point, std::string(goal->fixed_frame.c_str()), nullptr);
 }
 
 geometry_msgs::msg::TransformStamped BufferServer::lookupTransform(GoalHandle gh)
@@ -223,13 +223,13 @@ geometry_msgs::msg::TransformStamped BufferServer::lookupTransform(GoalHandle gh
   // check whether we need to used the advanced or simple api
   if (!goal->advanced) {
     return buffer_.lookupTransform(
-      goal->target_frame, goal->source_frame,
+      std::string(goal->target_frame.c_str()), std::string(goal->source_frame.c_str()),
       tf2_ros::fromMsg(goal->source_time));
   }
 
   return buffer_.lookupTransform(
-    goal->target_frame, tf2_ros::fromMsg(goal->target_time),
-    goal->source_frame, tf2_ros::fromMsg(goal->source_time), goal->fixed_frame);
+    std::string(goal->target_frame.c_str()), tf2_ros::fromMsg(goal->target_time),
+    std::string(goal->source_frame.c_str()), tf2_ros::fromMsg(goal->source_time), std::string(goal->fixed_frame.c_str()));
 }
 
 }  // namespace tf2_ros
diff --git a/tf2_ros/src/static_transform_broadcaster.cpp b/tf2_ros/src/static_transform_broadcaster.cpp
deleted file mode 100644
index 6ea8add2..00000000
--- a/tf2_ros/src/static_transform_broadcaster.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/** \author Tully Foote */
-
-#include "tf2_ros/static_transform_broadcaster.h"
-
-#include <vector>
-
-#include "geometry_msgs/msg/transform_stamped.hpp"
-#include "rclcpp/rclcpp.hpp"
-#include "tf2_msgs/msg/tf_message.hpp"
-
-namespace tf2_ros
-{
-
-void StaticTransformBroadcaster::sendTransform(
-  const geometry_msgs::msg::TransformStamped & msgtf)
-{
-  std::vector<geometry_msgs::msg::TransformStamped> v1;
-  v1.push_back(msgtf);
-  sendTransform(v1);
-}
-
-void StaticTransformBroadcaster::sendTransform(
-  const std::vector<geometry_msgs::msg::TransformStamped> & msgtf)
-{
-  for (auto it_in = msgtf.begin(); it_in != msgtf.end(); ++it_in) {
-    bool match_found = false;
-    for (auto it_msg = net_message_.transforms.begin(); it_msg != net_message_.transforms.end();
-      ++it_msg)
-    {
-      if (it_in->child_frame_id == it_msg->child_frame_id) {
-        *it_msg = *it_in;
-        match_found = true;
-        break;
-      }
-    }
-    if (!match_found) {
-      net_message_.transforms.push_back(*it_in);
-    }
-  }
-
-  publisher_->publish(net_message_);
-}
-
-}  // namespace tf2_ros
diff --git a/tf2_ros/src/static_transform_broadcaster_node.cpp b/tf2_ros/src/static_transform_broadcaster_node.cpp
index 37f2cf76..b0c863fc 100644
--- a/tf2_ros/src/static_transform_broadcaster_node.cpp
+++ b/tf2_ros/src/static_transform_broadcaster_node.cpp
@@ -92,7 +92,7 @@ StaticTransformBroadcasterNode::StaticTransformBroadcasterNode(const rclcpp::Nod
     throw std::runtime_error("child_frame_id cannot equal frame_id");
   }
 
-  broadcaster_ = std::make_unique<tf2_ros::StaticTransformBroadcaster>(this);
+  broadcaster_ = std::make_unique<tf2_ros::StaticTransformBroadcaster<std::pmr::polymorphic_allocator<void>>>(this);
 
   // send transform
   broadcaster_->sendTransform(tf_msg);
diff --git a/tf2_ros/src/tf2_echo.cpp b/tf2_ros/src/tf2_echo.cpp
index 44bd777d..428c6247 100644
--- a/tf2_ros/src/tf2_echo.cpp
+++ b/tf2_ros/src/tf2_echo.cpp
@@ -52,12 +52,12 @@ class echoListener
 {
 public:
   tf2_ros::Buffer buffer_;
-  std::shared_ptr<tf2_ros::TransformListener> tfl_;
+  std::shared_ptr<tf2_ros::TransformListener<std::pmr::polymorphic_allocator<void>>> tfl_;
 
   explicit echoListener(rclcpp::Clock::SharedPtr clock)
   : buffer_(clock)
   {
-    tfl_ = std::make_shared<tf2_ros::TransformListener>(buffer_);
+    tfl_ = std::make_shared<tf2_ros::TransformListener<std::pmr::polymorphic_allocator<void>>>(buffer_);
   }
 
   ~echoListener()
diff --git a/tf2_ros/src/tf2_monitor.cpp b/tf2_ros/src/tf2_monitor.cpp
index 936527fa..751dae6d 100644
--- a/tf2_ros/src/tf2_monitor.cpp
+++ b/tf2_ros/src/tf2_monitor.cpp
@@ -60,7 +60,7 @@ public:
 
   rclcpp::Clock::SharedPtr clock_;
   tf2_ros::Buffer buffer_;
-  std::shared_ptr<tf2_ros::TransformListener> tf_;
+  std::shared_ptr<tf2_ros::TransformListener<std::pmr::polymorphic_allocator<void>>> tf_;
 
   tf2_msgs::msg::TFMessage message_;
   std::mutex map_mutex_;
@@ -74,16 +74,16 @@ public:
     double average_offset = 0;
     std::unique_lock<std::mutex> my_lock(map_mutex_);
     for (size_t i = 0; i < message.transforms.size(); i++) {
-      frame_authority_map[message.transforms[i].child_frame_id] = authority;
+      frame_authority_map[std::string(message.transforms[i].child_frame_id.c_str())] = authority;
 
       double offset = clock_->now().seconds() - tf2_ros::timeToSec(
         message.transforms[i].header.stamp);
       average_offset += offset;
 
       std::map<std::string, std::vector<double>>::iterator it = delay_map.find(
-        message.transforms[i].child_frame_id);
+        std::string(message.transforms[i].child_frame_id.c_str()));
       if (it == delay_map.end()) {
-        delay_map[message.transforms[i].child_frame_id] = std::vector<double>(1, offset);
+        delay_map[std::string(message.transforms[i].child_frame_id.c_str())] = std::vector<double>(1, offset);
       } else {
         it->second.push_back(offset);
         if (it->second.size() > 1000) {
@@ -128,7 +128,7 @@ public:
     clock_(node->get_clock()),
     buffer_(clock_, tf2::Duration(tf2::BUFFER_CORE_DEFAULT_CACHE_TIME), node)
   {
-    tf_ = std::make_shared<tf2_ros::TransformListener>(buffer_);
+    tf_ = std::make_shared<tf2_ros::TransformListener<std::pmr::polymorphic_allocator<void>>>(buffer_);
 
     if (using_specific_chain_) {
       std::string warning_msg;
diff --git a/tf2_ros/src/transform_broadcaster.cpp b/tf2_ros/src/transform_broadcaster.cpp
deleted file mode 100644
index ee37b558..00000000
--- a/tf2_ros/src/transform_broadcaster.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-/** \author Tully Foote */
-
-#include "tf2_ros/transform_broadcaster.h"
-
-#include <vector>
-
-#include "geometry_msgs/msg/transform_stamped.hpp"
-#include "rclcpp/rclcpp.hpp"
-#include "tf2_msgs/msg/tf_message.hpp"
-
-namespace tf2_ros
-{
-
-void TransformBroadcaster::sendTransform(const geometry_msgs::msg::TransformStamped & msgtf)
-{
-  std::vector<geometry_msgs::msg::TransformStamped> v1;
-  v1.push_back(msgtf);
-  sendTransform(v1);
-}
-
-void TransformBroadcaster::sendTransform(
-  const std::vector<geometry_msgs::msg::TransformStamped> & msgtf)
-{
-  tf2_msgs::msg::TFMessage message;
-  for (std::vector<geometry_msgs::msg::TransformStamped>::const_iterator it = msgtf.begin();
-    it != msgtf.end(); ++it)
-  {
-    message.transforms.push_back(*it);
-  }
-  publisher_->publish(message);
-}
-
-}  // namespace tf2_ros
diff --git a/tf2_ros/src/transform_listener.cpp b/tf2_ros/src/transform_listener.cpp
deleted file mode 100644
index 3f59d5f0..00000000
--- a/tf2_ros/src/transform_listener.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2008, Willow Garage, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of the Willow Garage, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived from
- *       this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** \author Tully Foote */
-
-#include <memory>
-#include <sstream>
-#include <string>
-#include <thread>
-#include <utility>
-
-#include "tf2_ros/transform_listener.h"
-
-namespace tf2_ros
-{
-
-TransformListener::TransformListener(tf2::BufferCore & buffer, bool spin_thread)
-: buffer_(buffer)
-{
-  // create a unique name for the node
-  std::stringstream sstream;
-  sstream << "transform_listener_impl_" << std::hex << reinterpret_cast<size_t>(this);
-  rclcpp::NodeOptions options;
-  // but specify its name in .arguments to override any __node passed on the command line
-  options.arguments({"--ros-args", "-r", "__node:=" + std::string(sstream.str())});
-  options.start_parameter_event_publisher(false);
-  options.start_parameter_services(false);
-  optional_default_node_ = rclcpp::Node::make_shared("_", options);
-  init(
-    optional_default_node_, spin_thread, DynamicListenerQoS(), StaticListenerQoS(),
-    detail::get_default_transform_listener_sub_options(),
-    detail::get_default_transform_listener_static_sub_options());
-}
-
-TransformListener::~TransformListener()
-{
-  if (spin_thread_) {
-    executor_->cancel();
-    dedicated_listener_thread_->join();
-  }
-}
-
-
-void TransformListener::subscription_callback(
-  const tf2_msgs::msg::TFMessage::ConstSharedPtr msg,
-  bool is_static)
-{
-  const tf2_msgs::msg::TFMessage & msg_in = *msg;
-  // TODO(tfoote) find a way to get the authority
-  std::string authority = "Authority undetectable";
-  for (size_t i = 0u; i < msg_in.transforms.size(); i++) {
-    try {
-      buffer_.setTransform(msg_in.transforms[i], authority, is_static);
-    } catch (const tf2::TransformException & ex) {
-      // /\todo Use error reporting
-      std::string temp = ex.what();
-      RCLCPP_ERROR(
-        node_logging_interface_->get_logger(),
-        "Failure to set received transform from %s to %s with error: %s\n",
-        msg_in.transforms[i].child_frame_id.c_str(),
-        msg_in.transforms[i].header.frame_id.c_str(), temp.c_str());
-    }
-  }
-}
-
-}  // namespace tf2_ros
